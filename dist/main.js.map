{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"React\"","webpack:///./src/IPathfinder.tsx","webpack:///./src/Algorithms/PathfindingAlgorithm.tsx","webpack:///./src/Algorithms/DataStructures/PriorityQueue.tsx","webpack:///./src/mazes/MazeGenerator.ts","webpack:///./src/mazes/wallCarver.ts","webpack:///./src/index.tsx","webpack:///external \"ReactDOM\"","webpack:///./src/components/App.tsx","webpack:///./src/Pathfinder.tsx","webpack:///./src/Cell.tsx","webpack:///./src/Navbar.tsx","webpack:///./src/Algorithms/Dijkstra.tsx","webpack:///./src/Algorithms/DFS.ts","webpack:///./src/Algorithms/DataStructures/Stack.tsx","webpack:///./src/Algorithms/BFS.tsx","webpack:///./src/Algorithms/DataStructures/Queue.ts","webpack:///./src/mazes/RecursiveDivision.ts","webpack:///./src/mazes/RecursiveBacktracking.ts","webpack:///./src/mazes/Ellers.ts","webpack:///./src/Algorithms/AStar.ts","webpack:///./src/Algorithms/Perlin/PerlinNoise.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","React","screenWidth","Math","floor","window","innerWidth","screenHeight","innerHeight","GRID_W","GRID_H","DEFAULT_START_POS","x","y","DEFAULT_FINISH_POS","UPDATE_RATE","MouseState","NodeType","pathValues","Map","finalPath","visitedNodesInOrder","this","slice","length","grid","position","neighbors","push","filter","neighbor","nodeType","Wall","isVisited","cornerCheck","current","weightDifference","weight","pow","sqrt","abs","hash","pathData","newPathData","set","finishPos","curPosition","previousNode","unshift","pos1","pos2","toString","heap","val","priority","replace","undefined","tmp","found","find","foundNode","tuple","shift","pop","map","_","values","walls","topBorderWall","botBorderWall","leftBorderWall","rightBorderWall","min","max","random","wallsCreatedInOrder","ADJUSTED_WIDTH","ADJUSTED_HEIGHT","WallCarver","positionBetween","addWall","middleWall","crossWall","ReactDOM","render","document","getElementById","App","Component","props","super","state","className","Pathfinder","references","Array","fill","createRef","row","curRow","col","newNode","Unvisited","startPos","midpointPos","mouseState","PlacingWall","isMouseDown","updateLock","perlinToggle","prevAlgorithm","nextProps","nextState","node","eventType","Disabled","onMouseDown","onMouseUp","onMouseEnter","MovingStart","MovingFinish","MovingMidpoint","isEmpty","isStart","isFinish","isMidpoint","RemovingWall","clearPath","setState","recalculatePath","visitedPaths","finalPaths","calculatePath","produceVisitedInOrder","produceFinalPath","idx","visited","pos","VisitedOne","VisitedOverlap","VisitedTwo","path","ShortestPath","algorithm","visualiseAlgorithm","visitedInOrder","shortestPath","lockRender","visualiseVisited","visualisePath","concat","unlockRender","count","Promise","resolve","setTimeout","ref","includes","perlin","seed","newWeight","noise","mazeGenerator","setupWalls","getSetup","generateWalls","setupStartingWalls","visualizeMaze","wallAlreadyPlaced","wall","nextMidPoint","performAlgorithm","generateLandscape","generateMaze","rowIdx","cell","colIdx","updateMouseState","setMidpoint","nodeRef","Cell","event","nativeEvent","which","type","rbgVal","backgroundColor","convertWeightToGreyscale","id","style","handleMouseEvent","onContextMenu","preventDefault","Navbar","onClick","Dijkstra","minHeap","PriorityQueue","reset","setMap","insert","size","closestPosition","markAsVisited","equalPosition","findShortestPath","getNeighbors","closestDistance","newDistance","getDistance","neighborPathData","forEach","nodePosition","Infinity","clear","DFS","stack","reverse","data","top","element","BFS","queue","RecursiveDivision","lr","divide","ul","splitIdx","gap","newLr","newUl","width","height","vertical","randomEven","console","log","randomOdd","getRandom","RecursiveBacktracking","randomStartingPos","carveWalls","visit","getUnvisitedNeighbors","isVisisted","placeWallBetweenPositions","positionInBounds","randomisePositions","positions","sort","has","Ellers","currentRow","Uptree","mergeRow","prevRow","extendToNextRow","isRoot","addEntry","addTopWall","randomBool","getEntry","sameClass","mergeSets","addRightWall","set1","set2","getRoot","index1","index2","index","AStar","setNeighbors","start","finish","costSoFar","distanceFromStart","distanceFromFinish","totalCost","prevPathData","permutation","z","X","Y","Z","u","fade","v","w","A","AA","AB","B","BA","BB","scale","lerp","grad","a","b","h"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","module.exports = React;","import PathfindingAlgorithm from './Algorithms/PathfindingAlgorithm';\r\n\r\nconst screenWidth = Math.floor((0.95 * window.innerWidth) / 25);\r\nconst screenHeight = Math.floor((0.8 * window.innerHeight) / 25);\r\nexport const GRID_W = screenWidth % 2 === 0 ? screenWidth - 1 : screenWidth;\r\nexport const GRID_H = screenHeight % 2 === 0 ? screenHeight - 1 : screenHeight;\r\nexport const DEFAULT_START_POS: Position = { x: Math.floor(GRID_W / 4), y: Math.floor(GRID_H / 2) };\r\nexport const DEFAULT_FINISH_POS: Position = { x: GRID_W - DEFAULT_START_POS.x - 1, y: DEFAULT_START_POS.y };\r\nexport const UPDATE_RATE = 15;\r\n\r\nexport interface Position {\r\n    x: number;\r\n    y: number;\r\n}\r\nexport enum MouseState {\r\n    PlacingWall,\r\n    RemovingWall,\r\n    MovingStart,\r\n    MovingFinish,\r\n    MovingMidpoint,\r\n    Disabled,\r\n}\r\nexport enum NodeType {\r\n    Unvisited,\r\n    VisitedOne,\r\n    VisitedTwo,\r\n    VisitedOverlap,\r\n    Wall,\r\n    ShortestPath,\r\n}\r\nexport interface Node {\r\n    position: Position;\r\n    nodeType: NodeType;\r\n    weight: number;\r\n}\r\n","import { GRID_H, GRID_W, Node, NodeType, Position } from '../IPathfinder';\r\n\r\nexport interface PathData {\r\n    isVisited: boolean;\r\n    shortestPath?: number;\r\n    previousNode?: Position;\r\n}\r\n\r\nexport default abstract class PathfindingAlgorithm {\r\n    pathValues: Map<string, PathData> = new Map<string, PathData>();\r\n    finalPath: Array<Position> = [];\r\n    visitedNodesInOrder: Array<Position> = [];\r\n\r\n    protected abstract setMap(grid: Node[][], startPos?: Position): void;\r\n\r\n    public abstract calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void;\r\n\r\n    public produceVisitedInOrder(): Position[] {\r\n        return this.visitedNodesInOrder.slice(1, this.visitedNodesInOrder.length - 1);\r\n    }\r\n\r\n    public produceFinalPath(): Position[] {\r\n        return this.finalPath.slice(1, this.visitedNodesInOrder.length - 1);\r\n    }\r\n\r\n    protected getNeighbors(grid: Node[][], position: Position): Array<Position> {\r\n        let neighbors: Array<Position> = [];\r\n        neighbors.push({ x: position.x + 1, y: position.y });\r\n        neighbors.push({ x: position.x, y: position.y + 1 });\r\n        neighbors.push({ x: position.x, y: position.y - 1 });\r\n        neighbors.push({ x: position.x - 1, y: position.y });\r\n\r\n        neighbors.push({ x: position.x - 1, y: position.y + 1 });\r\n        neighbors.push({ x: position.x + 1, y: position.y + 1 });\r\n        neighbors.push({ x: position.x + 1, y: position.y - 1 });\r\n        neighbors.push({ x: position.x - 1, y: position.y - 1 });\r\n\r\n        return neighbors.filter((neighbor) => {\r\n            return (\r\n                neighbor.x >= 0 &&\r\n                neighbor.x < GRID_W &&\r\n                neighbor.y >= 0 &&\r\n                neighbor.y < GRID_H &&\r\n                grid[neighbor.y][neighbor.x].nodeType !== NodeType.Wall &&\r\n                !this.isVisited(neighbor) &&\r\n                this.cornerCheck(position, neighbor, grid)\r\n            );\r\n        });\r\n    }\r\n\r\n    private cornerCheck(position: Position, neighbor: Position, grid: Node[][]): boolean {\r\n        return (\r\n            grid[position.y][neighbor.x].nodeType !== NodeType.Wall ||\r\n            grid[neighbor.y][position.x].nodeType !== NodeType.Wall\r\n        );\r\n    }\r\n\r\n    protected getDistance(grid: Node[][], current: Position, neighbor: Position): number {\r\n        let weightDifference = grid[neighbor.y][neighbor.x].weight - grid[current.y][current.x].weight;\r\n        return (\r\n            Math.pow(10000, weightDifference) *\r\n            Math.sqrt(Math.pow(Math.abs(current.x - neighbor.x), 2) + Math.pow(Math.abs(current.y - neighbor.y), 2))\r\n        );\r\n    }\r\n\r\n    protected isVisited(position: Position): boolean {\r\n        return this.pathValues.get(this.hash(position)).isVisited;\r\n    }\r\n\r\n    protected markAsVisited(position: Position): void {\r\n        this.visitedNodesInOrder.push(position);\r\n        let pathData: PathData = this.pathValues.get(this.hash(position));\r\n        let newPathData: PathData = {\r\n            ...pathData,\r\n            isVisited: true,\r\n        };\r\n        this.pathValues.set(this.hash(position), newPathData);\r\n    }\r\n\r\n    protected findShortestPath(finishPos: Position): void {\r\n        for (\r\n            let curPosition = finishPos;\r\n            curPosition != null;\r\n            curPosition = this.pathValues.get(this.hash(curPosition)).previousNode\r\n        ) {\r\n            this.finalPath.unshift(curPosition);\r\n        }\r\n    }\r\n\r\n    protected equalPosition(pos1: Position, pos2: Position) {\r\n        return pos1.x === pos2.x && pos1.y === pos2.y;\r\n    }\r\n\r\n    protected hash(position: Position): string {\r\n        return position.x.toString() + '-' + position.y.toString();\r\n    }\r\n\r\n    protected clear(): void {\r\n        this.visitedNodesInOrder = [];\r\n        this.finalPath = [];\r\n        this.pathValues = new Map<string, PathData>();\r\n    }\r\n\r\n    protected abstract reset(): void;\r\n}\r\n","export interface Node {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport type Tuple<T> = [T, number];\r\n\r\nexport class PriorityQueue<T extends Node> {\r\n    heap: Tuple<T>[] = [];\r\n\r\n    constructor() {}\r\n\r\n    insert(val: T, priority: number, replace?: boolean) {\r\n        replace = replace !== undefined;\r\n\r\n        if (!this.heap.length || this.heap[this.heap.length - 1][1] > priority) {\r\n            this.heap.push([val, priority]);\r\n            return this.heap;\r\n        }\r\n\r\n        const tmp: Tuple<T>[] = [];\r\n        let found = false;\r\n\r\n        for (let i = 0; i < this.heap.length; i++) {\r\n            const p = this.heap[i][1];\r\n            const n = this.heap[i][0];\r\n\r\n            if (priority >= p && !found) {\r\n                tmp.push([val, priority]);\r\n                found = true;\r\n            }\r\n\r\n            if (!(replace && n.x === val.x && n.y === val.y)) {\r\n                tmp.push(this.heap[i]);\r\n            }\r\n        }\r\n        return (this.heap = tmp);\r\n    }\r\n\r\n    has({ x, y }: T) {\r\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\r\n\r\n        return !!foundNode;\r\n    }\r\n\r\n    get({ x, y }: T) {\r\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\r\n\r\n        return foundNode && foundNode[1];\r\n    }\r\n\r\n    shift(priority: boolean) {\r\n        const tuple = this.heap.shift();\r\n        if (priority) {\r\n            return tuple;\r\n        }\r\n\r\n        return tuple ? tuple[0] : undefined;\r\n    }\r\n\r\n    pop() {\r\n        return this.heap.pop()[0];\r\n    }\r\n\r\n    priorities() {\r\n        return this.heap.map(([_, p]) => p);\r\n    }\r\n\r\n    values() {\r\n        return this.heap.map(([val]) => val);\r\n    }\r\n\r\n    size() {\r\n        return this.heap.length;\r\n    }\r\n\r\n    toArray(values: boolean) {\r\n        if (values) {\r\n            return this.heap.map(([val]) => val);\r\n        }\r\n        return this.heap;\r\n    }\r\n}\r\n","import { Position, GRID_H, GRID_W } from './../IPathfinder';\r\nexport default abstract class MazeGenerator {\r\n    wallsCreatedInOrder: Position[];\r\n    public abstract generateWalls(): Position[];\r\n    public getSetup(): Position[] {\r\n        let walls: Position[] = [];\r\n        for (let i = 0; i < GRID_W; i++) {\r\n            let topBorderWall: Position = { x: i, y: 0 };\r\n            let botBorderWall: Position = { x: i, y: GRID_H - 1 };\r\n            walls.push(topBorderWall);\r\n            walls.push(botBorderWall);\r\n        }\r\n        for (let i = 1; i < GRID_H - 1; i++) {\r\n            let leftBorderWall: Position = { x: 0, y: i };\r\n            let rightBorderWall: Position = { x: GRID_W - 1, y: i };\r\n            walls.push(leftBorderWall);\r\n            walls.push(rightBorderWall);\r\n        }\r\n        return walls;\r\n    }\r\n    protected getRandom(min: number, max: number): number {\r\n        return min + Math.floor((max - min + 1) * Math.random());\r\n    }\r\n    protected addWall(position: Position) {\r\n        this.wallsCreatedInOrder.push(position);\r\n    }\r\n}\r\n","import MazeGenerator from './MazeGenerator';\r\nimport { Position, GRID_W, GRID_H } from '../IPathfinder';\r\n\r\nexport const ADJUSTED_WIDTH = (GRID_W - 1) / 2;\r\nexport const ADJUSTED_HEIGHT = (GRID_H - 1) / 2;\r\n\r\nexport default abstract class WallCarver extends MazeGenerator {\r\n    protected placeWallBetweenPositions(current: Position, neighbor: Position): void {\r\n        let positionBetween: Position = {\r\n            x: Math.floor((current.x + neighbor.x) / 2),\r\n            y: Math.floor((current.y + neighbor.y) / 2),\r\n        };\r\n        this.addWall(positionBetween);\r\n    }\r\n\r\n    protected positionInBounds(position: Position): boolean {\r\n        return position.x > 0 && position.x < GRID_W - 1 && position.y > 0 && position.y < GRID_H - 1;\r\n    }\r\n\r\n    public getSetup(): Position[] {\r\n        let walls: Position[] = [];\r\n        for (let i = 0; i < GRID_W; i++) {\r\n            let topBorderWall: Position = { x: i, y: 0 };\r\n            let botBorderWall: Position = { x: i, y: GRID_H - 1 };\r\n            walls.push(topBorderWall);\r\n            walls.push(botBorderWall);\r\n        }\r\n        for (let x = 0; x < GRID_W; x += 2) {\r\n            for (let y = 1; y < GRID_H - 1; y++) {\r\n                let middleWall: Position = { x: x, y: y };\r\n                walls.push(middleWall);\r\n            }\r\n        }\r\n        for (let x = 1; x < GRID_W - 1; x += 2) {\r\n            for (let y = 2; y < GRID_H - 2; y += 2) {\r\n                let crossWall: Position = { x: x, y: y };\r\n                walls.push(crossWall);\r\n            }\r\n        }\r\n        return walls;\r\n    }\r\n}\r\n","import * as React from 'react';\r\nimport * as ReactDOM from 'react-dom';\r\nimport App from './components/App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n","module.exports = ReactDOM;","import * as React from 'react';\r\nimport Pathfinder from '../Pathfinder';\r\nimport { Component } from 'react';\r\n\r\nexport default class App extends Component {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render(): any {\r\n        return (\r\n            <div className=\"app\">\r\n                <Pathfinder />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import * as React from 'react';\r\nimport {\r\n    Node,\r\n    NodeType,\r\n    Position,\r\n    MouseState,\r\n    GRID_W,\r\n    GRID_H,\r\n    DEFAULT_START_POS,\r\n    DEFAULT_FINISH_POS,\r\n    UPDATE_RATE,\r\n} from './IPathfinder';\r\nimport { Component, createRef, RefObject } from 'react';\r\nimport Cell from './Cell';\r\nimport Navbar from './Navbar';\r\nimport PathfindingAlgorithm from './Algorithms/PathfindingAlgorithm';\r\nimport PerlinNoise from './Algorithms/Perlin/PerlinNoise';\r\nimport MazeGenerator from './mazes/MazeGenerator';\r\n\r\ninterface State {\r\n    grid: Node[][];\r\n    startPos: Position;\r\n    finishPos: Position;\r\n    midpointPos: Position;\r\n    mouseState: MouseState;\r\n    isMouseDown: boolean;\r\n    updateLock: boolean;\r\n    perlinToggle: boolean;\r\n    prevAlgorithm: PathfindingAlgorithm;\r\n}\r\n\r\nexport default class Pathfinder extends Component<{}, State> {\r\n    references: Array<Array<RefObject<HTMLDivElement> | any>> = Array(GRID_H)\r\n        .fill([])\r\n        .map(() =>\r\n            Array(GRID_W)\r\n                .fill(0)\r\n                .map(() => createRef()),\r\n        );\r\n    constructor(props: any) {\r\n        super(props);\r\n        let grid: Node[][] = [];\r\n        for (let row = 0; row < GRID_H; row++) {\r\n            let curRow: Array<Node> = [];\r\n            for (let col = 0; col < GRID_W; col++) {\r\n                let newNode: Node = { position: { x: col, y: row }, nodeType: NodeType.Unvisited, weight: 0 };\r\n                curRow.push(newNode);\r\n            }\r\n            grid.push(curRow);\r\n        }\r\n        this.state = {\r\n            grid: grid,\r\n            startPos: DEFAULT_START_POS,\r\n            finishPos: DEFAULT_FINISH_POS,\r\n            midpointPos: null,\r\n            mouseState: MouseState.PlacingWall,\r\n            isMouseDown: false,\r\n            updateLock: false,\r\n            perlinToggle: false,\r\n            prevAlgorithm: null,\r\n        };\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps: Readonly<{}>, nextState: Readonly<State>): boolean {\r\n        return !nextState.updateLock;\r\n    }\r\n\r\n    clearPath(): Node[][] {\r\n        let grid: Node[][] = this.state.grid;\r\n        grid = grid.map((row) => {\r\n            return row.map((node) => {\r\n                return {\r\n                    ...node,\r\n                    nodeType: node.nodeType === NodeType.Wall ? NodeType.Wall : NodeType.Unvisited,\r\n                };\r\n            });\r\n        });\r\n        return grid;\r\n    }\r\n\r\n    updateMouseState(position: Position, eventType: string): void {\r\n        if (this.state.mouseState === MouseState.Disabled) return;\r\n        switch (eventType) {\r\n            case 'mousedown': {\r\n                this.onMouseDown(position);\r\n                break;\r\n            }\r\n            case 'mouseup': {\r\n                this.onMouseUp();\r\n                break;\r\n            }\r\n            case 'mouseenter': {\r\n                this.onMouseEnter(position);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private onMouseDown(position: Position) {\r\n        let { grid, mouseState, isMouseDown, prevAlgorithm } = this.state;\r\n        let nodeType: NodeType = grid[position.y][position.x].nodeType;\r\n        if (\r\n            (mouseState === MouseState.MovingStart ||\r\n                mouseState === MouseState.MovingFinish ||\r\n                mouseState === MouseState.MovingMidpoint) &&\r\n            !this.isEmpty(position)\r\n        )\r\n            return;\r\n\r\n        if (this.isStart(position)) {\r\n            mouseState = MouseState.MovingStart;\r\n        } else if (this.isFinish(position)) {\r\n            mouseState = MouseState.MovingFinish;\r\n        } else if (this.isMidpoint(position)) {\r\n            mouseState = MouseState.MovingMidpoint;\r\n        } else if (nodeType === NodeType.Unvisited) {\r\n            mouseState = MouseState.PlacingWall;\r\n        } else {\r\n            mouseState = MouseState.RemovingWall;\r\n        }\r\n\r\n        if (this.isEmpty(position)) {\r\n            if (prevAlgorithm !== null) {\r\n                grid = this.clearPath();\r\n                prevAlgorithm = null;\r\n            }\r\n            if (nodeType === NodeType.Wall) {\r\n                grid[position.y][position.x].nodeType = NodeType.Unvisited;\r\n            } else {\r\n                grid[position.y][position.x].nodeType = NodeType.Wall;\r\n            }\r\n        }\r\n        isMouseDown = true;\r\n        this.setState({ grid: grid, mouseState: mouseState, isMouseDown: isMouseDown, prevAlgorithm: prevAlgorithm });\r\n    }\r\n\r\n    private onMouseUp() {\r\n        let mouseState = MouseState.PlacingWall;\r\n        let isMouseDown = false;\r\n        this.setState({ mouseState: mouseState, isMouseDown: isMouseDown });\r\n    }\r\n\r\n    private onMouseEnter(position: Position) {\r\n        let { grid, startPos, finishPos, midpointPos, mouseState, isMouseDown, prevAlgorithm } = this.state;\r\n        if (!isMouseDown || this.isStart(position) || this.isFinish(position) || this.isMidpoint(position)) return;\r\n\r\n        switch (mouseState) {\r\n            case MouseState.MovingStart:\r\n                startPos = position;\r\n                if (prevAlgorithm !== null) {\r\n                    this.recalculatePath(startPos, finishPos, midpointPos, prevAlgorithm);\r\n                } else {\r\n                    this.setState({ startPos: startPos });\r\n                }\r\n                break;\r\n            case MouseState.MovingFinish:\r\n                finishPos = position;\r\n                if (prevAlgorithm !== null) {\r\n                    this.recalculatePath(startPos, finishPos, midpointPos, prevAlgorithm);\r\n                } else {\r\n                    this.setState({ finishPos: finishPos });\r\n                }\r\n                break;\r\n            case MouseState.MovingMidpoint:\r\n                midpointPos = position;\r\n                if (prevAlgorithm !== null) {\r\n                    this.recalculatePath(startPos, finishPos, midpointPos, prevAlgorithm);\r\n                } else {\r\n                    this.setState({ midpointPos: midpointPos });\r\n                }\r\n                break;\r\n            case MouseState.PlacingWall:\r\n                grid[position.y][position.x].nodeType = NodeType.Wall;\r\n                this.setState({ grid: grid });\r\n                break;\r\n            case MouseState.RemovingWall:\r\n                grid[position.y][position.x].nodeType = NodeType.Unvisited;\r\n                this.setState({ grid: grid });\r\n                break;\r\n        }\r\n    }\r\n\r\n    private recalculatePath(\r\n        startPos: Position,\r\n        finishPos: Position,\r\n        midpointPos: Position,\r\n        prevAlgorithm: PathfindingAlgorithm,\r\n    ) {\r\n        let grid: Node[][] = this.clearPath();\r\n        let visitedPaths: Position[][] = [];\r\n        let finalPaths: Position[][] = [];\r\n        if (midpointPos === null) {\r\n            prevAlgorithm.calculatePath(grid, startPos, finishPos);\r\n            visitedPaths.push(prevAlgorithm.produceVisitedInOrder());\r\n            finalPaths.push(prevAlgorithm.produceFinalPath());\r\n        } else {\r\n            prevAlgorithm.calculatePath(grid, startPos, midpointPos);\r\n            visitedPaths.push(prevAlgorithm.produceVisitedInOrder());\r\n            finalPaths.push(prevAlgorithm.produceFinalPath());\r\n\r\n            prevAlgorithm.calculatePath(grid, midpointPos, finishPos);\r\n            visitedPaths.push(prevAlgorithm.produceVisitedInOrder());\r\n            finalPaths.push(prevAlgorithm.produceFinalPath());\r\n        }\r\n\r\n        for (let idx = 0; idx < visitedPaths.length; idx++) {\r\n            let visited: Position[] = visitedPaths[idx];\r\n            for (let pos of visited) {\r\n                if (idx === 0) {\r\n                    grid[pos.y][pos.x].nodeType = NodeType.VisitedOne;\r\n                } else if (grid[pos.y][pos.x].nodeType === NodeType.VisitedOne) {\r\n                    grid[pos.y][pos.x].nodeType = NodeType.VisitedOverlap;\r\n                } else {\r\n                    grid[pos.y][pos.x].nodeType = NodeType.VisitedTwo;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let path of finalPaths) {\r\n            for (let pos of path) {\r\n                grid[pos.y][pos.x].nodeType = NodeType.ShortestPath;\r\n            }\r\n        }\r\n\r\n        this.setState({ grid: grid, startPos: startPos, finishPos: finishPos, midpointPos: midpointPos });\r\n    }\r\n\r\n    private isEmpty(position: Position) {\r\n        return !this.isStart(position) && !this.isFinish(position) && !this.isMidpoint(position);\r\n    }\r\n\r\n    private isStart(position: Position) {\r\n        return position.x === this.state.startPos.x && position.y === this.state.startPos.y;\r\n    }\r\n\r\n    private isFinish(position: Position) {\r\n        return position.x === this.state.finishPos.x && position.y === this.state.finishPos.y;\r\n    }\r\n\r\n    private isMidpoint(position: Position) {\r\n        return (\r\n            this.state.midpointPos !== null &&\r\n            position.x === this.state.midpointPos.x &&\r\n            position.y === this.state.midpointPos.y\r\n        );\r\n    }\r\n\r\n    private performAlgorithm(algorithm: PathfindingAlgorithm): void {\r\n        let midpointPos = this.state.midpointPos;\r\n        this.setState({ prevAlgorithm: algorithm, mouseState: MouseState.Disabled });\r\n        let visitedPaths: Position[][] = [];\r\n        let finalPaths: Position[][] = [];\r\n        if (midpointPos === null) {\r\n            algorithm.calculatePath(this.state.grid, this.state.startPos, this.state.finishPos);\r\n            visitedPaths.push(algorithm.produceVisitedInOrder());\r\n            finalPaths.push(algorithm.produceFinalPath());\r\n        } else {\r\n            algorithm.calculatePath(this.state.grid, this.state.startPos, this.state.midpointPos);\r\n            visitedPaths.push(algorithm.produceVisitedInOrder());\r\n            finalPaths.push(algorithm.produceFinalPath());\r\n\r\n            algorithm.calculatePath(this.state.grid, this.state.midpointPos, this.state.finishPos);\r\n            visitedPaths.push(algorithm.produceVisitedInOrder());\r\n            finalPaths.push(algorithm.produceFinalPath());\r\n        }\r\n\r\n        this.visualiseAlgorithm(visitedPaths, finalPaths);\r\n        this.setState({ mouseState: MouseState.PlacingWall });\r\n    }\r\n\r\n    private visualiseAlgorithm(visitedInOrder: Position[][], shortestPath: Position[][]): void {\r\n        (async () => {\r\n            this.lockRender();\r\n            for (let idx = 0; idx < visitedInOrder.length; idx++) {\r\n                let visited: Position[] = visitedInOrder[idx];\r\n                await this.visualiseVisited(visited, idx);\r\n            }\r\n\r\n            await this.visualisePath([].concat(...shortestPath));\r\n            this.unlockRender();\r\n        })();\r\n    }\r\n\r\n    private visualiseVisited(visitedInOrder: Array<Position>, count: number): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            for (let i = 0; i <= visitedInOrder.length; i++) {\r\n                setTimeout(() => {\r\n                    if (i === visitedInOrder.length) {\r\n                        setTimeout(() => {\r\n                            resolve();\r\n                        }, UPDATE_RATE);\r\n                    } else {\r\n                        let position: Position = visitedInOrder[i];\r\n                        let ref: RefObject<HTMLDivElement> = this.references[position.y][position.x];\r\n                        let className: string = ref.current.className;\r\n                        if (\r\n                            !className.includes('cell-start') &&\r\n                            !className.includes('cell-finish') &&\r\n                            !className.includes('cell-midpoint')\r\n                        ) {\r\n                            if (className.includes('cell-visited-0')) {\r\n                                ref.current.className = `cell cell-visited-overlap`;\r\n                            } else {\r\n                                ref.current.className = `cell cell-visited-${count}`;\r\n                            }\r\n                            let grid: Node[][] = this.state.grid;\r\n                            if (count === 0) {\r\n                                grid[position.y][position.x].nodeType = NodeType.VisitedOne;\r\n                            } else if (grid[position.y][position.x].nodeType === NodeType.VisitedOne) {\r\n                                grid[position.y][position.x].nodeType = NodeType.VisitedOverlap;\r\n                            } else {\r\n                                grid[position.y][position.x].nodeType = NodeType.VisitedTwo;\r\n                            }\r\n                            this.setState({ grid: grid });\r\n                        }\r\n                    }\r\n                }, UPDATE_RATE * i);\r\n            }\r\n        });\r\n    }\r\n\r\n    private visualisePath(shortestPath: Position[]): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            for (let i = 0; i <= shortestPath.length; i++) {\r\n                setTimeout(() => {\r\n                    if (i === shortestPath.length) {\r\n                        setTimeout(() => {\r\n                            resolve();\r\n                        }, UPDATE_RATE);\r\n                    } else {\r\n                        let position: Position = shortestPath[i];\r\n                        let ref: RefObject<HTMLDivElement> = this.references[position.y][position.x];\r\n                        let className: string = ref.current.className;\r\n                        if (\r\n                            !className.includes('cell-start') &&\r\n                            !className.includes('cell-finish') &&\r\n                            !className.includes('cell-midpoint')\r\n                        ) {\r\n                            ref.current.className = 'cell cell-shortestPath';\r\n                            let grid: Node[][] = this.state.grid;\r\n                            grid[position.y][position.x].nodeType = NodeType.ShortestPath;\r\n                            this.setState({ grid: grid });\r\n                        }\r\n                    }\r\n                }, UPDATE_RATE * i);\r\n            }\r\n        });\r\n    }\r\n\r\n    private lockRender() {\r\n        this.setState({ updateLock: true });\r\n    }\r\n\r\n    private unlockRender() {\r\n        this.setState({ updateLock: false });\r\n    }\r\n\r\n    private generateLandscape() {\r\n        const STEEPNESS: number = 0.2;\r\n        const perlin: PerlinNoise = new PerlinNoise();\r\n        const seed: number = Math.floor(Math.random() * 10000);\r\n\r\n        let grid: Node[][] = this.state.grid;\r\n        for (let y: number = 0; y < GRID_H; y++) {\r\n            for (let x: number = 0; x < GRID_W; x++) {\r\n                let newWeight = perlin.noise(x * STEEPNESS + seed, y * STEEPNESS + seed, 0);\r\n                grid[y][x].weight = newWeight;\r\n            }\r\n        }\r\n        this.setState({ grid: grid });\r\n    }\r\n\r\n    private generateMaze(mazeGenerator: MazeGenerator): void {\r\n        (async () => {\r\n            this.lockRender();\r\n            let setupWalls: Position[] = mazeGenerator.getSetup();\r\n            let walls: Position[] = mazeGenerator.generateWalls();\r\n            await this.setupStartingWalls(setupWalls);\r\n            await this.visualizeMaze(walls);\r\n            this.unlockRender();\r\n            this.setState({ mouseState: MouseState.PlacingWall });\r\n        })();\r\n    }\r\n\r\n    private setupStartingWalls(walls: Position[]): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            for (let i = 0; i <= walls.length; i++) {\r\n                if (i === walls.length) {\r\n                    setTimeout(() => {\r\n                        resolve();\r\n                    }, 1000);\r\n                } else {\r\n                    let grid: Node[][] = this.state.grid;\r\n                    let position = walls[i];\r\n                    let ref: RefObject<HTMLDivElement> = this.references[position.y][position.x];\r\n                    let className = ref.current.className;\r\n                    grid[position.y][position.x].nodeType = NodeType.Wall;\r\n                    if (\r\n                        !className.includes('cell-start') &&\r\n                        !className.includes('cell-finish') &&\r\n                        !className.includes('cell-midpoint')\r\n                    ) {\r\n                        ref.current.className = 'cell cell-wall';\r\n                    }\r\n                    this.setState({ grid: grid });\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private visualizeMaze(walls: Position[]): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            for (let i = 0; i <= walls.length; i++) {\r\n                setTimeout(() => {\r\n                    if (i === walls.length) {\r\n                        setTimeout(() => {\r\n                            resolve();\r\n                        }, UPDATE_RATE);\r\n                    } else {\r\n                        let grid: Node[][] = this.state.grid;\r\n                        let position: Position = walls[i];\r\n                        let ref: RefObject<HTMLDivElement> = this.references[position.y][position.x];\r\n                        let className: string = ref.current.className;\r\n                        if (this.wallAlreadyPlaced(position)) {\r\n                            if (!className.includes('cell-start') && !className.includes('cell-finish')) {\r\n                                ref.current.className = 'cell cell-unvisited';\r\n                            }\r\n                            grid[position.y][position.x].nodeType = NodeType.Unvisited;\r\n                        } else {\r\n                            if (\r\n                                !className.includes('cell-start') &&\r\n                                !className.includes('cell-finish') &&\r\n                                !className.includes('cell-midpoint')\r\n                            ) {\r\n                                ref.current.className = 'cell cell-wall';\r\n                            }\r\n                            grid[position.y][position.x].nodeType = NodeType.Wall;\r\n                        }\r\n\r\n                        this.setState({ grid: grid });\r\n                    }\r\n                }, UPDATE_RATE * i);\r\n            }\r\n        });\r\n    }\r\n\r\n    private wallAlreadyPlaced(wall: Position): boolean {\r\n        const grid = this.state.grid;\r\n        return grid[wall.y][wall.x].nodeType === NodeType.Wall;\r\n    }\r\n\r\n    setMidpoint(position: Position): void {\r\n        let prevAlgorithm = this.state.prevAlgorithm;\r\n        let grid = this.state.grid;\r\n        if (!this.isStart(position) && !this.isFinish(position)) {\r\n            let nextMidPoint: Position;\r\n            if (this.isMidpoint(position)) {\r\n                nextMidPoint = null;\r\n            } else {\r\n                nextMidPoint = position;\r\n            }\r\n            //\r\n            if (prevAlgorithm !== null) {\r\n                prevAlgorithm = null;\r\n                grid = this.clearPath();\r\n            }\r\n            //\r\n            this.setState({ grid: grid, prevAlgorithm: prevAlgorithm, midpointPos: nextMidPoint });\r\n        }\r\n    }\r\n\r\n    public render(): any {\r\n        const grid = this.state.grid;\r\n        return (\r\n            <div>\r\n                <Navbar\r\n                    performAlgorithm={(algorithm: PathfindingAlgorithm) => this.performAlgorithm(algorithm)}\r\n                    clearPath={() => this.setState({ prevAlgorithm: null, grid: this.clearPath() })}\r\n                    generateLandscape={() => this.generateLandscape()}\r\n                    generateMaze={(mazeGenerator: MazeGenerator) => this.generateMaze(mazeGenerator)}\r\n                />\r\n                <div className=\"grid\">\r\n                    {grid.map((row: Array<Node>, rowIdx) => {\r\n                        return (\r\n                            <div className=\"grid-row\" key={rowIdx}>\r\n                                {row.map((cell: Node, colIdx) => {\r\n                                    let position: Position = { x: colIdx, y: rowIdx };\r\n                                    return (\r\n                                        <Cell\r\n                                            position={{ x: colIdx, y: rowIdx }}\r\n                                            isStart={this.isStart(position)}\r\n                                            isFinish={this.isFinish(position)}\r\n                                            isMidpoint={this.isMidpoint(position)}\r\n                                            nodeType={cell.nodeType}\r\n                                            weight={cell.weight}\r\n                                            updateMouseState={(position: Position, eventType: string) =>\r\n                                                this.updateMouseState(position, eventType)\r\n                                            }\r\n                                            setMidpoint={(position: Position) => this.setMidpoint(position)}\r\n                                            nodeRef={this.references[rowIdx][colIdx]}\r\n                                            key={colIdx}\r\n                                        />\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import * as React from 'react';\r\nimport { Component, RefObject } from 'react';\r\nimport { NodeType, Position } from './IPathfinder';\r\n\r\ninterface Props {\r\n    position: Position;\r\n    isStart: boolean;\r\n    isFinish: boolean;\r\n    isMidpoint: boolean;\r\n    nodeType: NodeType;\r\n    weight: number;\r\n    updateMouseState: (position: Position, eventType: string) => void;\r\n    setMidpoint: (position: Position) => void;\r\n    nodeRef: (ref: RefObject<HTMLDivElement> | any) => void;\r\n}\r\n\r\nexport default class Cell extends Component<Props> {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    handleMouseEvent(event: React.MouseEvent<HTMLElement>): void {\r\n        let position: Position = this.props.position;\r\n        if (event.nativeEvent.which === 1) {\r\n            let eventType: string = event.type;\r\n            this.props.updateMouseState(position, eventType);\r\n        } else if (event.nativeEvent.which === 3 && event.type === 'mousedown') {\r\n            this.props.setMidpoint(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param weight is a scale of difficulty of node traversal [0,1]\r\n     * @returns greyscale rgb value corresponding to the weight e.g.:\r\n     *          weight 0 produces 'rgb(255,255,255)'\r\n     *          weight 1 produces 'rgb(55,55,55)'\r\n     */\r\n    convertWeightToGreyscale(weight: number): string {\r\n        weight = 1 - weight;\r\n        const min = 55;\r\n        const max = 255;\r\n        const rbgVal = min + (max - min) * weight;\r\n        return `rgb(${rbgVal},${rbgVal},${rbgVal})`;\r\n    }\r\n\r\n    render(): any {\r\n        let { isStart, isFinish, isMidpoint, nodeType, weight } = this.props;\r\n        let className: string;\r\n        if (isStart || isFinish || isMidpoint) {\r\n            className = isStart ? 'cell-start' : isFinish ? 'cell-finish' : isMidpoint ? 'cell-midpoint' : '';\r\n        } else {\r\n            switch (nodeType) {\r\n                case NodeType.Unvisited:\r\n                    className = 'cell-unvisited';\r\n                    break;\r\n                case NodeType.VisitedOne:\r\n                    className = 'cell-visited-0';\r\n                    break;\r\n                case NodeType.VisitedTwo:\r\n                    className = 'cell-visited-1';\r\n                    break;\r\n                case NodeType.VisitedOverlap:\r\n                    className = 'cell-visited-overlap';\r\n                    break;\r\n                case NodeType.Wall:\r\n                    className = 'cell-wall';\r\n                    break;\r\n                case NodeType.ShortestPath:\r\n                    className = 'cell-shortestPath';\r\n                    break;\r\n            }\r\n        }\r\n        // TODO: Proper integration with visual perlin noise, w/o colour degradation with the regular pathfinding module\r\n        let backgroundColor = {};\r\n        if (nodeType !== NodeType.Wall && nodeType !== NodeType.ShortestPath && !isStart && !isFinish && weight > 0) {\r\n            backgroundColor = { backgroundColor: this.convertWeightToGreyscale(weight) };\r\n        }\r\n        return (\r\n            <div\r\n                ref={this.props.nodeRef}\r\n                id={`cell-${this.props.position.x}-${this.props.position.y}`}\r\n                className={`cell ${className}`}\r\n                style={{ ...backgroundColor }}\r\n                onMouseDown={(event) => this.handleMouseEvent(event)}\r\n                onMouseUp={(event) => this.handleMouseEvent(event)}\r\n                onMouseEnter={(event) => this.handleMouseEvent(event)}\r\n                onContextMenu={(event) => event.preventDefault()}\r\n            />\r\n        );\r\n    }\r\n}\r\n","import { Component } from 'react';\r\nimport * as React from 'react';\r\nimport PathfindingAlgorithm from './Algorithms/PathfindingAlgorithm';\r\nimport Dijkstra from './Algorithms/Dijkstra';\r\nimport DFS from './Algorithms/DFS';\r\nimport BFS from './Algorithms/BFS';\r\nimport MazeGenerator from './mazes/MazeGenerator';\r\nimport RecursiveDivision from './mazes/RecursiveDivision';\r\nimport RecursiveBacktracking from './mazes/RecursiveBacktracking';\r\nimport Ellers from './mazes/Ellers';\r\nimport AStar from './Algorithms/AStar';\r\n\r\ninterface Props {\r\n    performAlgorithm: (algorithm: PathfindingAlgorithm) => void;\r\n    clearPath: () => void;\r\n    generateLandscape: () => void;\r\n    generateMaze: (mazeGenerator: MazeGenerator) => void;\r\n}\r\n\r\nexport default class Navbar extends Component<Props> {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render(): any {\r\n        return (\r\n            <div className=\"navbar\">\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.generateMaze(new Ellers());\r\n                    }}\r\n                >\r\n                    Ellers\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.generateMaze(new RecursiveBacktracking());\r\n                    }}\r\n                >\r\n                    Recursive BackTrack\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.generateMaze(new RecursiveDivision());\r\n                    }}\r\n                >\r\n                    Recursive Division\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.generateLandscape();\r\n                    }}\r\n                >\r\n                    Generate Landscape\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.performAlgorithm(new AStar());\r\n                    }}\r\n                >\r\n                    AStar\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.performAlgorithm(new Dijkstra());\r\n                    }}\r\n                >\r\n                    Dijkstra\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.performAlgorithm(new DFS());\r\n                    }}\r\n                >\r\n                    DFS\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.performAlgorithm(new BFS());\r\n                    }}\r\n                >\r\n                    BFS\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.clearPath();\r\n                    }}\r\n                >\r\n                    Clear\r\n                </button>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm';\r\nimport { Node, Position } from '../IPathfinder';\r\nimport { PriorityQueue } from './DataStructures/PriorityQueue';\r\n\r\nexport default class Dijkstra extends PathfindingAlgorithm {\r\n    minHeap: PriorityQueue<Position> = new PriorityQueue<Position>();\r\n    calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.reset();\r\n        this.setMap(grid, startPos);\r\n        this.minHeap.insert(startPos, 0);\r\n        while (this.minHeap.size() !== 0) {\r\n            let closestPosition: Position = this.minHeap.pop();\r\n            this.markAsVisited(closestPosition);\r\n            if (this.equalPosition(closestPosition, finishPos)) {\r\n                this.findShortestPath(finishPos);\r\n                return;\r\n            }\r\n            let neighbors: Array<Position> = this.getNeighbors(grid, closestPosition);\r\n            let closestDistance: number = this.pathValues.get(this.hash(closestPosition)).shortestPath;\r\n            for (let neighbor of neighbors) {\r\n                let newDistance: number = closestDistance + this.getDistance(grid, closestPosition, neighbor);\r\n                let neighborPathData: PathData = this.pathValues.get(this.hash(neighbor));\r\n                this.minHeap.insert(neighbor, newDistance);\r\n                if (newDistance < neighborPathData.shortestPath) {\r\n                    let pathData: PathData = {\r\n                        shortestPath: newDistance,\r\n                        isVisited: true,\r\n                        previousNode: closestPosition,\r\n                    };\r\n                    this.pathValues.set(this.hash(neighbor), pathData);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected setMap(grid: Array<Array<Node>>, startPos: Position): void {\r\n        grid.forEach((row) => {\r\n            return row.forEach((node) => {\r\n                let nodePosition: Position = node.position;\r\n                let shortestPath: number;\r\n                if (this.equalPosition(startPos, nodePosition)) {\r\n                    shortestPath = 0;\r\n                } else {\r\n                    shortestPath = Infinity;\r\n                }\r\n                let pathData: PathData = { shortestPath: shortestPath, isVisited: false, previousNode: null };\r\n                this.pathValues.set(this.hash(nodePosition), pathData);\r\n            });\r\n        });\r\n    }\r\n\r\n    protected reset(): void {\r\n        this.clear();\r\n        this.minHeap = new PriorityQueue<Position>();\r\n    }\r\n}\r\n","import PathfindingAlgorithm from './PathfindingAlgorithm';\r\nimport Stack from './DataStructures/Stack';\r\nimport { Position, Node } from '../IPathfinder';\r\n\r\nexport default class DFS extends PathfindingAlgorithm {\r\n    stack: Stack<Position> = new Stack<Position>();\r\n    calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.reset();\r\n        this.setMap(grid);\r\n        this.stack.push(startPos);\r\n        while (!this.stack.isEmpty()) {\r\n            let curPosition: Position = this.stack.pop();\r\n            this.markAsVisited(curPosition);\r\n            if (this.equalPosition(curPosition, finishPos)) {\r\n                this.finalPath = this.visitedNodesInOrder;\r\n                return;\r\n            }\r\n            let neighbors: Array<Position> = this.getNeighbors(grid, curPosition).reverse();\r\n            for (let neighbor of neighbors) {\r\n                this.stack.push(neighbor);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected setMap(grid: Array<Array<Node>>): void {\r\n        grid.forEach((row) => {\r\n            row.forEach((node) => {\r\n                let nodePosition: Position = node.position;\r\n                this.pathValues.set(this.hash(nodePosition), { isVisited: false });\r\n            });\r\n        });\r\n    }\r\n\r\n    protected reset(): void {\r\n        this.clear();\r\n        this.stack = new Stack<Position>();\r\n    }\r\n}\r\n","export default class Stack<T> {\r\n    data: Array<T>;\r\n    top: number;\r\n    constructor() {\r\n        this.data = new Array<T>();\r\n        this.top = 0;\r\n    }\r\n    public push(element: T): void {\r\n        this.data[this.top] = element;\r\n        this.top++;\r\n    }\r\n    public pop(): T {\r\n        this.top--;\r\n        return this.data[this.top];\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.top === 0;\r\n    }\r\n}\r\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm';\r\nimport Queue from './DataStructures/Queue';\r\nimport { Node, Position } from '../IPathfinder';\r\n\r\nexport default class BFS extends PathfindingAlgorithm {\r\n    queue: Queue<Position> = new Queue<Position>();\r\n\r\n    calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.reset();\r\n        this.setMap(grid);\r\n        this.queue.push(startPos);\r\n        while (!this.queue.isEmpty()) {\r\n            let curPosition: Position = this.queue.pop();\r\n            this.markAsVisited(curPosition);\r\n            if (this.equalPosition(curPosition, finishPos)) {\r\n                this.findShortestPath(finishPos);\r\n                return;\r\n            }\r\n            let neighbors: Array<Position> = this.getNeighbors(grid, curPosition);\r\n            for (let neighbor of neighbors) {\r\n                this.queue.push(neighbor);\r\n                this.pathValues.set(this.hash(neighbor), { isVisited: true, previousNode: curPosition });\r\n            }\r\n        }\r\n    }\r\n\r\n    protected setMap(grid: Array<Array<Node>>): void {\r\n        grid.forEach((row) => {\r\n            row.forEach((node) => {\r\n                let nodePosition: Position = node.position;\r\n                let pathData: PathData = {\r\n                    isVisited: false,\r\n                    previousNode: null,\r\n                };\r\n                this.pathValues.set(this.hash(nodePosition), pathData);\r\n            });\r\n        });\r\n    }\r\n\r\n    // protected findShortestPath(finishPos: Position) {\r\n    //     for (\r\n    //         let curPosition = finishPos;\r\n    //         curPosition != null;\r\n    //         curPosition = this.pathValues.get(this.hash(curPosition)).previousNode\r\n    //     ) {\r\n    //         this.finalPath.unshift(curPosition);\r\n    //     }\r\n    // }\r\n\r\n    protected reset(): void {\r\n        this.clear();\r\n        this.queue = new Queue<Position>();\r\n    }\r\n}\r\n","export default class Queue<T> {\r\n    data: Array<T> = [];\r\n    push(element: T) {\r\n        this.data.push(element);\r\n    }\r\n    pop(): T {\r\n        return this.data.shift();\r\n    }\r\n    isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n}\r\n","import MazeGenerator from './MazeGenerator';\r\nimport { Position, GRID_W, GRID_H } from '../IPathfinder';\r\n\r\nexport default class RecursiveDivision extends MazeGenerator {\r\n    public generateWalls(): Position[] {\r\n        this.wallsCreatedInOrder = [];\r\n        const ul: Position = { x: 0, y: 0 };\r\n        const lr: Position = { x: GRID_W - 1, y: GRID_H - 1 };\r\n        this.divide(ul, lr);\r\n        return this.wallsCreatedInOrder;\r\n    }\r\n\r\n    private divide(ul: Position, lr: Position) {\r\n        let width: number = lr.x - ul.x + 1;\r\n        let height: number = lr.y - ul.y + 1;\r\n        let vertical: boolean = width > height;\r\n        let splitIdx: number;\r\n        let gap: Position;\r\n        if (vertical) {\r\n            if (width < 4) return;\r\n            splitIdx = this.randomEven(ul.x, lr.x);\r\n            console.log(splitIdx);\r\n            gap = { x: splitIdx, y: this.randomOdd(ul.y, lr.y) };\r\n            console.log(`Trying ${splitIdx}, gap (${gap.x},${gap.y}) width: ${width} height: ${height}`);\r\n        } else {\r\n            if (height < 4) return;\r\n            splitIdx = this.randomEven(ul.y, lr.y);\r\n            console.log(splitIdx);\r\n            gap = { x: this.randomOdd(ul.x, lr.x), y: splitIdx };\r\n            console.log(`Trying ${splitIdx}, gap (${gap.x},${gap.y}) width: ${width} height: ${height}`);\r\n        }\r\n\r\n        for (let i = vertical ? ul.y + 1 : ul.x + 1; i <= (vertical ? lr.y - 1 : lr.x - 1); i++) {\r\n            if (i === (vertical ? gap.y : gap.x)) continue;\r\n            let pos: Position;\r\n            if (vertical) {\r\n                pos = { x: splitIdx, y: i };\r\n            } else {\r\n                pos = { x: i, y: splitIdx };\r\n            }\r\n            this.wallsCreatedInOrder.push(pos);\r\n        }\r\n\r\n        let newLr: Position;\r\n        let newUl: Position;\r\n        if (vertical) {\r\n            newLr = { x: splitIdx, y: lr.y };\r\n            newUl = { x: splitIdx, y: ul.y };\r\n        } else {\r\n            newLr = { x: lr.x, y: splitIdx };\r\n            newUl = { x: ul.x, y: splitIdx };\r\n        }\r\n\r\n        this.divide(ul, newLr);\r\n        this.divide(newUl, lr);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param min\r\n     * @param max\r\n     *\r\n     * produce a random even number in a range to match a valid wall coordinate that is not next to a current wall\r\n     */\r\n    private randomEven(min: number, max: number): number {\r\n        min += 2;\r\n        max -= 2;\r\n        if (min % 2 === 1) {\r\n            min++;\r\n        }\r\n        if (max % 2 === 1) {\r\n            max--;\r\n        }\r\n        let wall = min + 2 * this.getRandom(0, (max - min) / 2);\r\n        return wall;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param min\r\n     * @param max\r\n     *\r\n     * produce a random odd number in a range to match a valid gap coordinate\r\n     */\r\n    private randomOdd(min: number, max: number): number {\r\n        min += 2;\r\n        max -= 2;\r\n        if (min % 2 === 0) {\r\n            min++;\r\n        }\r\n        if (max % 2 === 0) {\r\n            max--;\r\n        }\r\n        let gap = min + 2 * this.getRandom(0, (max - min) / 2);\r\n        return gap;\r\n    }\r\n\r\n    private hash(position: Position): string {\r\n        return position.x.toString() + '-' + position.y.toString();\r\n    }\r\n}\r\n","import { Position, GRID_W, GRID_H } from '../IPathfinder';\r\nimport WallCarver from './wallCarver';\r\n\r\nexport default class RecursiveBacktracking extends WallCarver {\r\n    visited: Map<String, boolean>;\r\n    public generateWalls(): Position[] {\r\n        this.wallsCreatedInOrder = [];\r\n        this.visited = new Map<string, boolean>();\r\n        let randomStartingPos: Position = {\r\n            x: 2 * this.getRandom(1, (GRID_W - 1) / 2) - 1,\r\n            y: 2 * this.getRandom(1, (GRID_H - 1) / 2) - 1,\r\n        };\r\n        this.carveWalls(randomStartingPos);\r\n        return this.wallsCreatedInOrder;\r\n    }\r\n\r\n    carveWalls(current: Position): void {\r\n        this.visit(current);\r\n        let neighbors: Position[] = this.getUnvisitedNeighbors(current);\r\n        for (let neighbor of neighbors) {\r\n            console.log(neighbor);\r\n            if (!this.isVisisted(neighbor)) {\r\n                this.placeWallBetweenPositions(current, neighbor);\r\n                this.carveWalls(neighbor);\r\n            }\r\n        }\r\n    }\r\n\r\n    private getUnvisitedNeighbors(current: Position): Position[] {\r\n        let right: Position = { x: current.x + 2, y: current.y };\r\n        let up: Position = { x: current.x, y: current.y - 2 };\r\n        let left: Position = { x: current.x - 2, y: current.y };\r\n        let bot: Position = { x: current.x, y: current.y + 2 };\r\n        let neighbors: Position[] = [right, up, left, bot];\r\n        neighbors = neighbors.filter((pos: Position) => {\r\n            return this.positionInBounds(pos);\r\n        });\r\n        return this.randomisePositions(neighbors);\r\n    }\r\n\r\n    private randomisePositions(positions: Position[]): Position[] {\r\n        return positions.sort(() => Math.random() - 0.5);\r\n    }\r\n\r\n    private visit(position: Position): void {\r\n        this.visited.set(this.hash(position), true);\r\n    }\r\n\r\n    private isVisisted(position: Position): boolean {\r\n        return this.visited.has(this.hash(position));\r\n    }\r\n\r\n    private hash(position: Position): string {\r\n        return position.x.toString() + '-' + position.y.toString();\r\n    }\r\n}\r\n","import MazeGenerator from './MazeGenerator';\r\nimport { Position, GRID_W, GRID_H } from '../IPathfinder';\r\nimport WallCarver, { ADJUSTED_WIDTH, ADJUSTED_HEIGHT } from './wallCarver';\r\n\r\nexport default class Ellers extends WallCarver {\r\n    public generateWalls(): Position[] {\r\n        this.wallsCreatedInOrder = [];\r\n        this.generateMaze();\r\n        return this.wallsCreatedInOrder;\r\n    }\r\n\r\n    private generateMaze(): void {\r\n        let currentRow: Uptree = new Uptree();\r\n        currentRow = this.mergeRow(currentRow, 0, true);\r\n        for (let y = 1; y < ADJUSTED_HEIGHT; y++) {\r\n            let prevRow = currentRow;\r\n            currentRow = this.extendToNextRow(currentRow, prevRow, y);\r\n            currentRow = this.mergeRow(currentRow, y, y !== ADJUSTED_HEIGHT - 1);\r\n        }\r\n    }\r\n    extendToNextRow(currentRow: Uptree, prevRow: Uptree, rowIdx: number) {\r\n        currentRow = new Uptree();\r\n        for (let x = 0; x < ADJUSTED_WIDTH; x++) {\r\n            if (prevRow.isRoot(x)) {\r\n                currentRow.addEntry(x, -1);\r\n                this.addTopWall({ x: x, y: rowIdx });\r\n            } else if (this.randomBool()) {\r\n                currentRow.addEntry(x, prevRow.getEntry(x));\r\n                this.addTopWall({ x: x, y: rowIdx });\r\n            }\r\n        }\r\n        return currentRow;\r\n    }\r\n\r\n    private mergeRow(row: Uptree, rowIdx: number, random: boolean) {\r\n        for (let i = 0; i < ADJUSTED_WIDTH - 1; i++) {\r\n            if ((this.randomBool() || !random) && !row.sameClass(i, i + 1)) {\r\n                row.mergeSets(i, i + 1);\r\n                this.addRightWall({ x: i, y: rowIdx });\r\n            }\r\n        }\r\n        return row;\r\n    }\r\n    addRightWall(pos: Position): void {\r\n        this.addWall({ x: 2 * pos.x + 2, y: 2 * pos.y + 1 });\r\n    }\r\n\r\n    addTopWall(pos: Position): void {\r\n        this.addWall({ x: 2 * pos.x + 1, y: 2 * pos.y });\r\n    }\r\n\r\n    private randomBool(): boolean {\r\n        return Math.random() >= 0.5;\r\n    }\r\n}\r\n\r\nclass Uptree {\r\n    data: number[];\r\n    constructor() {\r\n        this.data = Array(ADJUSTED_WIDTH).fill(-1);\r\n    }\r\n\r\n    public mergeSets(set1: number, set2: number): void {\r\n        if (this.data[set1] === -1) {\r\n            this.data[set1] = this.getRoot(set2);\r\n        } else {\r\n            this.data[set2] = this.getRoot(set1);\r\n        }\r\n    }\r\n\r\n    public sameClass(index1: number, index2: number) {\r\n        return this.getRoot(index1) === this.getRoot(index2);\r\n    }\r\n\r\n    public getRoot(index: number): number {\r\n        while (this.data[index] !== -1) {\r\n            index = this.data[index];\r\n        }\r\n        return index;\r\n    }\r\n\r\n    public isRoot(index: number): boolean {\r\n        return this.data[index] === -1;\r\n    }\r\n\r\n    public addEntry(index: number, value: number) {\r\n        this.data[index] = value;\r\n    }\r\n\r\n    public getEntry(index: number): number {\r\n        return this.getRoot(index);\r\n    }\r\n}\r\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm';\r\nimport { Node, Position } from '../IPathfinder';\r\nimport { PriorityQueue } from './DataStructures/PriorityQueue';\r\n\r\nexport default class AStar extends PathfindingAlgorithm {\r\n    minHeap: PriorityQueue<Position> = new PriorityQueue<Position>();\r\n\r\n    public calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void {\r\n        this.reset();\r\n        this.setMap(grid, startPos);\r\n        this.minHeap.insert(startPos, 0);\r\n        while (this.minHeap.size() > 0) {\r\n            let closestPosition: Position = this.minHeap.pop();\r\n            if (this.pathValues.get(this.hash(closestPosition)).isVisited) {\r\n                continue;\r\n            }\r\n            this.markAsVisited(closestPosition);\r\n            if (this.equalPosition(closestPosition, finishPos)) {\r\n                this.findShortestPath(finishPos);\r\n                return;\r\n            }\r\n            this.setNeighbors(grid, closestPosition, startPos, finishPos);\r\n        }\r\n    }\r\n\r\n    private setNeighbors(grid: Node[][], current: Position, start: Position, finish: Position): void {\r\n        let neighbors = this.getNeighbors(grid, current);\r\n        let costSoFar: number = this.pathValues.get(this.hash(current)).shortestPath;\r\n        for (let neighbor of neighbors) {\r\n            let pathData: PathData = this.pathValues.get(this.hash(neighbor));\r\n            let distanceFromStart: number = costSoFar + this.getDistance(grid, neighbor, current);\r\n            let distanceFromFinish: number = this.getDistance(grid, neighbor, finish);\r\n            let totalCost: number = distanceFromStart + distanceFromFinish;\r\n            let prevPathData: PathData = this.pathValues.get(this.hash(neighbor));\r\n            if (prevPathData.previousNode !== null) {\r\n                let prevCost: number = prevPathData.shortestPath + distanceFromFinish;\r\n                if (totalCost < prevCost) {\r\n                    this.minHeap.insert(neighbor, totalCost, true);\r\n                    this.pathValues.set(this.hash(neighbor), {\r\n                        isVisited: false,\r\n                        previousNode: current,\r\n                        shortestPath: distanceFromStart,\r\n                    });\r\n                }\r\n            } else {\r\n                this.minHeap.insert(neighbor, totalCost, false);\r\n                this.pathValues.set(this.hash(neighbor), {\r\n                    isVisited: false,\r\n                    previousNode: current,\r\n                    shortestPath: distanceFromStart,\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    protected setMap(grid: Node[][], startPos: Position): void {\r\n        grid.forEach((row: Node[]) => {\r\n            return row.forEach((node: Node) => {\r\n                let nodePosition: Position = node.position;\r\n                let shortestPath: number;\r\n                if (this.equalPosition(startPos, nodePosition)) {\r\n                    shortestPath = 0;\r\n                } else {\r\n                    shortestPath = Infinity;\r\n                }\r\n                let pathData: PathData = { isVisited: false, shortestPath: shortestPath, previousNode: null };\r\n                this.pathValues.set(this.hash(nodePosition), pathData);\r\n            });\r\n        });\r\n    }\r\n    protected reset(): void {\r\n        this.clear();\r\n        this.minHeap = new PriorityQueue<Position>();\r\n    }\r\n}\r\n","// Credit to https://github.com/Bartvds/lorez/blob/master/src/extra/PerlinNoise.ts\r\n\r\nexport default class PerlinNoise {\r\n\r\n\tprivate p: number[];\r\n\tprivate permutation: number[];\r\n\r\n\tconstructor() {\r\n\t\t// To remove the need for index wrapping, double the permutation table length\r\n\t\tthis.permutation = [ 151, 160, 137, 91, 90, 15,\r\n\t\t\t131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\r\n\t\t\t190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\r\n\t\t\t88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\r\n\t\t\t77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\r\n\t\t\t102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\r\n\t\t\t135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\r\n\t\t\t5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\r\n\t\t\t223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\r\n\t\t\t129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\r\n\t\t\t251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\r\n\t\t\t49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\r\n\t\t\t138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\r\n\t\t];\r\n\t\tthis.p = new Array(512);\r\n\r\n\t\tfor (var i = 0; i < 256; i++) {\r\n\t\t\tthis.p[256 + i] = this.p[i] = this.permutation[i];\r\n\t\t}\r\n\t}\r\n\r\n\tnoise(x: number, y: number, z: number): number {\r\n\t\tvar X = Math.floor(x) & 255;     // FIND UNIT CUBE THAT\r\n\t\tvar Y = Math.floor(y) & 255;     // CONTAINS POINT.\r\n\t\tvar Z = Math.floor(z) & 255;\r\n\r\n\t\tx -= Math.floor(x);              // FIND RELATIVE X,Y,Z\r\n\t\ty -= Math.floor(y);              // OF POINT IN CUBE.\r\n\t\tz -= Math.floor(z);\r\n\r\n\t\tvar u = this.fade(x);            // COMPUTE FADE CURVES\r\n\t\tvar v = this.fade(y);            // FOR EACH OF X,Y,Z.\r\n\t\tvar w = this.fade(z);\r\n\r\n\t\tvar A = this.p[X] + Y;\r\n\t\tvar AA = this.p[A] + Z;\r\n\t\tvar AB = this.p[A + 1] + Z;      // HASH COORDINATES OF\r\n\r\n\t\tvar B = this.p[X + 1] + Y;\r\n\t\tvar BA = this.p[B] + Z;\r\n\t\tvar BB = this.p[B + 1] + Z;      // THE 8 CUBE CORNERS,\r\n\r\n\t\treturn this.scale(this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA  ], x, y, z),  // AND ADD\r\n\t\t\t\t\tthis.grad(this.p[BA], x - 1, y, z)), // BLENDED\r\n\t\t\t\tthis.lerp(u, this.grad(this.p[AB], x, y - 1, z),  // RESULTS\r\n\t\t\t\t\tthis.grad(this.p[BB], x - 1, y - 1, z))),// FROM  8\r\n\t\t\tthis.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),  // CORNERS\r\n\t\t\t\t\tthis.grad(this.p[BA + 1], x - 1, y, z - 1)), // OF CUBE\r\n\t\t\t\tthis.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),\r\n\t\t\t\t\tthis.grad(this.p[BB + 1], x - 1, y - 1, z - 1)))));\r\n\t}\r\n\r\n\tfade(t: number): number {\r\n\t\treturn t * t * t * (t * (t * 6 - 15) + 10);\r\n\t}\r\n\r\n\tlerp(t: number, a: number, b: number): number {\r\n\t\treturn a + t * (b - a);\r\n\t}\r\n\r\n\tgrad(hash: number, x: number, y: number, z: number): number {\r\n\t\tvar h = hash & 15;      // CONVERT LO 4 BITS OF HASH CODE\r\n\t\tvar u = h < 8 ? x : y;  // INTO 12 GRADIENT DIRECTIONS.\r\n\t\tvar v = h < 4 ? y : h == 12 || h == 14 ? x : z;\r\n\t\treturn ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\r\n\t}\r\n\r\n\tscale(n: number): number {\r\n\t\treturn (1 + n) / 2;\r\n\t}\r\n}"],"sourceRoot":""}