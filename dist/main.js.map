{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"React\"","webpack:///./src/Pathfinder.tsx","webpack:///./src/Algorithms/PathfindingAlgorithm.tsx","webpack:///./src/index.tsx","webpack:///external \"ReactDOM\"","webpack:///./src/components/App.tsx","webpack:///./src/Cell.tsx","webpack:///./src/Navbar.tsx","webpack:///./src/Algorithms/Dijkstra.tsx","webpack:///./src/Algorithms/DataStructures/PriorityQueue.tsx","webpack:///./src/Algorithms/DFS.ts","webpack:///./src/Algorithms/DataStructures/Stack.tsx","webpack:///./src/Algorithms/BFS.tsx","webpack:///./src/Algorithms/DataStructures/Queue.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","React","GRID_W","GRID_H","DEFAULT_START_POS","x","Math","floor","y","DEFAULT_FINISH_POS","MouseState","NodeType","Pathfinder","Component","props","super","this","state","grid","startPos","finishPos","mouseState","isMouseDown","updateLock","prevAlgorithm","row","curRow","col","newNode","position","nodeType","Unvisited","push","setState","PlacingWall","references","Array","fill","map","createRef","nextProps","nextState","nextContext","node","Wall","eventType","Disabled","onMouseDown","onMouseUp","onMouseEnter","MovingStart","isFinish","MovingFinish","isStart","RemovingWall","clearPath","recalculatePath","visitedInOrder","produceVisitedInOrder","finalPath","produceFinalPath","Visited","ShortestPath","algorithm","calculatePath","shortestPath","visualiseAlgorithm","lockRender","visualiseVisited","visualisePath","unlockRender","Promise","resolve","length","setTimeout","ref","className","current","includes","performAlgorithm","rowIdx","cell","colIdx","updateMouseState","nodeRef","pathValues","Map","visitedNodesInOrder","slice","neighbors","filter","neighbor","isVisited","cornerCheck","hash","pathData","newPathData","set","pos1","pos2","toString","ReactDOM","render","document","getElementById","App","Cell","event","type","id","handleMouseEvent","Navbar","onClick","Dijkstra","minHeap","PriorityQueue","setMap","insert","size","closestPosition","pop","markAsVisited","equalPosition","findShortestPath","getNeighbors","closestDistance","newDistance","getDistance","neighborPathData","previousNode","clear","sqrt","pow","abs","forEach","nodePosition","Infinity","curPosition","unshift","heap","val","priority","tmp","found","find","foundNode","tuple","shift","undefined","_","values","DFS","stack","isEmpty","reverse","data","top","element","BFS","queue"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,G,gBClFrDhC,EAAOD,QAAUkC,O,+bCAjB,aACA,OACA,OACA,OAGa,EAAAC,OAAS,GACT,EAAAC,OAAS,GACtB,MAAMC,EAA8B,CAAEC,EAAGC,KAAKC,MAAM,EAAAL,OAAS,GAAIM,EAAGF,KAAKC,MAAM,EAAAJ,OAAS,IAClFM,EAA+B,CAAEJ,EAAG,EAAAH,OAASE,EAAkBC,EAAGG,EAAGJ,EAAkBI,GAO7F,IAAYE,EAOAC,GAPZ,SAAYD,GACR,iCACA,mCACA,iCACA,mCACA,2BALJ,CAAYA,EAAA,EAAAA,aAAA,EAAAA,WAAU,KAOtB,SAAYC,GACR,6BACA,yBACA,mBACA,mCAJJ,CAAYA,EAAA,EAAAA,WAAA,EAAAA,SAAQ,KAmBpB,MAAqBC,UAAmB,EAAAC,UAEpC,YAAYC,GACRC,MAAMD,GACNE,KAAKC,MAAQ,CACTC,KAAM,GACNC,SAAU,KACVC,UAAW,KACXC,WAAY,KACZC,aAAa,EACbC,YAAY,EACZC,cAAe,MAIvB,oBACI,IAAIN,EAA2B,GAC/B,IAAK,IAAIO,EAAM,EAAGA,EAAM,EAAAtB,OAAQsB,IAAO,CACnC,IAAIC,EAAsB,GAC1B,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAAzB,OAAQyB,IAAO,CACnC,IAAIC,EAAgB,CAAEC,SAAU,CAAExB,EAAGsB,EAAKnB,EAAGiB,GAAOK,SAAUnB,EAASoB,WACvEL,EAAOM,KAAKJ,GAEhBV,EAAKc,KAAKN,GAEdV,KAAKiB,SAAS,CACVf,KAAMA,EACNC,SAAUf,EACVgB,UAAWX,EACXY,WAAYX,EAAWwB,YACvBZ,aAAa,IAEjBN,KAAKmB,WAAaC,MAAM,EAAAjC,QACnBkC,KAAK,IACLC,IAAI,IACDF,MAAM,EAAAlC,QACDmC,KAAK,GACLC,IAAI,IAAM,EAAAC,cAI3B,sBACIC,EACAC,EAQAC,GAEA,OAAQD,EAAUlB,WAGtB,YACI,IAAIL,EAA2BF,KAAKC,MAAMC,KAS1C,OARAA,EAAOA,EAAKoB,IAAKb,GACNA,EAAIa,IAAKK,IACL,CACHd,SAAUc,EAAKd,SACfC,SAAUa,EAAKb,WAAanB,EAASiC,KAAOjC,EAASiC,KAAOjC,EAASoB,cAI1Eb,EAGX,iBAAiBW,EAAoBgB,GACjC,GAAI7B,KAAKC,MAAMI,aAAeX,EAAWoC,SACzC,OAAQD,GACJ,IAAK,YACD7B,KAAK+B,YAAYlB,GACjB,MAEJ,IAAK,UACDb,KAAKgC,YACL,MAEJ,IAAK,aACDhC,KAAKiC,aAAapB,IAMtB,YAAYA,GAChB,IAAI,KAAEX,EAAI,WAAEG,EAAU,YAAEC,EAAW,cAAEE,GAAkBR,KAAKC,MACxDa,EAAqBZ,EAAKW,EAASrB,GAAGqB,EAASxB,GAAGyB,SAEjDT,IAAeX,EAAWwC,aAAelC,KAAKmC,SAAStB,IACvDR,IAAeX,EAAW0C,cAAgBpC,KAAKqC,QAAQxB,KAI5DR,EAAaL,KAAKqC,QAAQxB,GACpBnB,EAAWwC,YACXlC,KAAKmC,SAAStB,GACdnB,EAAW0C,aACXtB,IAAanB,EAASoB,UACtBrB,EAAWwB,YACXxB,EAAW4C,aAEZtC,KAAKqC,QAAQxB,IAAcb,KAAKmC,SAAStB,KACpB,OAAlBL,IACAN,EAAOF,KAAKuC,YACZ/B,EAAgB,MAEhBM,IAAanB,EAASiC,KACtB1B,EAAKW,EAASrB,GAAGqB,EAASxB,GAAGyB,SAAWnB,EAASoB,UAEjDb,EAAKW,EAASrB,GAAGqB,EAASxB,GAAGyB,SAAWnB,EAASiC,MAGzDtB,GAAc,EACdN,KAAKiB,SAAS,CAAEf,KAAMA,EAAMG,WAAYA,EAAYC,YAAaA,EAAaE,cAAeA,KAGzF,YACJ,IAAIH,EAAaX,EAAWwB,YAE5BlB,KAAKiB,SAAS,CAAEZ,WAAYA,EAAYC,aADtB,IAId,aAAaO,GACjB,IAAI,KAAEX,EAAI,SAAEC,EAAQ,UAAEC,EAAS,WAAEC,EAAU,YAAEC,EAAW,cAAEE,GAAkBR,KAAKC,MACjF,GAAKK,IAAeN,KAAKqC,QAAQxB,KAAab,KAAKmC,SAAStB,GAE5D,OAAQR,GACJ,KAAKX,EAAWwC,YACZ/B,EAAWU,EACW,OAAlBL,EACAR,KAAKwC,gBAAgBrC,EAAUC,EAAWI,GAE1CR,KAAKiB,SAAS,CAAEd,SAAUA,IAE9B,MACJ,KAAKT,EAAW0C,aACZhC,EAAYS,EACU,OAAlBL,EACAR,KAAKwC,gBAAgBrC,EAAUC,EAAWI,GAE1CR,KAAKiB,SAAS,CAAEb,UAAWA,IAE/B,MACJ,KAAKV,EAAWwB,YACZhB,EAAKW,EAASrB,GAAGqB,EAASxB,GAAGyB,SAAWnB,EAASiC,KACjD5B,KAAKiB,SAAS,CAAEf,KAAMA,IACtB,MACJ,KAAKR,EAAW4C,aACZpC,EAAKW,EAASrB,GAAGqB,EAASxB,GAAGyB,SAAWnB,EAASoB,UACjDf,KAAKiB,SAAS,CAAEf,KAAMA,KAK1B,gBAAgBC,EAAoBC,EAAqBI,GAC7D,IAAIN,EAA2BF,KAAKuC,YACpC/B,EAAcgC,gBAAgBtC,EAAMC,EAAUC,GAC9C,IAAIqC,EAAiBjC,EAAckC,wBAC/BC,EAAYnC,EAAcoC,mBAC9B,IAAK,IAAI/B,KAAY4B,EACjBvC,EAAKW,EAASrB,GAAGqB,EAASxB,GAAGyB,SAAWnB,EAASkD,QAErD,IAAK,IAAIhC,KAAY8B,EACjBzC,EAAKW,EAASrB,GAAGqB,EAASxB,GAAGyB,SAAWnB,EAASmD,aAErD9C,KAAKiB,SAAS,CAAEf,KAAMA,EAAMC,SAAUA,EAAUC,UAAWA,IAGvD,QAAQS,GACZ,OAAOA,EAASxB,IAAMW,KAAKC,MAAME,SAASd,GAAKwB,EAASrB,IAAMQ,KAAKC,MAAME,SAASX,EAG9E,SAASqB,GACb,OAAOA,EAASxB,IAAMW,KAAKC,MAAMG,UAAUf,GAAKwB,EAASrB,IAAMQ,KAAKC,MAAMG,UAAUZ,EAGhF,iBAAiBuD,GACrB/C,KAAKiB,SAAS,CAAET,cAAeuC,EAAW1C,WAAYX,EAAWoC,WACjEiB,EAAUC,cAAchD,KAAKC,MAAMC,KAAMF,KAAKC,MAAME,SAAUH,KAAKC,MAAMG,WACzE,IAAIqC,EAAkCM,EAAUL,wBAC5CO,EAAgCF,EAAUH,mBAC9C5C,KAAKkD,mBAAmBT,EAAgBQ,GAGpC,mBAAmBR,EAAiCQ,GACxD,MAAa,EAAD,gCACRjD,KAAKmD,mBACCnD,KAAKoD,iBAAiBX,SACtBzC,KAAKqD,cAAcJ,GACzBjD,KAAKsD,eACLtD,KAAKiB,SAAS,CAAEZ,WAAYX,EAAWwB,kBAL3C,GASI,iBAAiBuB,GACrB,OAAO,IAAIc,QAAeC,IACtB,IAAK,IAAIvG,EAAI,EAAGA,GAAKwF,EAAegB,OAAQxG,IACxCyG,WAAW,KACP,GAAIzG,IAAMwF,EAAegB,OACrBD,QACG,CACH,IAAI3C,EAAqB4B,EAAexF,GACpC0G,EAAiC3D,KAAKmB,WAAWN,EAASrB,GAAGqB,EAASxB,GACtEuE,EAAoBD,EAAIE,QAAQD,UACpC,IAAKA,EAAUE,SAAS,gBAAkBF,EAAUE,SAAS,eAAgB,CACzEH,EAAIE,QAAQD,UAAY,oBACxB,IAAI1D,EAA2BF,KAAKC,MAAMC,KAC1CA,EAAKW,EAASrB,GAAGqB,EAASxB,GAAGyB,SAAWnB,EAASkD,QACjD7C,KAAKiB,SAAS,CAAEf,KAAMA,OAnP9B,EAsPajD,KAKrB,cAAcgG,GAClB,OAAO,IAAIM,QAAeC,IACtB,IAAK,IAAIvG,EAAI,EAAGA,GAAKgG,EAAaQ,OAAQxG,IACtCyG,WAAW,KACP,GAAIzG,IAAMgG,EAAaQ,OACnBD,QACG,CACH,IAAI3C,EAAqBoC,EAAahG,GAClC0G,EAAiC3D,KAAKmB,WAAWN,EAASrB,GAAGqB,EAASxB,GACtEuE,EAAoBD,EAAIE,QAAQD,UACpC,IAAKA,EAAUE,SAAS,gBAAkBF,EAAUE,SAAS,eAAgB,CACzEH,EAAIE,QAAQD,UAAY,yBACxB,IAAI1D,EAA2BF,KAAKC,MAAMC,KAC1CA,EAAKW,EAASrB,GAAGqB,EAASxB,GAAGyB,SAAWnB,EAASmD,aACjD9C,KAAKiB,SAAS,CAAEf,KAAMA,OAzQ9B,EA4QajD,KAKrB,aACJ+C,KAAKiB,SAAS,CAAEV,YAAY,IAGxB,eACJP,KAAKiB,SAAS,CAAEV,YAAY,IAGzB,SACH,IAAIL,EAAOF,KAAKC,MAAMC,KACtB,OACI,2BACI,gBAAC,UAAM,CACH6D,iBAAmBhB,GAAoC/C,KAAK+D,iBAAiBhB,GAC7ER,UAAW,IAAMvC,KAAKiB,SAAS,CAAET,cAAe,KAAMN,KAAMF,KAAKuC,gBAErE,uBAAKqB,UAAU,QACV1D,EAAKoB,IAAI,CAACb,EAAkBuD,IAErB,uBAAKJ,UAAU,WAAWpF,IAAKwF,GAC1BvD,EAAIa,IAAI,CAAC2C,EAAYC,IAEd,gBAAC,UAAI,CACDrD,SAAU,CAAExB,EAAG6E,EAAQ1E,EAAGwE,GAC1B3B,QACIrC,KAAKC,MAAME,SAASd,IAAM6E,GAAUlE,KAAKC,MAAME,SAASX,IAAMwE,EAElE7B,SACInC,KAAKC,MAAMG,UAAUf,IAAM6E,GAAUlE,KAAKC,MAAMG,UAAUZ,IAAMwE,EAEpElD,SAAUmD,EAAKnD,SACfqD,iBAAkB,CAACtD,EAAoBgB,IACnC7B,KAAKmE,iBAAiBtD,EAAUgB,GAEpCuC,QAASpE,KAAKmB,WAAW6C,GAAQE,GACjC1F,IAAK0F,UApRjD,a,8EC1CA,aAQA,8BACI,KAAAG,WAAoC,IAAIC,IACxC,KAAA3B,UAA6B,GAC7B,KAAA4B,oBAAuC,GAQhC,wBACH,OAAOvE,KAAKuE,oBAAoBC,MAAM,EAAGxE,KAAKuE,oBAAoBd,OAAS,GAGxE,mBACH,OAAOzD,KAAK2C,UAAU6B,MAAM,EAAGxE,KAAKuE,oBAAoBd,OAAS,GAG3D,aAAavD,EAA0BW,GAC7C,IAAI4D,EAA6B,GAWjC,OAVAA,EAAUzD,KAAK,CAAE3B,EAAGwB,EAASxB,EAAI,EAAGG,EAAGqB,EAASrB,IAChDiF,EAAUzD,KAAK,CAAE3B,EAAGwB,EAASxB,EAAGG,EAAGqB,EAASrB,EAAI,IAChDiF,EAAUzD,KAAK,CAAE3B,EAAGwB,EAASxB,EAAGG,EAAGqB,EAASrB,EAAI,IAChDiF,EAAUzD,KAAK,CAAE3B,EAAGwB,EAASxB,EAAI,EAAGG,EAAGqB,EAASrB,IAEhDiF,EAAUzD,KAAK,CAAE3B,EAAGwB,EAASxB,EAAI,EAAGG,EAAGqB,EAASrB,EAAI,IACpDiF,EAAUzD,KAAK,CAAE3B,EAAGwB,EAASxB,EAAI,EAAGG,EAAGqB,EAASrB,EAAI,IACpDiF,EAAUzD,KAAK,CAAE3B,EAAGwB,EAASxB,EAAI,EAAGG,EAAGqB,EAASrB,EAAI,IACpDiF,EAAUzD,KAAK,CAAE3B,EAAGwB,EAASxB,EAAI,EAAGG,EAAGqB,EAASrB,EAAI,IAE7CiF,EAAUC,OAAQC,GAEjBA,EAAStF,GAAK,GACdsF,EAAStF,EAAI,EAAAH,QACbyF,EAASnF,GAAK,GACdmF,EAASnF,EAAI,EAAAL,QACbe,EAAKyE,EAASnF,GAAGmF,EAAStF,GAAGyB,WAAa,EAAAnB,SAASiC,OAClD5B,KAAK4E,UAAUD,IAChB3E,KAAK6E,YAAYhE,EAAU8D,EAAUzE,IAKzC,YAAYW,EAAoB8D,EAAoBzE,GACxD,OACIA,EAAKW,EAASrB,GAAGmF,EAAStF,GAAGyB,WAAa,EAAAnB,SAASiC,MACnD1B,EAAKyE,EAASnF,GAAGqB,EAASxB,GAAGyB,WAAa,EAAAnB,SAASiC,KAIjD,UAAUf,GAChB,OAAOb,KAAKqE,WAAWvG,IAAIkC,KAAK8E,KAAKjE,IAAW+D,UAG1C,cAAc/D,GACpBb,KAAKuE,oBAAoBvD,KAAKH,GAC9B,IAAIkE,EAAqB/E,KAAKqE,WAAWvG,IAAIkC,KAAK8E,KAAKjE,IACnDmE,EAAW,+BACRD,GAAQ,CACXH,WAAW,IAEf5E,KAAKqE,WAAWY,IAAIjF,KAAK8E,KAAKjE,GAAWmE,GAGnC,cAAcE,EAAgBC,GACpC,OAAOD,EAAK7F,IAAM8F,EAAK9F,GAAK6F,EAAK1F,IAAM2F,EAAK3F,EAGtC,KAAKqB,GACX,OAAOA,EAASxB,EAAE+F,WAAa,IAAMvE,EAASrB,EAAE4F,WAG1C,QACNpF,KAAKuE,oBAAsB,GAC3BvE,KAAK2C,UAAY,GACjB3C,KAAKqE,WAAa,IAAIC,O,8ECpF9B,aACA,OACA,OAEAe,EAASC,OAAO,gBAAC,UAAG,MAAKC,SAASC,eAAe,U,cCJjDxI,EAAOD,QAAUsI,U,8ECAjB,aACA,OACA,OAEA,MAAqBI,UAAY,EAAA5F,UAC7B,YAAYC,GACRC,MAAMD,GACNE,KAAKC,MAAQ,GAGjB,SACI,OACI,uBAAK2D,UAAU,OACX,gBAAC,UAAU,QAT3B,a,8ECJA,aACA,OACA,OAYA,MAAqB8B,UAAa,EAAA7F,UAC9B,YAAYC,GACRC,MAAMD,GACNE,KAAKC,MAAQ,GAGjB,iBAAiB0F,GACb,IAAI9D,EAAoB8D,EAAMC,KAC1B/E,EAAqBb,KAAKF,MAAMe,SACpCb,KAAKF,MAAMqE,iBAAiBtD,EAAUgB,GAG1C,SACI,IACI+B,GADA,QAAEvB,EAAO,SAAEF,EAAQ,SAAErB,GAAad,KAAKF,MAE3C,GAAIuC,GAAWF,EACXyB,EAAYvB,EAAU,aAAeF,EAAW,cAAgB,QAEhE,OAAQrB,GACJ,KAAK,EAAAnB,SAASoB,UACV6C,EAAY,iBACZ,MACJ,KAAK,EAAAjE,SAASkD,QACVe,EAAY,eACZ,MACJ,KAAK,EAAAjE,SAASiC,KACVgC,EAAY,YACZ,MACJ,KAAK,EAAAjE,SAASmD,aACVc,EAAY,oBAIxB,OACI,uBACID,IAAK3D,KAAKF,MAAMsE,QAChByB,GAAI,QAAQ7F,KAAKF,MAAMe,SAASxB,KAAKW,KAAKF,MAAMe,SAASrB,IACzDoE,UAAW,QAAQA,EACnB7B,YAAc4D,GAAU3F,KAAK8F,iBAAiBH,GAC9C3D,UAAY2D,GAAU3F,KAAK8F,iBAAiBH,GAC5C1D,aAAe0D,GAAU3F,KAAK8F,iBAAiBH,MAxC/D,a,8ECdA,aACA,OAEA,OACA,QACA,QAOA,MAAqBI,UAAe,EAAAlG,UAChC,YAAYC,GACRC,MAAMD,GACNE,KAAKC,MAAQ,GAGjB,SACI,OACI,uBAAK2D,UAAU,UACX,0BACIoC,QAAS,KACLhG,KAAKF,MAAMiE,iBAAiB,IAAI,aACnC,YAIL,0BACIiC,QAAS,KACLhG,KAAKF,MAAMiE,iBAAiB,IAAI,aACnC,OAIL,0BACIiC,QAAS,KACLhG,KAAKF,MAAMiE,iBAAiB,IAAI,aACnC,OAIL,0BACIiC,QAAS,KACLhG,KAAKF,MAAMyC,cACd,WAjCrB,a,8ECZA,aAEA,OAEA,MAAqB0D,UAAiB,UAAtC,c,oBACI,KAAAC,QAAmC,IAAI,EAAAC,cACvC,cAAcjG,EAA0BC,EAAoBC,GAGxD,IAFAJ,KAAKoG,OAAOlG,EAAMC,GAClBH,KAAKkG,QAAQG,OAAOlG,EAAU,GACC,IAAxBH,KAAKkG,QAAQI,QAAc,CAC9B,IAAIC,EAA4BvG,KAAKkG,QAAQM,MAE7C,GADAxG,KAAKyG,cAAcF,GACfvG,KAAK0G,cAAcH,EAAiBnG,GAEpC,YADAJ,KAAK2G,iBAAiBvG,GAG1B,IAAIqE,EAA6BzE,KAAK4G,aAAa1G,EAAMqG,GACrDM,EAA0B7G,KAAKqE,WAAWvG,IAAIkC,KAAK8E,KAAKyB,IAAkBtD,aAC9E,IAAK,IAAI0B,KAAYF,EAAW,CAC5B,IAAIqC,EAAsBD,EAAkB7G,KAAK+G,YAAYR,EAAiB5B,GAC1EqC,EAA6BhH,KAAKqE,WAAWvG,IAAIkC,KAAK8E,KAAKH,IAE/D,GADA3E,KAAKkG,QAAQG,OAAO1B,EAAUmC,GAC1BA,EAAcE,EAAiB/D,aAAc,CAC7C,IAAI8B,EAAqB,CACrB9B,aAAc6D,EACdlC,WAAW,EACXqC,aAAcV,GAElBvG,KAAKqE,WAAWY,IAAIjF,KAAK8E,KAAKH,GAAWI,MAMlD,gBAAgB7E,EAAgBC,EAAoBC,GACvDJ,KAAKkH,QACLlH,KAAKkG,QAAU,IAAI,EAAAC,cACnBnG,KAAKgD,cAAc9C,EAAMC,EAAUC,GAG/B,YAAY8E,EAAgBC,GAChC,OAAO7F,KAAK6H,KAAK7H,KAAK8H,IAAI9H,KAAK+H,IAAInC,EAAK7F,EAAI8F,EAAK9F,GAAI,GAAKC,KAAK8H,IAAI9H,KAAK+H,IAAInC,EAAK1F,EAAI2F,EAAK3F,GAAI,IAGxF,OAAOU,EAA0BC,GACvCD,EAAKoH,QAAS7G,GACHA,EAAI6G,QAAS3F,IAChB,IACIsB,EADAsE,EAAyB5F,EAAKd,SAG9BoC,EADAjD,KAAK0G,cAAcvG,EAAUoH,GACd,EAEAC,IAEnB,IAAIzC,EAAqB,CAAE9B,aAAcA,EAAc2B,WAAW,EAAOqC,aAAc,MACvFjH,KAAKqE,WAAWY,IAAIjF,KAAK8E,KAAKyC,GAAexC,MAKzD,iBAAiB3E,GACb,IACI,IAAIqH,EAAcrH,EACH,MAAfqH,EACAA,EAAczH,KAAKqE,WAAWvG,IAAIkC,KAAK8E,KAAK2C,IAAcR,aAE1DjH,KAAK2C,UAAU+E,QAAQD,IA9DnC,a,qGCGA,sBAGI,cAFA,KAAAE,KAAmB,GAInB,OAAOC,EAAQC,GACX,IAAK7H,KAAK2H,KAAKlE,QAAUzD,KAAK2H,KAAK3H,KAAK2H,KAAKlE,OAAS,GAAG,GAAKoE,EAE1D,OADA7H,KAAK2H,KAAK3G,KAAK,CAAC4G,EAAKC,IACd7H,KAAK2H,KAGhB,MAAMG,EAAkB,GACxB,IAAIC,GAAQ,EAEZ,IAAK,IAAI9K,EAAI,EAAGA,EAAI+C,KAAK2H,KAAKlE,OAAQxG,IAAK,CAGnC4K,GAFM7H,KAAK2H,KAAK1K,GAAG,KAED8K,IAClBD,EAAI9G,KAAK,CAAC4G,EAAKC,IACfE,GAAQ,GAGZD,EAAI9G,KAAKhB,KAAK2H,KAAK1K,IAGvB,OAAQ+C,KAAK2H,KAAOG,EAGxB,KAAI,EAAEzI,EAAC,EAAEG,IAGL,QAFkBQ,KAAK2H,KAAKK,KAAK,EAAEJ,KAASA,EAAIvI,IAAMA,GAAKuI,EAAIpI,IAAMA,GAKzE,KAAI,EAAEH,EAAC,EAAEG,IACL,MAAMyI,EAAYjI,KAAK2H,KAAKK,KAAK,EAAEJ,KAASA,EAAIvI,IAAMA,GAAKuI,EAAIpI,IAAMA,GAErE,OAAOyI,GAAaA,EAAU,GAGlC,MAAMJ,GACF,MAAMK,EAAQlI,KAAK2H,KAAKQ,QACxB,OAAIN,EACOK,EAGJA,EAAQA,EAAM,QAAKE,EAG9B,MACI,OAAOpI,KAAK2H,KAAKnB,MAAM,GAG3B,aACI,OAAOxG,KAAK2H,KAAKrG,IAAI,EAAE+G,EAAGtJ,KAAOA,GAGrC,SACI,OAAOiB,KAAK2H,KAAKrG,IAAI,EAAEsG,KAASA,GAGpC,OACI,OAAO5H,KAAK2H,KAAKlE,OAGrB,QAAQ6E,GACJ,OAAIA,EACOtI,KAAK2H,KAAKrG,IAAI,EAAEsG,KAASA,GAE7B5H,KAAK2H,Q,8EC5EpB,aACA,QAGA,MAAqBY,UAAY,UAAjC,c,oBACI,KAAAC,MAAyB,IAAI,UAC7B,cAActI,EAA0BC,EAAoBC,GAGxD,IAFAJ,KAAKoG,OAAOlG,GACZF,KAAKwI,MAAMxH,KAAKb,IACRH,KAAKwI,MAAMC,WAAW,CAC1B,IAAIhB,EAAwBzH,KAAKwI,MAAMhC,MAEvC,GADAxG,KAAKyG,cAAcgB,GACfzH,KAAK0G,cAAce,EAAarH,GAEhC,YADAJ,KAAK2C,UAAY3C,KAAKuE,qBAG1B,IAAIE,EAA6BzE,KAAK4G,aAAa1G,EAAMuH,GAAaiB,UACtE,IAAK,IAAI/D,KAAYF,EACjBzE,KAAKwI,MAAMxH,KAAK2D,IAKlB,OAAOzE,GACbA,EAAKoH,QAAS7G,IACVA,EAAI6G,QAAS3F,IACT,IAAI4F,EAAyB5F,EAAKd,SAClCb,KAAKqE,WAAWY,IAAIjF,KAAK8E,KAAKyC,GAAe,CAAE3C,WAAW,QAKtE,gBAAgB1E,EAA0BC,EAAoBC,GAC1DJ,KAAKkH,QACLlH,KAAKwI,MAAQ,IAAI,UACjBxI,KAAKgD,cAAc9C,EAAMC,EAAUC,IA/B3C,a,8ECJA,8BACI,KAAAuI,KAAiB,GACjB,KAAAC,IAAc,EACP,KAAKC,GACR7I,KAAK2I,KAAK3I,KAAK4I,KAAOC,EACtB7I,KAAK4I,MAEF,MAEH,OADA5I,KAAK4I,MACE5I,KAAK2I,KAAK3I,KAAK4I,KAKnB,UACH,OAAoB,IAAb5I,KAAK4I,O,8ECfpB,aACA,QAGA,MAAqBE,UAAY,UAAjC,c,oBACI,KAAAC,MAAyB,IAAI,UAE7B,cAAc7I,EAA0BC,EAAoBC,GAGxD,IAFAJ,KAAKoG,OAAOlG,GACZF,KAAK+I,MAAM/H,KAAKb,IACRH,KAAK+I,MAAMN,WAAW,CAC1B,IAAIhB,EAAwBzH,KAAK+I,MAAMvC,MAEvC,GADAxG,KAAKyG,cAAcgB,GACfzH,KAAK0G,cAAce,EAAarH,GAEhC,YADAJ,KAAK2G,iBAAiBvG,GAG1B,IAAIqE,EAA6BzE,KAAK4G,aAAa1G,EAAMuH,GACzD,IAAK,IAAI9C,KAAYF,EACjBzE,KAAK+I,MAAM/H,KAAK2D,GAChB3E,KAAKqE,WAAWY,IAAIjF,KAAK8E,KAAKH,GAAW,CAAEC,WAAW,EAAMqC,aAAcQ,KAK5E,OAAOvH,GACbA,EAAKoH,QAAS7G,IACVA,EAAI6G,QAAS3F,IACT,IAAI4F,EAAyB5F,EAAKd,SAKlCb,KAAKqE,WAAWY,IAAIjF,KAAK8E,KAAKyC,GAJL,CACrB3C,WAAW,EACXqC,aAAc,WAOtB,iBAAiB7G,GACrB,IACI,IAAIqH,EAAcrH,EACH,MAAfqH,EACAA,EAAczH,KAAKqE,WAAWvG,IAAIkC,KAAK8E,KAAK2C,IAAcR,aAE1DjH,KAAK2C,UAAU+E,QAAQD,GAI/B,gBAAgBvH,EAA0BC,EAAoBC,GAC1DJ,KAAKkH,QACLlH,KAAK+I,MAAQ,IAAI,UACjB/I,KAAKgD,cAAc9C,EAAMC,EAAUC,IA/C3C,a,8ECJA,8BACI,KAAAuI,KAAiB,GACjB,KAAKE,GACD7I,KAAK2I,KAAK3H,KAAK6H,GAEnB,MACI,OAAO7I,KAAK2I,KAAKR,QAErB,UACI,OAA4B,IAArBnI,KAAK2I,KAAKlF","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = React;","import * as React from 'react';\r\nimport { Component, createRef, RefObject } from 'react';\r\nimport Cell from './Cell';\r\nimport Navbar from './Navbar';\r\nimport PathfindingAlgorithm from './Algorithms/PathfindingAlgorithm';\r\n\r\nexport const GRID_W = 50;\r\nexport const GRID_H = 27;\r\nconst DEFAULT_START_POS: Position = { x: Math.floor(GRID_W / 4), y: Math.floor(GRID_H / 2) };\r\nconst DEFAULT_FINISH_POS: Position = { x: GRID_W - DEFAULT_START_POS.x, y: DEFAULT_START_POS.y };\r\nconst UPDATE_RATE = 5;\r\n\r\nexport interface Position {\r\n    x: number;\r\n    y: number;\r\n}\r\nexport enum MouseState {\r\n    PlacingWall,\r\n    RemovingWall,\r\n    MovingStart,\r\n    MovingFinish,\r\n    Disabled,\r\n}\r\nexport enum NodeType {\r\n    Unvisited,\r\n    Visited,\r\n    Wall,\r\n    ShortestPath,\r\n}\r\nexport interface Node {\r\n    position: Position;\r\n    nodeType: NodeType;\r\n}\r\ninterface State {\r\n    grid: Array<Array<Node>>;\r\n    startPos: Position;\r\n    finishPos: Position;\r\n    mouseState: MouseState;\r\n    isMouseDown: boolean;\r\n    updateLock: boolean;\r\n    prevAlgorithm: PathfindingAlgorithm;\r\n}\r\nexport default class Pathfinder extends Component<{}, State> {\r\n    references: Array<Array<RefObject<HTMLDivElement> | any>>;\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            startPos: null,\r\n            finishPos: null,\r\n            mouseState: null,\r\n            isMouseDown: false,\r\n            updateLock: false,\r\n            prevAlgorithm: null,\r\n        };\r\n    }\r\n\r\n    componentDidMount(): void {\r\n        let grid: Array<Array<Node>> = [];\r\n        for (let row = 0; row < GRID_H; row++) {\r\n            let curRow: Array<Node> = [];\r\n            for (let col = 0; col < GRID_W; col++) {\r\n                let newNode: Node = { position: { x: col, y: row }, nodeType: NodeType.Unvisited };\r\n                curRow.push(newNode);\r\n            }\r\n            grid.push(curRow);\r\n        }\r\n        this.setState({\r\n            grid: grid,\r\n            startPos: DEFAULT_START_POS,\r\n            finishPos: DEFAULT_FINISH_POS,\r\n            mouseState: MouseState.PlacingWall,\r\n            isMouseDown: false,\r\n        });\r\n        this.references = Array(GRID_H)\r\n            .fill([])\r\n            .map(() =>\r\n                Array(GRID_W)\r\n                    .fill(0)\r\n                    .map(() => createRef()),\r\n            );\r\n    }\r\n\r\n    shouldComponentUpdate(\r\n        nextProps: Readonly<{}>,\r\n        nextState: Readonly<{\r\n            grid: Array<Array<Node>>;\r\n            startPos: Position;\r\n            finishPos: Position;\r\n            mouseState: MouseState;\r\n            isMouseDown: boolean;\r\n            updateLock: boolean;\r\n        }>,\r\n        nextContext: any,\r\n    ): boolean {\r\n        return !nextState.updateLock;\r\n    }\r\n\r\n    clearPath(): Array<Array<Node>> {\r\n        let grid: Array<Array<Node>> = this.state.grid;\r\n        grid = grid.map((row) => {\r\n            return row.map((node) => {\r\n                return {\r\n                    position: node.position,\r\n                    nodeType: node.nodeType === NodeType.Wall ? NodeType.Wall : NodeType.Unvisited,\r\n                };\r\n            });\r\n        });\r\n        return grid;\r\n    }\r\n\r\n    updateMouseState(position: Position, eventType: string): void {\r\n        if (this.state.mouseState === MouseState.Disabled) return;\r\n        switch (eventType) {\r\n            case 'mousedown': {\r\n                this.onMouseDown(position);\r\n                break;\r\n            }\r\n            case 'mouseup': {\r\n                this.onMouseUp();\r\n                break;\r\n            }\r\n            case 'mouseenter': {\r\n                this.onMouseEnter(position);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private onMouseDown(position: Position) {\r\n        let { grid, mouseState, isMouseDown, prevAlgorithm } = this.state;\r\n        let nodeType: NodeType = grid[position.y][position.x].nodeType;\r\n        if (\r\n            (mouseState === MouseState.MovingStart && this.isFinish(position)) ||\r\n            (mouseState === MouseState.MovingFinish && this.isStart(position))\r\n        )\r\n            return;\r\n\r\n        mouseState = this.isStart(position)\r\n            ? MouseState.MovingStart\r\n            : this.isFinish(position)\r\n            ? MouseState.MovingFinish\r\n            : nodeType === NodeType.Unvisited\r\n            ? MouseState.PlacingWall\r\n            : MouseState.RemovingWall;\r\n\r\n        if (!this.isStart(position) && !this.isFinish(position)) {\r\n            if (prevAlgorithm !== null) {\r\n                grid = this.clearPath();\r\n                prevAlgorithm = null;\r\n            }\r\n            if (nodeType === NodeType.Wall) {\r\n                grid[position.y][position.x].nodeType = NodeType.Unvisited;\r\n            } else {\r\n                grid[position.y][position.x].nodeType = NodeType.Wall;\r\n            }\r\n        }\r\n        isMouseDown = true;\r\n        this.setState({ grid: grid, mouseState: mouseState, isMouseDown: isMouseDown, prevAlgorithm: prevAlgorithm });\r\n    }\r\n\r\n    private onMouseUp() {\r\n        let mouseState = MouseState.PlacingWall;\r\n        let isMouseDown = false;\r\n        this.setState({ mouseState: mouseState, isMouseDown: isMouseDown });\r\n    }\r\n\r\n    private onMouseEnter(position: Position) {\r\n        let { grid, startPos, finishPos, mouseState, isMouseDown, prevAlgorithm } = this.state;\r\n        if (!isMouseDown || this.isStart(position) || this.isFinish(position)) return;\r\n\r\n        switch (mouseState) {\r\n            case MouseState.MovingStart:\r\n                startPos = position;\r\n                if (prevAlgorithm !== null) {\r\n                    this.recalculatePath(startPos, finishPos, prevAlgorithm);\r\n                } else {\r\n                    this.setState({ startPos: startPos });\r\n                }\r\n                break;\r\n            case MouseState.MovingFinish:\r\n                finishPos = position;\r\n                if (prevAlgorithm !== null) {\r\n                    this.recalculatePath(startPos, finishPos, prevAlgorithm);\r\n                } else {\r\n                    this.setState({ finishPos: finishPos });\r\n                }\r\n                break;\r\n            case MouseState.PlacingWall:\r\n                grid[position.y][position.x].nodeType = NodeType.Wall;\r\n                this.setState({ grid: grid });\r\n                break;\r\n            case MouseState.RemovingWall:\r\n                grid[position.y][position.x].nodeType = NodeType.Unvisited;\r\n                this.setState({ grid: grid });\r\n                break;\r\n        }\r\n    }\r\n\r\n    private recalculatePath(startPos: Position, finishPos: Position, prevAlgorithm: PathfindingAlgorithm) {\r\n        let grid: Array<Array<Node>> = this.clearPath();\r\n        prevAlgorithm.recalculatePath(grid, startPos, finishPos);\r\n        let visitedInOrder = prevAlgorithm.produceVisitedInOrder();\r\n        let finalPath = prevAlgorithm.produceFinalPath();\r\n        for (let position of visitedInOrder) {\r\n            grid[position.y][position.x].nodeType = NodeType.Visited;\r\n        }\r\n        for (let position of finalPath) {\r\n            grid[position.y][position.x].nodeType = NodeType.ShortestPath;\r\n        }\r\n        this.setState({ grid: grid, startPos: startPos, finishPos: finishPos });\r\n    }\r\n\r\n    private isStart(position: Position) {\r\n        return position.x === this.state.startPos.x && position.y === this.state.startPos.y;\r\n    }\r\n\r\n    private isFinish(position: Position) {\r\n        return position.x === this.state.finishPos.x && position.y === this.state.finishPos.y;\r\n    }\r\n\r\n    private performAlgorithm(algorithm: PathfindingAlgorithm): void {\r\n        this.setState({ prevAlgorithm: algorithm, mouseState: MouseState.Disabled });\r\n        algorithm.calculatePath(this.state.grid, this.state.startPos, this.state.finishPos);\r\n        let visitedInOrder: Array<Position> = algorithm.produceVisitedInOrder();\r\n        let shortestPath: Array<Position> = algorithm.produceFinalPath();\r\n        this.visualiseAlgorithm(visitedInOrder, shortestPath);\r\n    }\r\n\r\n    private visualiseAlgorithm(visitedInOrder: Array<Position>, shortestPath: Array<Position>): void {\r\n        (async () => {\r\n            this.lockRender();\r\n            await this.visualiseVisited(visitedInOrder);\r\n            await this.visualisePath(shortestPath);\r\n            this.unlockRender();\r\n            this.setState({ mouseState: MouseState.PlacingWall });\r\n        })();\r\n    }\r\n\r\n    private visualiseVisited(visitedInOrder: Array<Position>): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            for (let i = 0; i <= visitedInOrder.length; i++) {\r\n                setTimeout(() => {\r\n                    if (i === visitedInOrder.length) {\r\n                        resolve();\r\n                    } else {\r\n                        let position: Position = visitedInOrder[i];\r\n                        let ref: RefObject<HTMLDivElement> = this.references[position.y][position.x];\r\n                        let className: string = ref.current.className;\r\n                        if (!className.includes('cell-start') && !className.includes('cell-finish')) {\r\n                            ref.current.className = 'cell cell-visited';\r\n                            let grid: Array<Array<Node>> = this.state.grid;\r\n                            grid[position.y][position.x].nodeType = NodeType.Visited;\r\n                            this.setState({ grid: grid });\r\n                        }\r\n                    }\r\n                }, UPDATE_RATE * i);\r\n            }\r\n        });\r\n    }\r\n\r\n    private visualisePath(shortestPath: Array<Position>): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            for (let i = 0; i <= shortestPath.length; i++) {\r\n                setTimeout(() => {\r\n                    if (i === shortestPath.length) {\r\n                        resolve();\r\n                    } else {\r\n                        let position: Position = shortestPath[i];\r\n                        let ref: RefObject<HTMLDivElement> = this.references[position.y][position.x];\r\n                        let className: string = ref.current.className;\r\n                        if (!className.includes('cell-start') && !className.includes('cell-finish')) {\r\n                            ref.current.className = 'cell cell-shortestPath';\r\n                            let grid: Array<Array<Node>> = this.state.grid;\r\n                            grid[position.y][position.x].nodeType = NodeType.ShortestPath;\r\n                            this.setState({ grid: grid });\r\n                        }\r\n                    }\r\n                }, UPDATE_RATE * i);\r\n            }\r\n        });\r\n    }\r\n\r\n    private lockRender() {\r\n        this.setState({ updateLock: true });\r\n    }\r\n\r\n    private unlockRender() {\r\n        this.setState({ updateLock: false });\r\n    }\r\n\r\n    public render(): any {\r\n        let grid = this.state.grid;\r\n        return (\r\n            <div>\r\n                <Navbar\r\n                    performAlgorithm={(algorithm: PathfindingAlgorithm) => this.performAlgorithm(algorithm)}\r\n                    clearPath={() => this.setState({ prevAlgorithm: null, grid: this.clearPath() })}\r\n                />\r\n                <div className=\"grid\">\r\n                    {grid.map((row: Array<Node>, rowIdx) => {\r\n                        return (\r\n                            <div className=\"grid-row\" key={rowIdx}>\r\n                                {row.map((cell: Node, colIdx) => {\r\n                                    return (\r\n                                        <Cell\r\n                                            position={{ x: colIdx, y: rowIdx }}\r\n                                            isStart={\r\n                                                this.state.startPos.x === colIdx && this.state.startPos.y === rowIdx\r\n                                            }\r\n                                            isFinish={\r\n                                                this.state.finishPos.x === colIdx && this.state.finishPos.y === rowIdx\r\n                                            }\r\n                                            nodeType={cell.nodeType}\r\n                                            updateMouseState={(position: Position, eventType: string) =>\r\n                                                this.updateMouseState(position, eventType)\r\n                                            }\r\n                                            nodeRef={this.references[rowIdx][colIdx]}\r\n                                            key={colIdx}\r\n                                        />\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import { GRID_H, GRID_W, Node, NodeType, Position } from '../Pathfinder';\r\n\r\nexport interface PathData {\r\n    isVisited: boolean;\r\n    shortestPath?: number;\r\n    previousNode?: Position;\r\n}\r\n\r\nexport default abstract class PathfindingAlgorithm {\r\n    pathValues: Map<string, PathData> = new Map<string, PathData>();\r\n    finalPath: Array<Position> = [];\r\n    visitedNodesInOrder: Array<Position> = [];\r\n\r\n    protected abstract setMap(grid: Array<Array<Node>>, startPos?: Position): void;\r\n\r\n    public abstract calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void;\r\n\r\n    public abstract recalculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void;\r\n\r\n    public produceVisitedInOrder(): Array<Position> {\r\n        return this.visitedNodesInOrder.slice(1, this.visitedNodesInOrder.length - 1);\r\n    }\r\n\r\n    public produceFinalPath(): Array<Position> {\r\n        return this.finalPath.slice(1, this.visitedNodesInOrder.length - 1);\r\n    }\r\n\r\n    protected getNeighbors(grid: Array<Array<Node>>, position: Position): Array<Position> {\r\n        let neighbors: Array<Position> = [];\r\n        neighbors.push({ x: position.x + 1, y: position.y });\r\n        neighbors.push({ x: position.x, y: position.y + 1 });\r\n        neighbors.push({ x: position.x, y: position.y - 1 });\r\n        neighbors.push({ x: position.x - 1, y: position.y });\r\n\r\n        neighbors.push({ x: position.x - 1, y: position.y + 1 });\r\n        neighbors.push({ x: position.x + 1, y: position.y + 1 });\r\n        neighbors.push({ x: position.x + 1, y: position.y - 1 });\r\n        neighbors.push({ x: position.x - 1, y: position.y - 1 });\r\n\r\n        return neighbors.filter((neighbor) => {\r\n            return (\r\n                neighbor.x >= 0 &&\r\n                neighbor.x < GRID_W &&\r\n                neighbor.y >= 0 &&\r\n                neighbor.y < GRID_H &&\r\n                grid[neighbor.y][neighbor.x].nodeType !== NodeType.Wall &&\r\n                !this.isVisited(neighbor) &&\r\n                this.cornerCheck(position, neighbor, grid)\r\n            );\r\n        });\r\n    }\r\n\r\n    private cornerCheck(position: Position, neighbor: Position, grid: Array<Array<Node>>): boolean {\r\n        return (\r\n            grid[position.y][neighbor.x].nodeType !== NodeType.Wall ||\r\n            grid[neighbor.y][position.x].nodeType !== NodeType.Wall\r\n        );\r\n    }\r\n\r\n    protected isVisited(position: Position): boolean {\r\n        return this.pathValues.get(this.hash(position)).isVisited;\r\n    }\r\n\r\n    protected markAsVisited(position: Position): void {\r\n        this.visitedNodesInOrder.push(position);\r\n        let pathData: PathData = this.pathValues.get(this.hash(position));\r\n        let newPathData: PathData = {\r\n            ...pathData,\r\n            isVisited: true,\r\n        };\r\n        this.pathValues.set(this.hash(position), newPathData);\r\n    }\r\n\r\n    protected equalPosition(pos1: Position, pos2: Position) {\r\n        return pos1.x === pos2.x && pos1.y === pos2.y;\r\n    }\r\n\r\n    protected hash(position: Position): string {\r\n        return position.x.toString() + '-' + position.y.toString();\r\n    }\r\n\r\n    protected clear(): void {\r\n        this.visitedNodesInOrder = [];\r\n        this.finalPath = [];\r\n        this.pathValues = new Map<string, PathData>();\r\n    }\r\n}\r\n","import * as React from 'react';\r\nimport * as ReactDOM from 'react-dom';\r\nimport App from './components/App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n","module.exports = ReactDOM;","import * as React from 'react';\r\nimport Pathfinder from '../Pathfinder';\r\nimport { Component } from 'react';\r\n\r\nexport default class App extends Component {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render(): any {\r\n        return (\r\n            <div className=\"app\">\r\n                <Pathfinder />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import * as React from 'react';\r\nimport { Component, LegacyRef } from 'react';\r\nimport { NodeType, Position } from './Pathfinder';\r\nimport { RefObject } from 'react';\r\n\r\ninterface Props {\r\n    position: Position;\r\n    isStart: boolean;\r\n    isFinish: boolean;\r\n    nodeType: NodeType;\r\n    updateMouseState: (position: Position, eventType: string) => void;\r\n    nodeRef: (ref: RefObject<HTMLDivElement> | any) => void;\r\n}\r\n\r\nexport default class Cell extends Component<Props> {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    handleMouseEvent(event: React.MouseEvent<HTMLElement>): void {\r\n        let eventType: string = event.type;\r\n        let position: Position = this.props.position;\r\n        this.props.updateMouseState(position, eventType);\r\n    }\r\n\r\n    render(): any {\r\n        let { isStart, isFinish, nodeType } = this.props;\r\n        let className: string;\r\n        if (isStart || isFinish) {\r\n            className = isStart ? 'cell-start' : isFinish ? 'cell-finish' : '';\r\n        } else {\r\n            switch (nodeType) {\r\n                case NodeType.Unvisited:\r\n                    className = 'cell-unvisited';\r\n                    break;\r\n                case NodeType.Visited:\r\n                    className = 'cell-visited';\r\n                    break;\r\n                case NodeType.Wall:\r\n                    className = 'cell-wall';\r\n                    break;\r\n                case NodeType.ShortestPath:\r\n                    className = 'cell-shortestPath';\r\n                    break;\r\n            }\r\n        }\r\n        return (\r\n            <div\r\n                ref={this.props.nodeRef}\r\n                id={`cell-${this.props.position.x}-${this.props.position.y}`}\r\n                className={`cell ${className}`}\r\n                onMouseDown={(event) => this.handleMouseEvent(event)}\r\n                onMouseUp={(event) => this.handleMouseEvent(event)}\r\n                onMouseEnter={(event) => this.handleMouseEvent(event)}\r\n            />\r\n        );\r\n    }\r\n}\r\n","import { Component } from 'react';\r\nimport * as React from 'react';\r\nimport PathfindingAlgorithm from './Algorithms/PathfindingAlgorithm';\r\nimport Dijkstra from './Algorithms/Dijkstra';\r\nimport DFS from './Algorithms/DFS';\r\nimport BFS from './Algorithms/BFS';\r\n\r\ninterface Props {\r\n    performAlgorithm: (algorithm: PathfindingAlgorithm) => void;\r\n    clearPath: () => void;\r\n}\r\n\r\nexport default class Navbar extends Component<Props> {\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render(): any {\r\n        return (\r\n            <div className=\"navbar\">\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.performAlgorithm(new Dijkstra());\r\n                    }}\r\n                >\r\n                    Dijkstra\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.performAlgorithm(new DFS());\r\n                    }}\r\n                >\r\n                    DFS\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.performAlgorithm(new BFS());\r\n                    }}\r\n                >\r\n                    BFS\r\n                </button>\r\n                <button\r\n                    onClick={() => {\r\n                        this.props.clearPath();\r\n                    }}\r\n                >\r\n                    Clear\r\n                </button>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm';\r\nimport { Node, Position } from '../Pathfinder';\r\nimport { PriorityQueue } from './DataStructures/PriorityQueue';\r\n\r\nexport default class Dijkstra extends PathfindingAlgorithm {\r\n    minHeap: PriorityQueue<Position> = new PriorityQueue<Position>();\r\n    calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.setMap(grid, startPos);\r\n        this.minHeap.insert(startPos, 0);\r\n        while (this.minHeap.size() !== 0) {\r\n            let closestPosition: Position = this.minHeap.pop();\r\n            this.markAsVisited(closestPosition);\r\n            if (this.equalPosition(closestPosition, finishPos)) {\r\n                this.findShortestPath(finishPos);\r\n                return;\r\n            }\r\n            let neighbors: Array<Position> = this.getNeighbors(grid, closestPosition);\r\n            let closestDistance: number = this.pathValues.get(this.hash(closestPosition)).shortestPath;\r\n            for (let neighbor of neighbors) {\r\n                let newDistance: number = closestDistance + this.getDistance(closestPosition, neighbor);\r\n                let neighborPathData: PathData = this.pathValues.get(this.hash(neighbor));\r\n                this.minHeap.insert(neighbor, newDistance);\r\n                if (newDistance < neighborPathData.shortestPath) {\r\n                    let pathData: PathData = {\r\n                        shortestPath: newDistance,\r\n                        isVisited: true,\r\n                        previousNode: closestPosition,\r\n                    };\r\n                    this.pathValues.set(this.hash(neighbor), pathData);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public recalculatePath(grid: Node[][], startPos: Position, finishPos: Position): void {\r\n        this.clear();\r\n        this.minHeap = new PriorityQueue<Position>();\r\n        this.calculatePath(grid, startPos, finishPos);\r\n    }\r\n\r\n    private getDistance(pos1: Position, pos2: Position): number {\r\n        return Math.sqrt(Math.pow(Math.abs(pos1.x - pos2.x), 2) + Math.pow(Math.abs(pos1.y - pos2.y), 2));\r\n    }\r\n\r\n    protected setMap(grid: Array<Array<Node>>, startPos: Position): void {\r\n        grid.forEach((row) => {\r\n            return row.forEach((node) => {\r\n                let nodePosition: Position = node.position;\r\n                let shortestPath: number;\r\n                if (this.equalPosition(startPos, nodePosition)) {\r\n                    shortestPath = 0;\r\n                } else {\r\n                    shortestPath = Infinity;\r\n                }\r\n                let pathData: PathData = { shortestPath: shortestPath, isVisited: false, previousNode: null };\r\n                this.pathValues.set(this.hash(nodePosition), pathData);\r\n            });\r\n        });\r\n    }\r\n\r\n    findShortestPath(finishPos: Position): void {\r\n        for (\r\n            let curPosition = finishPos;\r\n            curPosition != null;\r\n            curPosition = this.pathValues.get(this.hash(curPosition)).previousNode\r\n        ) {\r\n            this.finalPath.unshift(curPosition);\r\n        }\r\n    }\r\n}\r\n","export interface Node {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport type Tuple<T> = [T, number];\r\n\r\nexport class PriorityQueue<T extends Node> {\r\n    heap: Tuple<T>[] = [];\r\n\r\n    constructor() {}\r\n\r\n    insert(val: T, priority: number) {\r\n        if (!this.heap.length || this.heap[this.heap.length - 1][1] > priority) {\r\n            this.heap.push([val, priority]);\r\n            return this.heap;\r\n        }\r\n\r\n        const tmp: Tuple<T>[] = [];\r\n        let found = false;\r\n\r\n        for (let i = 0; i < this.heap.length; i++) {\r\n            const p = this.heap[i][1];\r\n\r\n            if (priority >= p && !found) {\r\n                tmp.push([val, priority]);\r\n                found = true;\r\n            }\r\n\r\n            tmp.push(this.heap[i]);\r\n        }\r\n\r\n        return (this.heap = tmp);\r\n    }\r\n\r\n    has({ x, y }: T) {\r\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\r\n\r\n        return !!foundNode;\r\n    }\r\n\r\n    get({ x, y }: T) {\r\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\r\n\r\n        return foundNode && foundNode[0];\r\n    }\r\n\r\n    shift(priority: boolean) {\r\n        const tuple = this.heap.shift();\r\n        if (priority) {\r\n            return tuple;\r\n        }\r\n\r\n        return tuple ? tuple[0] : undefined;\r\n    }\r\n\r\n    pop() {\r\n        return this.heap.pop()[0];\r\n    }\r\n\r\n    priorities() {\r\n        return this.heap.map(([_, p]) => p);\r\n    }\r\n\r\n    values() {\r\n        return this.heap.map(([val]) => val);\r\n    }\r\n\r\n    size() {\r\n        return this.heap.length;\r\n    }\r\n\r\n    toArray(values: boolean) {\r\n        if (values) {\r\n            return this.heap.map(([val]) => val);\r\n        }\r\n        return this.heap;\r\n    }\r\n}\r\n","import PathfindingAlgorithm from './PathfindingAlgorithm';\r\nimport Stack from './DataStructures/Stack';\r\nimport { Position, Node } from '../Pathfinder';\r\n\r\nexport default class DFS extends PathfindingAlgorithm {\r\n    stack: Stack<Position> = new Stack<Position>();\r\n    calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.setMap(grid);\r\n        this.stack.push(startPos);\r\n        while (!this.stack.isEmpty()) {\r\n            let curPosition: Position = this.stack.pop();\r\n            this.markAsVisited(curPosition);\r\n            if (this.equalPosition(curPosition, finishPos)) {\r\n                this.finalPath = this.visitedNodesInOrder;\r\n                return;\r\n            }\r\n            let neighbors: Array<Position> = this.getNeighbors(grid, curPosition).reverse();\r\n            for (let neighbor of neighbors) {\r\n                this.stack.push(neighbor);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected setMap(grid: Array<Array<Node>>): void {\r\n        grid.forEach((row) => {\r\n            row.forEach((node) => {\r\n                let nodePosition: Position = node.position;\r\n                this.pathValues.set(this.hash(nodePosition), { isVisited: false });\r\n            });\r\n        });\r\n    }\r\n\r\n    recalculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.clear();\r\n        this.stack = new Stack<Position>();\r\n        this.calculatePath(grid, startPos, finishPos);\r\n    }\r\n}\r\n","export default class Stack<T> {\r\n    data: Array<T> = [];\r\n    top: number = 0;\r\n    public push(element: T): void {\r\n        this.data[this.top] = element;\r\n        this.top++;\r\n    }\r\n    public pop(): T {\r\n        this.top--;\r\n        return this.data[this.top];\r\n    }\r\n    // public peek(): T {\r\n    //     return this.data[this.top - 1];\r\n    // }\r\n    public isEmpty(): boolean {\r\n        return this.top === 0;\r\n    }\r\n}\r\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm';\r\nimport Queue from './DataStructures/Queue';\r\nimport { Node, Position } from '../Pathfinder';\r\n\r\nexport default class BFS extends PathfindingAlgorithm {\r\n    queue: Queue<Position> = new Queue<Position>();\r\n\r\n    calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.setMap(grid);\r\n        this.queue.push(startPos);\r\n        while (!this.queue.isEmpty()) {\r\n            let curPosition: Position = this.queue.pop();\r\n            this.markAsVisited(curPosition);\r\n            if (this.equalPosition(curPosition, finishPos)) {\r\n                this.findShortestPath(finishPos);\r\n                return;\r\n            }\r\n            let neighbors: Array<Position> = this.getNeighbors(grid, curPosition);\r\n            for (let neighbor of neighbors) {\r\n                this.queue.push(neighbor);\r\n                this.pathValues.set(this.hash(neighbor), { isVisited: true, previousNode: curPosition });\r\n            }\r\n        }\r\n    }\r\n\r\n    protected setMap(grid: Array<Array<Node>>): void {\r\n        grid.forEach((row) => {\r\n            row.forEach((node) => {\r\n                let nodePosition: Position = node.position;\r\n                let pathData: PathData = {\r\n                    isVisited: false,\r\n                    previousNode: null,\r\n                };\r\n                this.pathValues.set(this.hash(nodePosition), pathData);\r\n            });\r\n        });\r\n    }\r\n\r\n    private findShortestPath(finishPos: Position) {\r\n        for (\r\n            let curPosition = finishPos;\r\n            curPosition != null;\r\n            curPosition = this.pathValues.get(this.hash(curPosition)).previousNode\r\n        ) {\r\n            this.finalPath.unshift(curPosition);\r\n        }\r\n    }\r\n\r\n    recalculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.clear();\r\n        this.queue = new Queue<Position>();\r\n        this.calculatePath(grid, startPos, finishPos);\r\n    }\r\n}\r\n","export default class Queue<T> {\r\n    data: Array<T> = [];\r\n    push(element: T) {\r\n        this.data.push(element);\r\n    }\r\n    pop(): T {\r\n        return this.data.shift();\r\n    }\r\n    isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n}\r\n"],"sourceRoot":""}