{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"React\"","webpack:///./src/Pathfinder.tsx","webpack:///./src/index.tsx","webpack:///external \"ReactDOM\"","webpack:///./src/components/App.tsx","webpack:///./src/Cell.tsx","webpack:///./src/Navbar.tsx","webpack:///./src/Algorithms/Dijkstra.ts","webpack:///./src/Algorithms/PathfindingAlgorithm.ts","webpack:///./src/Algorithms/PriorityQueue.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","React","GRIDW","GRIDH","DEFAULTSTARTPOS","x","Math","floor","y","DEFAULTFINISHPOS","MouseState","NodeType","Pathfinder","Component","props","super","this","state","grid","startPos","finishPos","mouseState","isMouseDown","row","curRow","col","newNode","position","nodeType","Unvisited","push","setState","PlacingWall","eventType","onMouseDown","onMouseUp","onMouseEnter","MovingStart","isFinish","MovingFinish","isStart","RemovingWall","Wall","algorithm","calculatePath","visitedInOrder","produceVisitedInOrder","shortestPath","produceShortestPath","visualiseAlgorithm","visualiseVisited","visualisePath","Promise","resolve","posIdx","setInterval","length","document","getElementById","className","performAlgorithm","map","rowIdx","cell","colIdx","updateMouseState","ReactDOM","render","App","Cell","event","type","Visited","ShortestPath","id","handleMouseEvent","onClick","Dijkstra","pathValues","minHeap","PriorityQueue","node","nodePosition","Infinity","previousNode","insert","size","closestPosition","pop","closestDistance","console","log","getShortestPath","visitedNodesInOrder","neighbors","getNeighbors","neighborPosition","newDistance","neighborPathValues","curPosition","shortestPathInOrder","unshift","filter","pos","heap","val","priority","tmp","found","find","foundNode","tuple","shift","undefined","_","values"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,G,gBClFrDhC,EAAOD,QAAUkC,O,8YCAjB,aACA,OACA,OACA,OAGa,EAAAC,MAAQ,GACR,EAAAC,MAAQ,GACrB,MAAMC,EAA4B,CAACC,EAAGC,KAAKC,MAAM,EAAAL,MAAM,GAAIM,EAAGF,KAAKC,MAAM,EAAAJ,MAAM,IACzEM,EAA6B,CAACJ,EAAG,EAAAH,MAAQE,EAAgBC,EAAGG,EAAGJ,EAAgBI,GAOrF,IAAYE,EAMAC,GANZ,SAAYD,GACR,iCACA,mCACA,iCACA,mCAJJ,CAAYA,EAAA,EAAAA,aAAA,EAAAA,WAAU,KAMtB,SAAYC,GACR,6BACA,yBACA,mBACA,mCAJJ,CAAYA,EAAA,EAAAA,WAAA,EAAAA,SAAQ,KAUpB,MAAqBC,UAAmB,EAAAC,UAEpC,YAAYC,GACRC,MAAMD,GACNE,KAAKC,MAAQ,CACTC,KAAM,GACNC,SAAU,KACVC,UAAW,KACXC,WAAY,KACZC,aAAa,GAIrB,oBACI,IAAIJ,EAA2B,GAC/B,IAAK,IAAIK,EAAM,EAAGA,EAAM,EAAApB,MAAOoB,IAAO,CAClC,IAAIC,EAAsB,GAC1B,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAAvB,MAAOuB,IAAO,CAClC,IAAIC,EAAgB,CAACC,SAAU,CAACtB,EAAGoB,EAAKjB,EAAGe,GAAMK,SAAUjB,EAASkB,WACpEL,EAAOM,KAAKJ,GAEhBR,EAAKY,KAAKN,GAOdR,KAAKe,SAAS,CAACb,KAAMA,EAAMC,SAAUf,EAAiBgB,UAAWX,EAAkBY,WAAYX,EAAWsB,YAAaV,aAAa,IAGxI,iBAAiBK,EAAoBM,GACjC,OAAQA,GACJ,IAAK,YACDjB,KAAKkB,YAAYP,GACjB,MAEJ,IAAK,UACDX,KAAKmB,YACL,MAEJ,IAAK,aACDnB,KAAKoB,aAAaT,IAMtB,YAAYA,GAChB,IAAI,KAACT,EAAI,WAAEG,EAAU,YAAEC,GAAeN,KAAKC,MACvCW,EAAqBV,EAAKS,EAASnB,GAAGmB,EAAStB,GAAGuB,SACjDP,IAAeX,EAAW2B,aAAerB,KAAKsB,SAASX,IAAeN,IAAeX,EAAW6B,cAAgBvB,KAAKwB,QAAQb,KAElIN,EAAaL,KAAKwB,QAAQb,GAAYjB,EAAW2B,YAAcrB,KAAKsB,SAASX,GAAYjB,EAAW6B,aAAeX,IAAajB,EAASkB,UAAYnB,EAAWsB,YAActB,EAAW+B,aAEpLzB,KAAKwB,QAAQb,IAAcX,KAAKsB,SAASX,KACtCC,IAAajB,EAAS+B,KACtBxB,EAAKS,EAASnB,GAAGmB,EAAStB,GAAGuB,SAAWjB,EAASkB,UAEjDX,EAAKS,EAASnB,GAAGmB,EAAStB,GAAGuB,SAAWjB,EAAS+B,MAGzDpB,GAAc,EACdN,KAAKe,SAAS,CAACb,KAAMA,EAAMG,WAAYA,EAAYC,YAAaA,KAG5D,YACJ,IAAID,EAAaX,EAAWsB,YAE5BhB,KAAKe,SAAS,CAACV,WAAYA,EAAYC,aADrB,IAId,aAAaK,GACjB,IAAI,KAACT,EAAI,SAAEC,EAAQ,UAAEC,EAAS,WAAEC,EAAU,YAAEC,GAAeN,KAAKC,MAChE,GAAKK,IAAeN,KAAKwB,QAAQb,KAAaX,KAAKsB,SAASX,GAE5D,OAAQN,GACJ,KAAKX,EAAW2B,YACZlB,EAAWQ,EACXX,KAAKe,SAAS,CAACZ,SAAUA,IACzB,MACJ,KAAKT,EAAW6B,aACZnB,EAAYO,EACZX,KAAKe,SAAS,CAACX,UAAWA,IAC1B,MACJ,KAAKV,EAAWsB,YACZd,EAAKS,EAASnB,GAAGmB,EAAStB,GAAGuB,SAAWjB,EAAS+B,KACjD1B,KAAKe,SAAS,CAACb,KAAMA,IACrB,MACJ,KAAKR,EAAW+B,aACZvB,EAAKS,EAASnB,GAAGmB,EAAStB,GAAGuB,SAAWjB,EAASkB,UACjDb,KAAKe,SAAS,CAACb,KAAMA,KAKzB,QAAQS,GACZ,OAAOA,EAAStB,IAAMW,KAAKC,MAAME,SAASd,GAAKsB,EAASnB,IAAMQ,KAAKC,MAAME,SAASX,EAG9E,SAASmB,GACb,OAAOA,EAAStB,IAAMW,KAAKC,MAAMG,UAAUf,GAAKsB,EAASnB,IAAMQ,KAAKC,MAAMG,UAAUZ,EAGhF,iBAAiBmC,GACrBA,EAAUC,cAAc5B,KAAKC,MAAMC,KAAMF,KAAKC,MAAME,SAAUH,KAAKC,MAAMG,WACzE,IAAIyB,EAAkCF,EAAUG,wBAC5CC,EAAgCJ,EAAUK,sBAC9ChC,KAAKiC,mBAAmBJ,EAAgBE,GAGpC,mBAAmBF,EAAiCE,GACxD,MAAa,EAAD,sCACF/B,KAAKkC,iBAAiBL,SACtB7B,KAAKmC,cAAcJ,OAF7B,GAMI,iBAAiBF,GACrB,OAAO,IAAIO,QAAQC,IACf,IAAIC,EAAiB,EACrBC,YAAY,KACR,GAAID,IAAWT,EAAeW,OAC1BH,QACG,CACH,IAAI1B,EAAqBkB,EAAeS,GACxCG,SAASC,eAAe,QAAQ/B,EAAStB,KAAKsB,EAASnB,KAAKmD,UAAY,oBACxEL,MArJD,GAuJSA,KAIhB,cAAcP,GAClB,OAAO,IAAIK,QAAQC,IACf,IAAIC,EAAiB,EACrBC,YAAY,KACR,GAAID,IAAWP,EAAaS,OACxBH,QACG,CACH,IAAI1B,EAAqBoB,EAAaO,GACtCG,SAASC,eAAe,QAAQ/B,EAAStB,KAAKsB,EAASnB,KAAKmD,UAAY,yBACxEL,MApKD,GAsKSA,KAIjB,SACH,IAAIpC,EAAOF,KAAKC,MAAMC,KACtB,OACI,2BACA,gBAAC,UAAM,CAAC0C,iBAAqBjB,GAAoC3B,KAAK4C,iBAAiBjB,KACvF,uBAAKgB,UAAY,QACZzC,EAAK2C,IAAI,CAACtC,EAAkBuC,IACjB,uBAAKH,UAAU,WAAWnE,IAAOsE,GACpCvC,EAAIsC,IAAI,CAACE,EAAYC,IACV,gBAAC,UAAI,CACTrC,SAAY,CAACtB,EAAG2D,EAAQxD,EAAGsD,GAC3BtB,QAASxB,KAAKC,MAAME,SAASd,IAAM2D,GAAUhD,KAAKC,MAAME,SAASX,IAAMsD,EACvExB,SAAUtB,KAAKC,MAAMG,UAAUf,IAAM2D,GAAUhD,KAAKC,MAAMG,UAAUZ,IAAMsD,EAC1ElC,SAAYmC,EAAKnC,SACjBqC,iBAAoB,CAACtC,EAAoBM,IAAsBjB,KAAKiD,iBAAiBtC,EAAUM,GAE/FzC,IAAOwE,UApKvC,a,8EChCA,aACA,OACA,OAGAE,EAASC,OACL,gBAAC,UAAG,MACJV,SAASC,eAAe,U,cCP5B1F,EAAOD,QAAUmG,U,8ECAjB,aACA,OACA,OAGA,MAAqBE,UAAY,EAAAvD,UAC7B,YAAYC,GACRC,MAAMD,GACNE,KAAKC,MAAQ,GAGjB,SACI,OAAQ,uBAAK0C,UAAU,OACnB,gBAAC,UAAU,QARvB,a,8ECLA,aACA,OACA,OAEA,MAAqBU,UAAa,EAAAxD,UAU9B,YAAYC,GACRC,MAAMD,GACNE,KAAKC,MAAQ,GAGjB,iBAAiBqD,GACb,IAAIrC,EAAqBqC,EAAMC,KAC3B5C,EAAqBX,KAAKF,MAAMa,SACpCX,KAAKF,MAAMmD,iBAAiBtC,EAAUM,GAG1C,SACI,IACI0B,GADA,QAACnB,EAAO,SAAEF,EAAQ,SAAEV,GAAYZ,KAAKF,MAEzC,GAAI0B,GAAWF,EACXqB,EAAYnB,EAAU,aAAeF,EAAW,cAAgB,QAEhE,OAAQV,GACJ,KAAK,EAAAjB,SAASkB,UAAc8B,EAAY,iBAAkB,MAC1D,KAAK,EAAAhD,SAAS6D,QAAcb,EAAY,eAAgB,MACxD,KAAK,EAAAhD,SAAS+B,KAAciB,EAAY,YAAa,MACrD,KAAK,EAAAhD,SAAS8D,aAAcd,EAAY,oBAGhD,OACI,uBAAKe,GAAI,QAAQ1D,KAAKF,MAAMa,SAAStB,KAAKW,KAAKF,MAAMa,SAASnB,IAAKmD,UAAW,QAAQA,EACjFzB,YAAqBoC,GAAUtD,KAAK2D,iBAAiBL,GACrDnC,UAAqBmC,GAAUtD,KAAK2D,iBAAiBL,GACrDlC,aAAqBkC,GAAUtD,KAAK2D,iBAAiBL,MAtCtE,a,8ECJA,aACA,OAGA,OAEA,gBAA6B,EAAAzD,UACzB,YAAYC,GACRC,MAAMD,GACNE,KAAKC,MAAQ,GAGjB,SACI,OACI,uBAAK0C,UAAU,UACX,0BAAQiB,QAAS,KAAO5D,KAAKF,MAAM8C,iBAAiB,IAAI,aAAY,cATpF,a,8ECNA,aACA,OACA,OAOA,MAAqBiB,UAAiB,UAGlC,cACI9D,QACAC,KAAK8D,WAAa,GAClB9D,KAAK+D,QAAS,IAAI,EAAAC,cAGtB,cAAc9D,EAA0BC,EAAoBC,GA8BxD,IA7BAJ,KAAK8D,WAAa5D,EAAK2C,IAAKtC,GACjBA,EAAIsC,IAAKoB,IACZ,IACIlC,EADAmC,EAAyBD,EAAKtD,SAOlC,OAJIoB,EADA5B,EAASd,IAAM6E,EAAa7E,GAAKc,EAASX,IAAM0E,EAAa1E,EAC9C,EAEA2E,IAEZ,CAACpC,aAAcA,EAAcqC,aAAc,SAG1DpE,KAAK+D,QAAQM,OAAOlE,EAAU,GAiBC,IAAxBH,KAAK+D,QAAQO,QAAc,CAC9B,IAAIC,EAA4BvE,KAAK+D,QAAQS,MACzCC,EAA0BzE,KAAK8D,WAAWS,EAAgB/E,GAAG+E,EAAgBlF,GAAG0C,aAEpF,GADA2C,QAAQC,IAAI,QAAQJ,EAAgBlF,KAAKkF,EAAgB/E,KACrDiF,IAAoBN,IAEpB,YADAO,QAAQC,IAAI,oBAGhB,GAAIJ,EAAgBlF,IAAMe,EAAUf,GAAKkF,EAAgB/E,IAAMY,EAAUZ,EAGrE,OAFAkF,QAAQC,IAAI,uBACZ3E,KAAK4E,gBAAgBzE,EAAUC,GAGX,IAApBqE,GACAzE,KAAK6E,oBAAoB/D,KAAKyD,GAElC,IAAIO,EAA6B9E,KAAK+E,aAAa7E,EAAMqE,GACzD,IAAK,IAAIS,KAAoBF,EAAW,CACpC,IAAIG,EAAsBjF,KAAK8D,WAAWS,EAAgB/E,GAAG+E,EAAgBlF,GAAG0C,aAAe,EAC3FmD,EAAiClF,KAAK8D,WAAWkB,EAAiBxF,GAAGwF,EAAiB3F,GAC1FW,KAAK+D,QAAQM,OAAOW,EAAkBC,GAClCA,EAAcC,EAAmBnD,eACjC/B,KAAK8D,WAAWkB,EAAiBxF,GAAGwF,EAAiB3F,GAAK,CAAC0C,aAAckD,EAAab,aAAcG,MAMpH,gBAAgBpE,EAAoBC,GAChC,IAAK,IAAI+E,EAAc/E,EACH,MAAf+E,EACAA,EAAcnF,KAAK8D,WAAWqB,EAAY3F,GAAG2F,EAAY9F,GAAG+E,aAE7DpE,KAAKoF,oBAAoBC,QAAQF,GAIzC,aAAajF,EAA0BS,GACnC,IAAImE,EAA6B,GAajC,OAZInE,EAAStB,EAAIa,EAAK,GAAGsC,OAAS,GAC9BsC,EAAUhE,KAAK,CAACzB,EAAGsB,EAAStB,EAAI,EAAGG,EAAGmB,EAASnB,IAE/CmB,EAASnB,EAAI,GACbsF,EAAUhE,KAAK,CAACzB,EAAGsB,EAAStB,EAAGG,EAAGmB,EAASnB,EAAI,IAE/CmB,EAAStB,EAAI,GACbyF,EAAUhE,KAAK,CAACzB,EAAGsB,EAAStB,EAAI,EAAGG,EAAGmB,EAASnB,IAE/CmB,EAASnB,EAAIU,EAAKsC,OAAS,GAC3BsC,EAAUhE,KAAK,CAACzB,EAAGsB,EAAStB,EAAGG,EAAGmB,EAASnB,EAAI,IAE5CsF,EAAUQ,OAAQC,GACdvF,KAAK8D,WAAWyB,EAAI/F,GAAG+F,EAAIlG,GAAG0C,eAAiBoC,KAAYjE,EAAKqF,EAAI/F,GAAG+F,EAAIlG,GAAGuB,WAAa,EAAAjB,SAASkB,YA3FvH,a,8ECPA,gBAII,cACIb,KAAKoF,oBAAsB,GAC3BpF,KAAK6E,oBAAsB,GAKxB,wBACH,OAAO7E,KAAK6E,oBAGT,sBACH,OAAO7E,KAAKoF,uB,8ECXpB,sBAGI,cAFA,KAAAI,KAAmB,GAInB,OAAOC,EAAQC,GACX,IAAK1F,KAAKwF,KAAKhD,QAAUxC,KAAKwF,KAAKxF,KAAKwF,KAAKhD,OAAS,GAAG,GAAKkD,EAE1D,OADA1F,KAAKwF,KAAK1E,KAAK,CAAC2E,EAAKC,IACd1F,KAAKwF,KAGhB,MAAMG,EAAkB,GACxB,IAAIC,GAAQ,EAEZ,IAAK,IAAI3I,EAAI,EAAGA,EAAI+C,KAAKwF,KAAKhD,OAAQvF,IAAK,CAGnCyI,GAFM1F,KAAKwF,KAAKvI,GAAG,KAED2I,IAClBD,EAAI7E,KAAK,CAAC2E,EAAKC,IACfE,GAAQ,GAGZD,EAAI7E,KAAKd,KAAKwF,KAAKvI,IAGvB,OAAQ+C,KAAKwF,KAAOG,EAGxB,KAAI,EAAEtG,EAAC,EAAEG,IAGL,QAFkBQ,KAAKwF,KAAKK,KAAK,EAAEJ,KAASA,EAAIpG,IAAMA,GAAKoG,EAAIjG,IAAMA,GAKzE,KAAI,EAAEH,EAAC,EAAEG,IACL,MAAMsG,EAAY9F,KAAKwF,KAAKK,KAAK,EAAEJ,KAASA,EAAIpG,IAAMA,GAAKoG,EAAIjG,IAAMA,GAErE,OAAOsG,GAAaA,EAAU,GAGlC,MAAMJ,GACF,MAAMK,EAAQ/F,KAAKwF,KAAKQ,QACxB,OAAIN,EACOK,EAGJA,EAAQA,EAAM,QAAKE,EAG9B,MACI,OAAOjG,KAAKwF,KAAKhB,MAAM,GAG3B,aACI,OAAOxE,KAAKwF,KAAK3C,IAAI,EAAEqD,EAAGnH,KAAOA,GAGrC,SACI,OAAOiB,KAAKwF,KAAK3C,IAAI,EAAE4C,KAASA,GAGpC,OACI,OAAOzF,KAAKwF,KAAKhD,OAGrB,QAAQ2D,GACJ,OAAIA,EACOnG,KAAKwF,KAAK3C,IAAI,EAAE4C,KAASA,GAE7BzF,KAAKwF","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = React;","import * as React from \"react\";\r\nimport {Component} from \"react\";\r\nimport Cell from \"./Cell\";\r\nimport Navbar from \"./Navbar\";\r\nimport PathfindingAlgorithm from \"./Algorithms/PathfindingAlgorithm\";\r\n\r\nexport const GRIDW = 50;\r\nexport const GRIDH = 27;\r\nconst DEFAULTSTARTPOS: Position = {x: Math.floor(GRIDW/4), y: Math.floor(GRIDH/2)};\r\nconst DEFAULTFINISHPOS: Position = {x: GRIDW - DEFAULTSTARTPOS.x, y: DEFAULTSTARTPOS.y};\r\nconst UPDATERATE = 15;\r\n\r\nexport interface Position {\r\n    x: number,\r\n    y: number,\r\n}\r\nexport enum MouseState {\r\n    PlacingWall,\r\n    RemovingWall,\r\n    MovingStart,\r\n    MovingFinish,\r\n}\r\nexport enum NodeType {\r\n    Unvisited,\r\n    Visited,\r\n    Wall,\r\n    ShortestPath,\r\n}\r\nexport interface Node {\r\n    position : Position,\r\n    nodeType: NodeType;\r\n}\r\nexport default class Pathfinder extends Component<{}, {grid: Array<Array<Node>>, startPos: Position, finishPos: Position, mouseState: MouseState, isMouseDown: boolean}> {\r\n    // references: Array<Array<React.RefObject<any>>>;\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            startPos: null,\r\n            finishPos: null,\r\n            mouseState: null,\r\n            isMouseDown: false,\r\n        };\r\n    }\r\n\r\n    componentDidMount(): void {\r\n        let grid: Array<Array<Node>> = [];\r\n        for (let row = 0; row < GRIDH; row++) {\r\n            let curRow: Array<Node> = [];\r\n            for (let col = 0; col < GRIDW; col++) {\r\n                let newNode: Node = {position: {x: col, y: row}, nodeType: NodeType.Unvisited};\r\n                curRow.push(newNode);\r\n            }\r\n            grid.push(curRow);\r\n        }\r\n        // this.references = grid.map((row: Array<Node>) => {\r\n        //    return row.map(() => {\r\n        //        return React.createRef();\r\n        //    });\r\n        // });\r\n        this.setState({grid: grid, startPos: DEFAULTSTARTPOS, finishPos: DEFAULTFINISHPOS, mouseState: MouseState.PlacingWall, isMouseDown: false});\r\n    }\r\n\r\n    updateMouseState(position: Position, eventType: string): void {\r\n        switch (eventType) {\r\n            case \"mousedown\": {\r\n                this.onMouseDown(position);\r\n                break;\r\n            }\r\n            case \"mouseup\": {\r\n                this.onMouseUp();\r\n                break;\r\n            }\r\n            case \"mouseenter\": {\r\n                this.onMouseEnter(position);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private onMouseDown(position: Position) {\r\n        let {grid, mouseState, isMouseDown} = this.state;\r\n        let nodeType: NodeType = grid[position.y][position.x].nodeType;\r\n        if ((mouseState === MouseState.MovingStart && this.isFinish(position)) || (mouseState === MouseState.MovingFinish && this.isStart(position))) return;\r\n\r\n        mouseState = this.isStart(position) ? MouseState.MovingStart : this.isFinish(position) ? MouseState.MovingFinish : nodeType === NodeType.Unvisited ? MouseState.PlacingWall : MouseState.RemovingWall;\r\n\r\n        if (!this.isStart(position) && !this.isFinish(position)) {\r\n            if (nodeType === NodeType.Wall) {\r\n                grid[position.y][position.x].nodeType = NodeType.Unvisited;\r\n            } else {\r\n                grid[position.y][position.x].nodeType = NodeType.Wall\r\n            }\r\n        }\r\n        isMouseDown = true;\r\n        this.setState({grid: grid, mouseState: mouseState, isMouseDown: isMouseDown});\r\n    }\r\n\r\n    private onMouseUp() {\r\n        let mouseState = MouseState.PlacingWall;\r\n        let isMouseDown = false;\r\n        this.setState({mouseState: mouseState, isMouseDown: isMouseDown});\r\n    }\r\n\r\n    private onMouseEnter(position: Position) {\r\n        let {grid, startPos, finishPos, mouseState, isMouseDown} = this.state;\r\n        if (!isMouseDown || this.isStart(position) || this.isFinish(position)) return;\r\n\r\n        switch (mouseState) {\r\n            case MouseState.MovingStart:\r\n                startPos = position;\r\n                this.setState({startPos: startPos});\r\n                break;\r\n            case MouseState.MovingFinish:\r\n                finishPos = position;\r\n                this.setState({finishPos: finishPos});\r\n                break;\r\n            case MouseState.PlacingWall:\r\n                grid[position.y][position.x].nodeType = NodeType.Wall;\r\n                this.setState({grid: grid});\r\n                break;\r\n            case MouseState.RemovingWall:\r\n                grid[position.y][position.x].nodeType = NodeType.Unvisited;\r\n                this.setState({grid: grid});\r\n                break;\r\n        }\r\n    }\r\n\r\n    private isStart(position: Position) {\r\n        return position.x === this.state.startPos.x && position.y === this.state.startPos.y;\r\n    }\r\n\r\n    private isFinish(position: Position) {\r\n        return position.x === this.state.finishPos.x && position.y === this.state.finishPos.y;\r\n    }\r\n\r\n    private performAlgorithm(algorithm: PathfindingAlgorithm): void {\r\n        algorithm.calculatePath(this.state.grid, this.state.startPos, this.state.finishPos);\r\n        let visitedInOrder: Array<Position> = algorithm.produceVisitedInOrder();\r\n        let shortestPath: Array<Position> = algorithm.produceShortestPath();\r\n        this.visualiseAlgorithm(visitedInOrder, shortestPath);\r\n    }\r\n\r\n    private visualiseAlgorithm(visitedInOrder: Array<Position>, shortestPath: Array<Position>): void {\r\n        (async () => {\r\n            await this.visualiseVisited(visitedInOrder);\r\n            await this.visualisePath(shortestPath);\r\n        })();\r\n    }\r\n\r\n    private visualiseVisited(visitedInOrder: Array<Position>): Promise<void> {\r\n        return new Promise(resolve => {\r\n            let posIdx: number = 0;\r\n            setInterval(() => {\r\n                if (posIdx === visitedInOrder.length) {\r\n                    resolve();\r\n                } else {\r\n                    let position: Position = visitedInOrder[posIdx];\r\n                    document.getElementById(`cell-${position.x}-${position.y}`).className = \"cell cell-visited\";\r\n                    posIdx++;\r\n                }\r\n            }, UPDATERATE * posIdx)\r\n        });\r\n    }\r\n\r\n    private visualisePath(shortestPath: Array<Position>): Promise<void> {\r\n        return new Promise(resolve => {\r\n            let posIdx: number = 0;\r\n            setInterval(() => {\r\n                if (posIdx === shortestPath.length) {\r\n                    resolve();\r\n                } else {\r\n                    let position: Position = shortestPath[posIdx];\r\n                    document.getElementById(`cell-${position.x}-${position.y}`).className = \"cell cell-shortestPath\";\r\n                    posIdx++;\r\n                }\r\n            }, UPDATERATE * posIdx)\r\n        });\r\n    }\r\n\r\n    public render(): any {\r\n        let grid = this.state.grid;\r\n        return (\r\n            <div>\r\n            <Navbar performAlgorithm = {(algorithm: PathfindingAlgorithm) => this.performAlgorithm(algorithm)}/>\r\n            <div className = \"grid\">\r\n                {grid.map((row: Array<Node>, rowIdx) => {\r\n                    return (<div className=\"grid-row\" key = {rowIdx}>\r\n                        {row.map((cell: Node, colIdx) => {\r\n                            return (<Cell\r\n                                position = {{x: colIdx, y: rowIdx}}\r\n                                isStart={this.state.startPos.x === colIdx && this.state.startPos.y === rowIdx}\r\n                                isFinish={this.state.finishPos.x === colIdx && this.state.finishPos.y === rowIdx}\r\n                                nodeType = {cell.nodeType}\r\n                                updateMouseState = {(position: Position, eventType: string) => this.updateMouseState(position, eventType)}\r\n                                // ref = {this.references[rowIdx][colIdx]}\r\n                                key = {colIdx}/>)\r\n                        })}\r\n                    </div>)\r\n                })}\r\n            </div>\r\n            </div>\r\n        )\r\n    }\r\n}","import * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport App from \"./components/App\";\r\n\r\n\r\nReactDOM.render(\r\n    <App/>,\r\n    document.getElementById(\"root\")\r\n);","module.exports = ReactDOM;","import * as React from \"react\";\r\nimport Pathfinder from \"../Pathfinder\";\r\nimport {Component} from \"react\";\r\n\r\n\r\nexport default class App extends Component {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render(): any {\r\n        return (<div className=\"app\">\r\n            <Pathfinder/>\r\n        </div>);\r\n    }\r\n}","import * as React from \"react\";\r\nimport {Component} from \"react\";\r\nimport {NodeType, Position} from \"./Pathfinder\";\r\n\r\nexport default class Cell extends Component<\r\n    {\r\n        position: Position,\r\n        isStart: boolean,\r\n        isFinish: boolean,\r\n        nodeType: NodeType,\r\n        updateMouseState: (position: Position, eventType: string) => void,\r\n        // ref: React.RefObject<any>\r\n    },\r\n    {}>{\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    handleMouseEvent(event: React.MouseEvent<HTMLElement>): void {\r\n        let eventType: string =  event.type;\r\n        let position: Position = this.props.position;\r\n        this.props.updateMouseState(position, eventType);\r\n    }\r\n\r\n    render(): any {\r\n        let {isStart, isFinish, nodeType} = this.props;\r\n        let className: string;\r\n        if (isStart || isFinish) {\r\n            className = isStart ? \"cell-start\" : isFinish ? \"cell-finish\" : \"\";\r\n        } else {\r\n            switch (nodeType) {\r\n                case NodeType.Unvisited:    className = \"cell-unvisited\"; break;\r\n                case NodeType.Visited:      className = \"cell-visited\"; break;\r\n                case NodeType.Wall:         className = \"cell-wall\"; break;\r\n                case NodeType.ShortestPath: className = \"cell-shortestPath\"; break;\r\n            }\r\n        }\r\n        return (\r\n            <div id={`cell-${this.props.position.x}-${this.props.position.y}`} className={`cell ${className}`}\r\n                 onMouseDown    =   {(event) => this.handleMouseEvent(event)}\r\n                 onMouseUp      =   {(event) => this.handleMouseEvent(event)}\r\n                 onMouseEnter   =   {(event) => this.handleMouseEvent(event)}\r\n            />\r\n        )\r\n    }\r\n}","import {Component} from \"react\";\r\nimport * as React from \"react\";\r\nimport {render} from \"react-dom\";\r\nimport PathfindingAlgorithm from \"./Algorithms/PathfindingAlgorithm\";\r\nimport Dijkstra from \"./Algorithms/Dijkstra\";\r\n\r\nexport default class extends Component<{performAlgorithm: (algorithm: PathfindingAlgorithm) => void},{}> {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render(): any {\r\n        return (\r\n            <div className=\"navbar\">\r\n                <button onClick={() => {this.props.performAlgorithm(new Dijkstra())}}>Djikstra</button>\r\n            </div>\r\n        )\r\n    }\r\n}","import PathfindingAlgorithm from \"./PathfindingAlgorithm\";\r\nimport {Node, NodeType, Position} from \"../Pathfinder\";\r\nimport {PriorityQueue} from \"./PriorityQueue\";\r\n\r\ninterface PathObject {\r\n    shortestPath: number,\r\n    previousNode: Position,\r\n}\r\n\r\nexport default class Dijkstra extends PathfindingAlgorithm {\r\n    pathValues: Array<Array<PathObject>>;\r\n    minHeap: PriorityQueue<Position>;\r\n    constructor() {\r\n        super();\r\n        this.pathValues = [];\r\n        this.minHeap= new PriorityQueue();\r\n    }\r\n\r\n    calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.pathValues = grid.map((row) => {\r\n            return row.map((node) => {\r\n                let nodePosition: Position = node.position;\r\n                let shortestPath: number;\r\n                if (startPos.x === nodePosition.x && startPos.y === nodePosition.y) {\r\n                    shortestPath = 0;\r\n                } else {\r\n                    shortestPath = Infinity;\r\n                }\r\n                return {shortestPath: shortestPath, previousNode: null}\r\n            });\r\n        });\r\n        this.minHeap.insert(startPos, 0);\r\n\r\n        // for (let row = 0; row < grid.length; row++) {\r\n        //     for (let col = 0; col < grid[0].length; col++) {\r\n        //         let position: Position = {x: col, y: row};\r\n        //         let pathObject: PathObject;\r\n        //         let shortestPath: number;\r\n        //         if (position.x === startPos.x && position.y === startPos.y) {\r\n        //             shortestPath = 0;\r\n        //         } else {\r\n        //             shortestPath = Infinity;\r\n        //         }\r\n        //         pathObject = {shortestPath: shortestPath, previousNode: null};\r\n        //         this.map.set(position, pathObject);\r\n        //     }\r\n        // }\r\n\r\n        while (this.minHeap.size() !== 0) {\r\n            let closestPosition: Position = this.minHeap.pop();\r\n            let closestDistance: number = this.pathValues[closestPosition.y][closestPosition.x].shortestPath;\r\n            console.log(`POS: ${closestPosition.x} ${closestPosition.y}`);\r\n            if (closestDistance === Infinity) {\r\n                console.log(\"INFINITY REACHED\");\r\n                return;\r\n            }\r\n            if (closestPosition.x === finishPos.x && closestPosition.y === finishPos.y) {\r\n                console.log(\"FINISH REACHED\");\r\n                this.getShortestPath(startPos, finishPos);\r\n                return;\r\n            }\r\n            if (closestDistance !== 0) {\r\n                this.visitedNodesInOrder.push(closestPosition);\r\n            }\r\n            let neighbors: Array<Position> = this.getNeighbors(grid, closestPosition);\r\n            for (let neighborPosition of neighbors) {\r\n                let newDistance: number = this.pathValues[closestPosition.y][closestPosition.x].shortestPath + 1;\r\n                let neighborPathValues: PathObject = this.pathValues[neighborPosition.y][neighborPosition.x];\r\n                this.minHeap.insert(neighborPosition, newDistance);\r\n                if (newDistance < neighborPathValues.shortestPath) {\r\n                    this.pathValues[neighborPosition.y][neighborPosition.x] = {shortestPath: newDistance, previousNode: closestPosition};\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    getShortestPath(startPos: Position, finishPos: Position): void {\r\n        for (let curPosition = finishPos;\r\n             curPosition != null;\r\n             curPosition = this.pathValues[curPosition.y][curPosition.x].previousNode\r\n        ) {\r\n            this.shortestPathInOrder.unshift(curPosition);\r\n        }\r\n    }\r\n\r\n    getNeighbors(grid: Array<Array<Node>>, position: Position): Array<Position> {\r\n        let neighbors: Array<Position> = [];\r\n        if (position.x < grid[0].length - 1) {\r\n            neighbors.push({x: position.x + 1, y: position.y});\r\n        }\r\n        if (position.y > 0) {\r\n            neighbors.push({x: position.x, y: position.y - 1});\r\n        }\r\n        if (position.x > 0) {\r\n            neighbors.push({x: position.x - 1, y: position.y});\r\n        }\r\n        if (position.y < grid.length - 1) {\r\n            neighbors.push({x: position.x, y: position.y + 1});\r\n        }\r\n        return neighbors.filter((pos) => {\r\n            return this.pathValues[pos.y][pos.x].shortestPath === Infinity && grid[pos.y][pos.x].nodeType === NodeType.Unvisited;\r\n        });\r\n    }\r\n}","import {Node, Position} from \"../Pathfinder\";\r\n\r\nexport default abstract class PathfindingAlgorithm {\r\n    shortestPathInOrder: Array<Position>;\r\n    visitedNodesInOrder: Array<Position>;\r\n\r\n    constructor() {\r\n        this.shortestPathInOrder = [];\r\n        this.visitedNodesInOrder = [];\r\n    }\r\n\r\n    public abstract calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void;\r\n\r\n    public produceVisitedInOrder(): Array<Position> {\r\n        return this.visitedNodesInOrder;\r\n    }\r\n\r\n    public produceShortestPath() : Array<Position> {\r\n        return this.shortestPathInOrder;\r\n    }\r\n}\r\n\r\n// export interface Weighted {\r\n//\r\n// }\r\n//\r\n// export interface Unweighted {\r\n//\r\n// }\r\n//\r\n// export interface Unidirectional {\r\n//\r\n// }\r\n//\r\n// export interface Bidirectional {\r\n//\r\n// }","export interface Node {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport type Tuple<T> = [T, number];\r\n\r\nexport class PriorityQueue<T extends Node> {\r\n    heap: Tuple<T>[] = [];\r\n\r\n    constructor() {}\r\n\r\n    insert(val: T, priority: number) {\r\n        if (!this.heap.length || this.heap[this.heap.length - 1][1] > priority) {\r\n            this.heap.push([val, priority]);\r\n            return this.heap;\r\n        }\r\n\r\n        const tmp: Tuple<T>[] = [];\r\n        let found = false;\r\n\r\n        for (let i = 0; i < this.heap.length; i++) {\r\n            const p = this.heap[i][1];\r\n\r\n            if (priority >= p && !found) {\r\n                tmp.push([val, priority]);\r\n                found = true;\r\n            }\r\n\r\n            tmp.push(this.heap[i]);\r\n        }\r\n\r\n        return (this.heap = tmp);\r\n    }\r\n\r\n    has({ x, y }: T) {\r\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\r\n\r\n        return !!foundNode;\r\n    }\r\n\r\n    get({ x, y }: T) {\r\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\r\n\r\n        return foundNode && foundNode[0];\r\n    }\r\n\r\n    shift(priority: boolean) {\r\n        const tuple = this.heap.shift();\r\n        if (priority) {\r\n            return tuple;\r\n        }\r\n\r\n        return tuple ? tuple[0] : undefined;\r\n    }\r\n\r\n    pop() {\r\n        return this.heap.pop()[0];\r\n    }\r\n\r\n    priorities() {\r\n        return this.heap.map(([_, p]) => p);\r\n    }\r\n\r\n    values() {\r\n        return this.heap.map(([val]) => val);\r\n    }\r\n\r\n    size() {\r\n        return this.heap.length;\r\n    }\r\n\r\n    toArray(values: boolean) {\r\n        if (values) {\r\n            return this.heap.map(([val]) => val);\r\n        }\r\n        return this.heap;\r\n    }\r\n}"],"sourceRoot":""}