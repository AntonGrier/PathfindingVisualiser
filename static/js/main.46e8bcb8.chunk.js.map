{"version":3,"sources":["IPathfinder.tsx","Cell.tsx","Algorithms/PathfindingAlgorithm.tsx","Algorithms/DataStructures/PriorityQueue.tsx","Algorithms/Dijkstra.tsx","Algorithms/DataStructures/Stack.tsx","Algorithms/DFS.ts","Algorithms/DataStructures/Queue.ts","Algorithms/BFS.tsx","mazes/MazeGenerator.ts","mazes/RecursiveDivision.ts","mazes/WallCarver.ts","mazes/RecursiveBacktracking.ts","mazes/Ellers.ts","Algorithms/AStar.ts","Navbar.tsx","Algorithms/Perlin/PerlinNoise.ts","Pathfinder.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["MouseState","NodeType","screenWidth","Math","floor","window","innerWidth","screenHeight","innerHeight","GRID_W","GRID_H","DEFAULT_START_POS","x","y","DEFAULT_FINISH_POS","Cell","props","state","event","position","this","nativeEvent","which","eventType","type","updateMouseState","setMidpoint","weight","rbgVal","className","isStart","isFinish","isMidpoint","nodeType","Unvisited","VisitedOne","VisitedTwo","VisitedOverlap","Wall","ShortestPath","backgroundColor","convertWeightToGreyscale","ref","nodeRef","id","style","onMouseDown","handleMouseEvent","onMouseUp","onMouseEnter","onContextMenu","preventDefault","Component","PathfindingAlgorithm","pathValues","Map","finalPath","visitedNodesInOrder","slice","length","grid","neighbors","push","filter","neighbor","isVisited","cornerCheck","current","weightDifference","pow","sqrt","abs","get","hash","pathData","newPathData","set","finishPos","curPosition","previousNode","unshift","pos1","pos2","toString","PriorityQueue","heap","val","priority","replace","undefined","tmp","found","i","p","n","find","foundNode","tuple","shift","pop","map","values","Dijkstra","minHeap","startPos","reset","setMap","insert","size","closestPosition","markAsVisited","equalPosition","findShortestPath","getNeighbors","closestDistance","shortestPath","newDistance","getDistance","neighborPathData","forEach","row","node","nodePosition","Infinity","clear","Stack","data","top","Array","element","DFS","stack","isEmpty","reverse","Queue","BFS","queue","MazeGenerator","wallsCreatedInOrder","walls","topBorderWall","botBorderWall","leftBorderWall","rightBorderWall","min","max","random","RecursiveDivision","lr","divide","ul","splitIdx","gap","newLr","newUl","width","height","vertical","randomEven","console","log","randomOdd","pos","getRandom","ADJUSTED_WIDTH","ADJUSTED_HEIGHT","WallCarver","positionBetween","addWall","middleWall","crossWall","RecursiveBacktracking","visited","randomStartingPos","carveWalls","visit","getUnvisitedNeighbors","isVisisted","placeWallBetweenPositions","positionInBounds","randomisePositions","positions","sort","has","Ellers","generateMaze","currentRow","Uptree","mergeRow","prevRow","extendToNextRow","rowIdx","isRoot","addEntry","addTopWall","randomBool","getEntry","sameClass","mergeSets","addRightWall","fill","set1","set2","getRoot","index1","index2","index","value","AStar","setNeighbors","start","finish","costSoFar","distanceFromStart","distanceFromFinish","totalCost","prevPathData","Navbar","onClick","generateLandscape","performAlgorithm","clearPath","PerlinNoise","permutation","z","X","Y","Z","u","fade","v","w","A","AA","AB","B","BA","BB","scale","lerp","grad","t","a","b","h","Pathfinder","references","createRef","curRow","col","newNode","midpointPos","mouseState","PlacingWall","isMouseDown","updateLock","perlinToggle","prevAlgorithm","nextProps","nextState","Disabled","MovingStart","MovingFinish","MovingMidpoint","RemovingWall","setState","recalculatePath","visitedPaths","finalPaths","calculatePath","produceVisitedInOrder","produceFinalPath","idx","path","algorithm","visualiseAlgorithm","visitedInOrder","lockRender","visualiseVisited","visualisePath","concat","unlockRender","count","Promise","resolve","setTimeout","includes","perlin","seed","newWeight","noise","mazeGenerator","setupWalls","getSetup","generateWalls","setupStartingWalls","visualizeMaze","wallAlreadyPlaced","wall","nextMidPoint","key","cell","colIdx","App","Boolean","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.46e8bcb8.chunk.js","sourcesContent":["const screenWidth = Math.floor((0.95 * window.innerWidth) / 25);\r\nconst screenHeight = Math.floor((0.85 * window.innerHeight) / 25);\r\nexport const GRID_W = screenWidth % 2 === 0 ? screenWidth - 1 : screenWidth;\r\nexport const GRID_H = screenHeight % 2 === 0 ? screenHeight - 1 : screenHeight;\r\nexport const DEFAULT_START_POS: Position = { x: Math.floor(GRID_W / 4), y: Math.floor(GRID_H / 2) };\r\nexport const DEFAULT_FINISH_POS: Position = { x: GRID_W - DEFAULT_START_POS.x - 1, y: DEFAULT_START_POS.y };\r\nexport const UPDATE_RATE = 15;\r\n\r\nexport interface Position {\r\n    x: number;\r\n    y: number;\r\n}\r\nexport enum MouseState {\r\n    PlacingWall,\r\n    RemovingWall,\r\n    MovingStart,\r\n    MovingFinish,\r\n    MovingMidpoint,\r\n    Disabled,\r\n}\r\nexport enum NodeType {\r\n    Unvisited,\r\n    VisitedOne,\r\n    VisitedTwo,\r\n    VisitedOverlap,\r\n    Wall,\r\n    ShortestPath,\r\n}\r\nexport interface Node {\r\n    position: Position;\r\n    nodeType: NodeType;\r\n    weight: number;\r\n}\r\n","import * as React from 'react';\r\nimport { Component, RefObject } from 'react';\r\nimport { NodeType, Position } from './IPathfinder';\r\n\r\ninterface Props {\r\n    position: Position;\r\n    isStart: boolean;\r\n    isFinish: boolean;\r\n    isMidpoint: boolean;\r\n    nodeType: NodeType;\r\n    weight: number;\r\n    updateMouseState: (position: Position, eventType: string) => void;\r\n    setMidpoint: (position: Position) => void;\r\n    nodeRef: (ref: RefObject<HTMLDivElement> | any) => void;\r\n}\r\n\r\nexport default class Cell extends Component<Props> {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    handleMouseEvent(event: React.MouseEvent<HTMLElement>): void {\r\n        let position: Position = this.props.position;\r\n        if (event.nativeEvent.which === 1) {\r\n            let eventType: string = event.type;\r\n            this.props.updateMouseState(position, eventType);\r\n        } else if (event.nativeEvent.which === 3 && event.type === 'mousedown') {\r\n            this.props.setMidpoint(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param weight is a scale of difficulty of node traversal [0,1]\r\n     * @returns greyscale rgb value corresponding to the weight e.g.:\r\n     *          weight 0 produces 'rgb(255,255,255)'\r\n     *          weight 1 produces 'rgb(55,55,55)'\r\n     */\r\n    convertWeightToGreyscale(weight: number): string {\r\n        weight = 1 - weight;\r\n        const min = 55;\r\n        const max = 255;\r\n        const rbgVal = min + (max - min) * weight;\r\n        return `rgb(${rbgVal},${rbgVal},${rbgVal})`;\r\n    }\r\n\r\n    render(): any {\r\n        let { isStart, isFinish, isMidpoint, nodeType, weight } = this.props;\r\n        let className: string;\r\n        if (isStart || isFinish || isMidpoint) {\r\n            className = isStart ? 'cell-start' : isFinish ? 'cell-finish' : isMidpoint ? 'cell-midpoint' : '';\r\n        } else {\r\n            switch (nodeType) {\r\n                case NodeType.Unvisited:\r\n                    className = 'cell-unvisited';\r\n                    break;\r\n                case NodeType.VisitedOne:\r\n                    className = 'cell-visited-0';\r\n                    break;\r\n                case NodeType.VisitedTwo:\r\n                    className = 'cell-visited-1';\r\n                    break;\r\n                case NodeType.VisitedOverlap:\r\n                    className = 'cell-visited-overlap';\r\n                    break;\r\n                case NodeType.Wall:\r\n                    className = 'cell-wall';\r\n                    break;\r\n                case NodeType.ShortestPath:\r\n                    className = 'cell-shortestPath';\r\n                    break;\r\n            }\r\n        }\r\n        // TODO: Proper integration with visual perlin noise, w/o colour degradation with the regular pathfinding module\r\n        let backgroundColor = {};\r\n        if (nodeType !== NodeType.Wall && nodeType !== NodeType.ShortestPath && !isStart && !isFinish && weight > 0) {\r\n            backgroundColor = { backgroundColor: this.convertWeightToGreyscale(weight) };\r\n        }\r\n        return (\r\n            <div\r\n                ref={this.props.nodeRef}\r\n                id={`cell-${this.props.position.x}-${this.props.position.y}`}\r\n                className={`cell ${className}`}\r\n                style={{ ...backgroundColor }}\r\n                onMouseDown={(event) => this.handleMouseEvent(event)}\r\n                onMouseUp={(event) => this.handleMouseEvent(event)}\r\n                onMouseEnter={(event) => this.handleMouseEvent(event)}\r\n                onContextMenu={(event) => event.preventDefault()}\r\n            />\r\n        );\r\n    }\r\n}\r\n","import { GRID_H, GRID_W, Node, NodeType, Position } from '../IPathfinder';\r\n\r\nexport interface PathData {\r\n    isVisited: boolean;\r\n    shortestPath?: number;\r\n    previousNode?: Position;\r\n}\r\n\r\nexport default abstract class PathfindingAlgorithm {\r\n    pathValues: Map<string, PathData> = new Map<string, PathData>();\r\n    finalPath: Array<Position> = [];\r\n    visitedNodesInOrder: Array<Position> = [];\r\n\r\n    protected abstract setMap(grid: Node[][], startPos?: Position): void;\r\n\r\n    public abstract calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void;\r\n\r\n    public produceVisitedInOrder(): Position[] {\r\n        return this.visitedNodesInOrder.slice(1, this.visitedNodesInOrder.length - 1);\r\n    }\r\n\r\n    public produceFinalPath(): Position[] {\r\n        return this.finalPath.slice(1, this.visitedNodesInOrder.length - 1);\r\n    }\r\n\r\n    protected getNeighbors(grid: Node[][], position: Position): Array<Position> {\r\n        let neighbors: Array<Position> = [];\r\n        neighbors.push({ x: position.x + 1, y: position.y });\r\n        neighbors.push({ x: position.x, y: position.y + 1 });\r\n        neighbors.push({ x: position.x, y: position.y - 1 });\r\n        neighbors.push({ x: position.x - 1, y: position.y });\r\n\r\n        neighbors.push({ x: position.x - 1, y: position.y + 1 });\r\n        neighbors.push({ x: position.x + 1, y: position.y + 1 });\r\n        neighbors.push({ x: position.x + 1, y: position.y - 1 });\r\n        neighbors.push({ x: position.x - 1, y: position.y - 1 });\r\n\r\n        return neighbors.filter((neighbor) => {\r\n            return (\r\n                neighbor.x >= 0 &&\r\n                neighbor.x < GRID_W &&\r\n                neighbor.y >= 0 &&\r\n                neighbor.y < GRID_H &&\r\n                grid[neighbor.y][neighbor.x].nodeType !== NodeType.Wall &&\r\n                !this.isVisited(neighbor) &&\r\n                this.cornerCheck(position, neighbor, grid)\r\n            );\r\n        });\r\n    }\r\n\r\n    private cornerCheck(position: Position, neighbor: Position, grid: Node[][]): boolean {\r\n        return (\r\n            grid[position.y][neighbor.x].nodeType !== NodeType.Wall ||\r\n            grid[neighbor.y][position.x].nodeType !== NodeType.Wall\r\n        );\r\n    }\r\n\r\n    protected getDistance(grid: Node[][], current: Position, neighbor: Position): number {\r\n        let weightDifference = grid[neighbor.y][neighbor.x].weight - grid[current.y][current.x].weight;\r\n        return (\r\n            Math.pow(10000, weightDifference) *\r\n            Math.sqrt(Math.pow(Math.abs(current.x - neighbor.x), 2) + Math.pow(Math.abs(current.y - neighbor.y), 2))\r\n        );\r\n    }\r\n\r\n    protected isVisited(position: Position): boolean {\r\n        return this.pathValues.get(this.hash(position)).isVisited;\r\n    }\r\n\r\n    protected markAsVisited(position: Position): void {\r\n        this.visitedNodesInOrder.push(position);\r\n        let pathData: PathData = this.pathValues.get(this.hash(position));\r\n        let newPathData: PathData = {\r\n            ...pathData,\r\n            isVisited: true,\r\n        };\r\n        this.pathValues.set(this.hash(position), newPathData);\r\n    }\r\n\r\n    protected findShortestPath(finishPos: Position): void {\r\n        for (\r\n            let curPosition = finishPos;\r\n            curPosition != null;\r\n            curPosition = this.pathValues.get(this.hash(curPosition)).previousNode\r\n        ) {\r\n            this.finalPath.unshift(curPosition);\r\n        }\r\n    }\r\n\r\n    protected equalPosition(pos1: Position, pos2: Position) {\r\n        return pos1.x === pos2.x && pos1.y === pos2.y;\r\n    }\r\n\r\n    protected hash(position: Position): string {\r\n        return position.x.toString() + '-' + position.y.toString();\r\n    }\r\n\r\n    protected clear(): void {\r\n        this.visitedNodesInOrder = [];\r\n        this.finalPath = [];\r\n        this.pathValues = new Map<string, PathData>();\r\n    }\r\n\r\n    protected abstract reset(): void;\r\n}\r\n","export interface Node {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport type Tuple<T> = [T, number];\r\n\r\nexport class PriorityQueue<T extends Node> {\r\n    heap: Tuple<T>[] = [];\r\n\r\n    insert(val: T, priority: number, replace?: boolean) {\r\n        replace = replace !== undefined;\r\n\r\n        if (!this.heap.length || this.heap[this.heap.length - 1][1] > priority) {\r\n            this.heap.push([val, priority]);\r\n            return this.heap;\r\n        }\r\n\r\n        const tmp: Tuple<T>[] = [];\r\n        let found = false;\r\n\r\n        for (let i = 0; i < this.heap.length; i++) {\r\n            const p = this.heap[i][1];\r\n            const n = this.heap[i][0];\r\n\r\n            if (priority >= p && !found) {\r\n                tmp.push([val, priority]);\r\n                found = true;\r\n            }\r\n\r\n            if (!(replace && n.x === val.x && n.y === val.y)) {\r\n                tmp.push(this.heap[i]);\r\n            }\r\n        }\r\n        return (this.heap = tmp);\r\n    }\r\n\r\n    has({ x, y }: T) {\r\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\r\n\r\n        return !!foundNode;\r\n    }\r\n\r\n    get({ x, y }: T) {\r\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\r\n\r\n        return foundNode && foundNode[1];\r\n    }\r\n\r\n    shift(priority: boolean) {\r\n        const tuple = this.heap.shift();\r\n        if (priority) {\r\n            return tuple;\r\n        }\r\n\r\n        return tuple ? tuple[0] : undefined;\r\n    }\r\n\r\n    pop() {\r\n        return this.heap.pop()[0];\r\n    }\r\n\r\n    priorities() {\r\n        return this.heap.map(([_, p]) => p);\r\n    }\r\n\r\n    values() {\r\n        return this.heap.map(([val]) => val);\r\n    }\r\n\r\n    size() {\r\n        return this.heap.length;\r\n    }\r\n\r\n    toArray(values: boolean) {\r\n        if (values) {\r\n            return this.heap.map(([val]) => val);\r\n        }\r\n        return this.heap;\r\n    }\r\n}\r\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm';\r\nimport { Node, Position } from '../IPathfinder';\r\nimport { PriorityQueue } from './DataStructures/PriorityQueue';\r\n\r\nexport default class Dijkstra extends PathfindingAlgorithm {\r\n    minHeap: PriorityQueue<Position> = new PriorityQueue<Position>();\r\n    calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.reset();\r\n        this.setMap(grid, startPos);\r\n        this.minHeap.insert(startPos, 0);\r\n        while (this.minHeap.size() !== 0) {\r\n            let closestPosition: Position = this.minHeap.pop();\r\n            this.markAsVisited(closestPosition);\r\n            if (this.equalPosition(closestPosition, finishPos)) {\r\n                this.findShortestPath(finishPos);\r\n                return;\r\n            }\r\n            let neighbors: Array<Position> = this.getNeighbors(grid, closestPosition);\r\n            let closestDistance: number = this.pathValues.get(this.hash(closestPosition)).shortestPath;\r\n            for (let neighbor of neighbors) {\r\n                let newDistance: number = closestDistance + this.getDistance(grid, closestPosition, neighbor);\r\n                let neighborPathData: PathData = this.pathValues.get(this.hash(neighbor));\r\n                this.minHeap.insert(neighbor, newDistance);\r\n                if (newDistance < neighborPathData.shortestPath) {\r\n                    let pathData: PathData = {\r\n                        shortestPath: newDistance,\r\n                        isVisited: true,\r\n                        previousNode: closestPosition,\r\n                    };\r\n                    this.pathValues.set(this.hash(neighbor), pathData);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected setMap(grid: Array<Array<Node>>, startPos: Position): void {\r\n        grid.forEach((row) => {\r\n            return row.forEach((node) => {\r\n                let nodePosition: Position = node.position;\r\n                let shortestPath: number;\r\n                if (this.equalPosition(startPos, nodePosition)) {\r\n                    shortestPath = 0;\r\n                } else {\r\n                    shortestPath = Infinity;\r\n                }\r\n                let pathData: PathData = { shortestPath: shortestPath, isVisited: false, previousNode: null };\r\n                this.pathValues.set(this.hash(nodePosition), pathData);\r\n            });\r\n        });\r\n    }\r\n\r\n    protected reset(): void {\r\n        this.clear();\r\n        this.minHeap = new PriorityQueue<Position>();\r\n    }\r\n}\r\n","export default class Stack<T> {\r\n    data: Array<T>;\r\n    top: number;\r\n    constructor() {\r\n        this.data = new Array<T>();\r\n        this.top = 0;\r\n    }\r\n    public push(element: T): void {\r\n        this.data[this.top] = element;\r\n        this.top++;\r\n    }\r\n    public pop(): T {\r\n        this.top--;\r\n        return this.data[this.top];\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.top === 0;\r\n    }\r\n}\r\n","import PathfindingAlgorithm from './PathfindingAlgorithm';\r\nimport Stack from './DataStructures/Stack';\r\nimport { Position, Node } from '../IPathfinder';\r\n\r\nexport default class DFS extends PathfindingAlgorithm {\r\n    stack: Stack<Position> = new Stack<Position>();\r\n    calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.reset();\r\n        this.setMap(grid);\r\n        this.stack.push(startPos);\r\n        while (!this.stack.isEmpty()) {\r\n            let curPosition: Position = this.stack.pop();\r\n            this.markAsVisited(curPosition);\r\n            if (this.equalPosition(curPosition, finishPos)) {\r\n                this.finalPath = this.visitedNodesInOrder;\r\n                return;\r\n            }\r\n            let neighbors: Array<Position> = this.getNeighbors(grid, curPosition).reverse();\r\n            for (let neighbor of neighbors) {\r\n                this.stack.push(neighbor);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected setMap(grid: Array<Array<Node>>): void {\r\n        grid.forEach((row) => {\r\n            row.forEach((node) => {\r\n                let nodePosition: Position = node.position;\r\n                this.pathValues.set(this.hash(nodePosition), { isVisited: false });\r\n            });\r\n        });\r\n    }\r\n\r\n    protected reset(): void {\r\n        this.clear();\r\n        this.stack = new Stack<Position>();\r\n    }\r\n}\r\n","export default class Queue<T> {\r\n    data: Array<T> = [];\r\n    push(element: T) {\r\n        this.data.push(element);\r\n    }\r\n    pop(): T {\r\n        return this.data.shift();\r\n    }\r\n    isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n}\r\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm';\r\nimport Queue from './DataStructures/Queue';\r\nimport { Node, Position } from '../IPathfinder';\r\n\r\nexport default class BFS extends PathfindingAlgorithm {\r\n    queue: Queue<Position> = new Queue<Position>();\r\n\r\n    calculatePath(grid: Array<Array<Node>>, startPos: Position, finishPos: Position): void {\r\n        this.reset();\r\n        this.setMap(grid);\r\n        this.queue.push(startPos);\r\n        while (!this.queue.isEmpty()) {\r\n            let curPosition: Position = this.queue.pop();\r\n            this.markAsVisited(curPosition);\r\n            if (this.equalPosition(curPosition, finishPos)) {\r\n                this.findShortestPath(finishPos);\r\n                return;\r\n            }\r\n            let neighbors: Array<Position> = this.getNeighbors(grid, curPosition);\r\n            for (let neighbor of neighbors) {\r\n                this.queue.push(neighbor);\r\n                this.pathValues.set(this.hash(neighbor), { isVisited: true, previousNode: curPosition });\r\n            }\r\n        }\r\n    }\r\n\r\n    protected setMap(grid: Array<Array<Node>>): void {\r\n        grid.forEach((row) => {\r\n            row.forEach((node) => {\r\n                let nodePosition: Position = node.position;\r\n                let pathData: PathData = {\r\n                    isVisited: false,\r\n                    previousNode: null,\r\n                };\r\n                this.pathValues.set(this.hash(nodePosition), pathData);\r\n            });\r\n        });\r\n    }\r\n\r\n    // protected findShortestPath(finishPos: Position) {\r\n    //     for (\r\n    //         let curPosition = finishPos;\r\n    //         curPosition != null;\r\n    //         curPosition = this.pathValues.get(this.hash(curPosition)).previousNode\r\n    //     ) {\r\n    //         this.finalPath.unshift(curPosition);\r\n    //     }\r\n    // }\r\n\r\n    protected reset(): void {\r\n        this.clear();\r\n        this.queue = new Queue<Position>();\r\n    }\r\n}\r\n","import { Position, GRID_H, GRID_W } from './../IPathfinder';\r\nexport default abstract class MazeGenerator {\r\n    wallsCreatedInOrder: Position[];\r\n    public abstract generateWalls(): Position[];\r\n    public getSetup(): Position[] {\r\n        let walls: Position[] = [];\r\n        for (let i = 0; i < GRID_W; i++) {\r\n            let topBorderWall: Position = { x: i, y: 0 };\r\n            let botBorderWall: Position = { x: i, y: GRID_H - 1 };\r\n            walls.push(topBorderWall);\r\n            walls.push(botBorderWall);\r\n        }\r\n        for (let i = 1; i < GRID_H - 1; i++) {\r\n            let leftBorderWall: Position = { x: 0, y: i };\r\n            let rightBorderWall: Position = { x: GRID_W - 1, y: i };\r\n            walls.push(leftBorderWall);\r\n            walls.push(rightBorderWall);\r\n        }\r\n        return walls;\r\n    }\r\n    protected getRandom(min: number, max: number): number {\r\n        return min + Math.floor((max - min + 1) * Math.random());\r\n    }\r\n    protected addWall(position: Position) {\r\n        this.wallsCreatedInOrder.push(position);\r\n    }\r\n}\r\n","import MazeGenerator from './MazeGenerator';\r\nimport { Position, GRID_W, GRID_H } from '../IPathfinder';\r\n\r\nexport default class RecursiveDivision extends MazeGenerator {\r\n    public generateWalls(): Position[] {\r\n        this.wallsCreatedInOrder = [];\r\n        const ul: Position = { x: 0, y: 0 };\r\n        const lr: Position = { x: GRID_W - 1, y: GRID_H - 1 };\r\n        this.divide(ul, lr);\r\n        return this.wallsCreatedInOrder;\r\n    }\r\n\r\n    private divide(ul: Position, lr: Position) {\r\n        let width: number = lr.x - ul.x + 1;\r\n        let height: number = lr.y - ul.y + 1;\r\n        let vertical: boolean = width > height;\r\n        let splitIdx: number;\r\n        let gap: Position;\r\n        if (vertical) {\r\n            if (width < 4) return;\r\n            splitIdx = this.randomEven(ul.x, lr.x);\r\n            console.log(splitIdx);\r\n            gap = { x: splitIdx, y: this.randomOdd(ul.y, lr.y) };\r\n            console.log(`Trying ${splitIdx}, gap (${gap.x},${gap.y}) width: ${width} height: ${height}`);\r\n        } else {\r\n            if (height < 4) return;\r\n            splitIdx = this.randomEven(ul.y, lr.y);\r\n            console.log(splitIdx);\r\n            gap = { x: this.randomOdd(ul.x, lr.x), y: splitIdx };\r\n            console.log(`Trying ${splitIdx}, gap (${gap.x},${gap.y}) width: ${width} height: ${height}`);\r\n        }\r\n\r\n        for (let i = vertical ? ul.y + 1 : ul.x + 1; i <= (vertical ? lr.y - 1 : lr.x - 1); i++) {\r\n            if (i === (vertical ? gap.y : gap.x)) continue;\r\n            let pos: Position;\r\n            if (vertical) {\r\n                pos = { x: splitIdx, y: i };\r\n            } else {\r\n                pos = { x: i, y: splitIdx };\r\n            }\r\n            this.wallsCreatedInOrder.push(pos);\r\n        }\r\n\r\n        let newLr: Position;\r\n        let newUl: Position;\r\n        if (vertical) {\r\n            newLr = { x: splitIdx, y: lr.y };\r\n            newUl = { x: splitIdx, y: ul.y };\r\n        } else {\r\n            newLr = { x: lr.x, y: splitIdx };\r\n            newUl = { x: ul.x, y: splitIdx };\r\n        }\r\n\r\n        this.divide(ul, newLr);\r\n        this.divide(newUl, lr);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param min\r\n     * @param max\r\n     *\r\n     * produce a random even number in a range to match a valid wall coordinate that is not next to a current wall\r\n     */\r\n    private randomEven(min: number, max: number): number {\r\n        min += 2;\r\n        max -= 2;\r\n        if (min % 2 === 1) {\r\n            min++;\r\n        }\r\n        if (max % 2 === 1) {\r\n            max--;\r\n        }\r\n        let wall = min + 2 * this.getRandom(0, (max - min) / 2);\r\n        return wall;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param min\r\n     * @param max\r\n     *\r\n     * produce a random odd number in a range to match a valid gap coordinate\r\n     */\r\n    private randomOdd(min: number, max: number): number {\r\n        min += 2;\r\n        max -= 2;\r\n        if (min % 2 === 0) {\r\n            min++;\r\n        }\r\n        if (max % 2 === 0) {\r\n            max--;\r\n        }\r\n        let gap = min + 2 * this.getRandom(0, (max - min) / 2);\r\n        return gap;\r\n    }\r\n\r\n    private hash(position: Position): string {\r\n        return position.x.toString() + '-' + position.y.toString();\r\n    }\r\n}\r\n","import MazeGenerator from './MazeGenerator';\r\nimport { Position, GRID_W, GRID_H } from '../IPathfinder';\r\n\r\nexport const ADJUSTED_WIDTH = (GRID_W - 1) / 2;\r\nexport const ADJUSTED_HEIGHT = (GRID_H - 1) / 2;\r\n\r\nexport default abstract class WallCarver extends MazeGenerator {\r\n    protected placeWallBetweenPositions(current: Position, neighbor: Position): void {\r\n        let positionBetween: Position = {\r\n            x: Math.floor((current.x + neighbor.x) / 2),\r\n            y: Math.floor((current.y + neighbor.y) / 2),\r\n        };\r\n        this.addWall(positionBetween);\r\n    }\r\n\r\n    protected positionInBounds(position: Position): boolean {\r\n        return position.x > 0 && position.x < GRID_W - 1 && position.y > 0 && position.y < GRID_H - 1;\r\n    }\r\n\r\n    public getSetup(): Position[] {\r\n        let walls: Position[] = [];\r\n        for (let i = 0; i < GRID_W; i++) {\r\n            let topBorderWall: Position = { x: i, y: 0 };\r\n            let botBorderWall: Position = { x: i, y: GRID_H - 1 };\r\n            walls.push(topBorderWall);\r\n            walls.push(botBorderWall);\r\n        }\r\n        for (let x = 0; x < GRID_W; x += 2) {\r\n            for (let y = 1; y < GRID_H - 1; y++) {\r\n                let middleWall: Position = { x: x, y: y };\r\n                walls.push(middleWall);\r\n            }\r\n        }\r\n        for (let x = 1; x < GRID_W - 1; x += 2) {\r\n            for (let y = 2; y < GRID_H - 2; y += 2) {\r\n                let crossWall: Position = { x: x, y: y };\r\n                walls.push(crossWall);\r\n            }\r\n        }\r\n        return walls;\r\n    }\r\n}\r\n","import { Position, GRID_W, GRID_H } from '../IPathfinder';\r\nimport WallCarver from './WallCarver';\r\n\r\nexport default class RecursiveBacktracking extends WallCarver {\r\n    visited: Map<String, boolean>;\r\n    public generateWalls(): Position[] {\r\n        this.wallsCreatedInOrder = [];\r\n        this.visited = new Map<string, boolean>();\r\n        let randomStartingPos: Position = {\r\n            x: 2 * this.getRandom(1, (GRID_W - 1) / 2) - 1,\r\n            y: 2 * this.getRandom(1, (GRID_H - 1) / 2) - 1,\r\n        };\r\n        this.carveWalls(randomStartingPos);\r\n        return this.wallsCreatedInOrder;\r\n    }\r\n\r\n    carveWalls(current: Position): void {\r\n        this.visit(current);\r\n        let neighbors: Position[] = this.getUnvisitedNeighbors(current);\r\n        for (let neighbor of neighbors) {\r\n            console.log(neighbor);\r\n            if (!this.isVisisted(neighbor)) {\r\n                this.placeWallBetweenPositions(current, neighbor);\r\n                this.carveWalls(neighbor);\r\n            }\r\n        }\r\n    }\r\n\r\n    private getUnvisitedNeighbors(current: Position): Position[] {\r\n        let right: Position = { x: current.x + 2, y: current.y };\r\n        let up: Position = { x: current.x, y: current.y - 2 };\r\n        let left: Position = { x: current.x - 2, y: current.y };\r\n        let bot: Position = { x: current.x, y: current.y + 2 };\r\n        let neighbors: Position[] = [right, up, left, bot];\r\n        neighbors = neighbors.filter((pos: Position) => {\r\n            return this.positionInBounds(pos);\r\n        });\r\n        return this.randomisePositions(neighbors);\r\n    }\r\n\r\n    private randomisePositions(positions: Position[]): Position[] {\r\n        return positions.sort(() => Math.random() - 0.5);\r\n    }\r\n\r\n    private visit(position: Position): void {\r\n        this.visited.set(this.hash(position), true);\r\n    }\r\n\r\n    private isVisisted(position: Position): boolean {\r\n        return this.visited.has(this.hash(position));\r\n    }\r\n\r\n    private hash(position: Position): string {\r\n        return position.x.toString() + '-' + position.y.toString();\r\n    }\r\n}\r\n","import { Position } from '../IPathfinder';\r\nimport WallCarver, { ADJUSTED_WIDTH, ADJUSTED_HEIGHT } from './WallCarver';\r\n\r\nexport default class Ellers extends WallCarver {\r\n    public generateWalls(): Position[] {\r\n        this.wallsCreatedInOrder = [];\r\n        this.generateMaze();\r\n        return this.wallsCreatedInOrder;\r\n    }\r\n\r\n    private generateMaze(): void {\r\n        let currentRow: Uptree = new Uptree();\r\n        currentRow = this.mergeRow(currentRow, 0, true);\r\n        for (let y = 1; y < ADJUSTED_HEIGHT; y++) {\r\n            let prevRow = currentRow;\r\n            currentRow = this.extendToNextRow(currentRow, prevRow, y);\r\n            currentRow = this.mergeRow(currentRow, y, y !== ADJUSTED_HEIGHT - 1);\r\n        }\r\n    }\r\n    extendToNextRow(currentRow: Uptree, prevRow: Uptree, rowIdx: number) {\r\n        currentRow = new Uptree();\r\n        for (let x = 0; x < ADJUSTED_WIDTH; x++) {\r\n            if (prevRow.isRoot(x)) {\r\n                currentRow.addEntry(x, -1);\r\n                this.addTopWall({ x: x, y: rowIdx });\r\n            } else if (this.randomBool()) {\r\n                currentRow.addEntry(x, prevRow.getEntry(x));\r\n                this.addTopWall({ x: x, y: rowIdx });\r\n            }\r\n        }\r\n        return currentRow;\r\n    }\r\n\r\n    private mergeRow(row: Uptree, rowIdx: number, random: boolean) {\r\n        for (let i = 0; i < ADJUSTED_WIDTH - 1; i++) {\r\n            if ((this.randomBool() || !random) && !row.sameClass(i, i + 1)) {\r\n                row.mergeSets(i, i + 1);\r\n                this.addRightWall({ x: i, y: rowIdx });\r\n            }\r\n        }\r\n        return row;\r\n    }\r\n    addRightWall(pos: Position): void {\r\n        this.addWall({ x: 2 * pos.x + 2, y: 2 * pos.y + 1 });\r\n    }\r\n\r\n    addTopWall(pos: Position): void {\r\n        this.addWall({ x: 2 * pos.x + 1, y: 2 * pos.y });\r\n    }\r\n\r\n    private randomBool(): boolean {\r\n        return Math.random() >= 0.5;\r\n    }\r\n}\r\n\r\nclass Uptree {\r\n    data: number[];\r\n    constructor() {\r\n        this.data = Array(ADJUSTED_WIDTH).fill(-1);\r\n    }\r\n\r\n    public mergeSets(set1: number, set2: number): void {\r\n        if (this.data[set1] === -1) {\r\n            this.data[set1] = this.getRoot(set2);\r\n        } else {\r\n            this.data[set2] = this.getRoot(set1);\r\n        }\r\n    }\r\n\r\n    public sameClass(index1: number, index2: number) {\r\n        return this.getRoot(index1) === this.getRoot(index2);\r\n    }\r\n\r\n    public getRoot(index: number): number {\r\n        while (this.data[index] !== -1) {\r\n            index = this.data[index];\r\n        }\r\n        return index;\r\n    }\r\n\r\n    public isRoot(index: number): boolean {\r\n        return this.data[index] === -1;\r\n    }\r\n\r\n    public addEntry(index: number, value: number) {\r\n        this.data[index] = value;\r\n    }\r\n\r\n    public getEntry(index: number): number {\r\n        return this.getRoot(index);\r\n    }\r\n}\r\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm';\r\nimport { Node, Position } from '../IPathfinder';\r\nimport { PriorityQueue } from './DataStructures/PriorityQueue';\r\n\r\nexport default class AStar extends PathfindingAlgorithm {\r\n    minHeap: PriorityQueue<Position> = new PriorityQueue<Position>();\r\n\r\n    public calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void {\r\n        this.reset();\r\n        this.setMap(grid, startPos);\r\n        this.minHeap.insert(startPos, 0);\r\n        while (this.minHeap.size() > 0) {\r\n            let closestPosition: Position = this.minHeap.pop();\r\n            if (this.pathValues.get(this.hash(closestPosition)).isVisited) {\r\n                continue;\r\n            }\r\n            this.markAsVisited(closestPosition);\r\n            if (this.equalPosition(closestPosition, finishPos)) {\r\n                this.findShortestPath(finishPos);\r\n                return;\r\n            }\r\n            this.setNeighbors(grid, closestPosition, startPos, finishPos);\r\n        }\r\n    }\r\n\r\n    private setNeighbors(grid: Node[][], current: Position, start: Position, finish: Position): void {\r\n        let neighbors = this.getNeighbors(grid, current);\r\n        let costSoFar: number = this.pathValues.get(this.hash(current)).shortestPath;\r\n        for (let neighbor of neighbors) {\r\n            // let pathData: PathData = this.pathValues.get(this.hash(neighbor));\r\n            let distanceFromStart: number = costSoFar + this.getDistance(grid, neighbor, current);\r\n            let distanceFromFinish: number = this.getDistance(grid, neighbor, finish);\r\n            let totalCost: number = distanceFromStart + distanceFromFinish;\r\n            let prevPathData: PathData = this.pathValues.get(this.hash(neighbor));\r\n            if (prevPathData.previousNode !== null) {\r\n                let prevCost: number = prevPathData.shortestPath + distanceFromFinish;\r\n                if (totalCost < prevCost) {\r\n                    this.minHeap.insert(neighbor, totalCost, true);\r\n                    this.pathValues.set(this.hash(neighbor), {\r\n                        isVisited: false,\r\n                        previousNode: current,\r\n                        shortestPath: distanceFromStart,\r\n                    });\r\n                }\r\n            } else {\r\n                this.minHeap.insert(neighbor, totalCost, false);\r\n                this.pathValues.set(this.hash(neighbor), {\r\n                    isVisited: false,\r\n                    previousNode: current,\r\n                    shortestPath: distanceFromStart,\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    protected setMap(grid: Node[][], startPos: Position): void {\r\n        grid.forEach((row: Node[]) => {\r\n            return row.forEach((node: Node) => {\r\n                let nodePosition: Position = node.position;\r\n                let shortestPath: number;\r\n                if (this.equalPosition(startPos, nodePosition)) {\r\n                    shortestPath = 0;\r\n                } else {\r\n                    shortestPath = Infinity;\r\n                }\r\n                let pathData: PathData = { isVisited: false, shortestPath: shortestPath, previousNode: null };\r\n                this.pathValues.set(this.hash(nodePosition), pathData);\r\n            });\r\n        });\r\n    }\r\n    protected reset(): void {\r\n        this.clear();\r\n        this.minHeap = new PriorityQueue<Position>();\r\n    }\r\n}\r\n","import { Component } from 'react';\r\nimport * as React from 'react';\r\nimport PathfindingAlgorithm from './Algorithms/PathfindingAlgorithm';\r\nimport Dijkstra from './Algorithms/Dijkstra';\r\nimport DFS from './Algorithms/DFS';\r\nimport BFS from './Algorithms/BFS';\r\nimport MazeGenerator from './mazes/MazeGenerator';\r\nimport RecursiveDivision from './mazes/RecursiveDivision';\r\nimport RecursiveBacktracking from './mazes/RecursiveBacktracking';\r\nimport Ellers from './mazes/Ellers';\r\nimport AStar from './Algorithms/AStar';\r\n\r\ninterface Props {\r\n    performAlgorithm: (algorithm: PathfindingAlgorithm) => void;\r\n    clearPath: () => void;\r\n    generateLandscape: () => void;\r\n    generateMaze: (mazeGenerator: MazeGenerator) => void;\r\n}\r\n\r\nexport default class Navbar extends Component<Props> {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render(): any {\r\n        return (\r\n            <ul>\r\n                <li><a\r\n                    onClick={() => {\r\n                        this.props.generateMaze(new Ellers());\r\n                    }}\r\n                >\r\n                    Ellers\r\n                </a></li>\r\n                <li><a\r\n                    onClick={() => {\r\n                        this.props.generateMaze(new RecursiveBacktracking());\r\n                    }}\r\n                >\r\n                    Recursive BackTrack\r\n                </a></li>\r\n                <li><a\r\n                    onClick={() => {\r\n                        this.props.generateMaze(new RecursiveDivision());\r\n                    }}\r\n                >\r\n                    Recursive Division\r\n                </a></li>\r\n                <li><a\r\n                    onClick={() => {\r\n                        this.props.generateLandscape();\r\n                    }}\r\n                >\r\n                    Generate Landscape\r\n                </a></li>\r\n                <li><a\r\n                    onClick={() => {\r\n                        this.props.performAlgorithm(new AStar());\r\n                    }}\r\n                >\r\n                    AStar\r\n                </a></li>\r\n                <li><a\r\n                    onClick={() => {\r\n                        this.props.performAlgorithm(new Dijkstra());\r\n                    }}\r\n                >\r\n                    Dijkstra\r\n                </a></li>\r\n                <li><a\r\n                    onClick={() => {\r\n                        this.props.performAlgorithm(new DFS());\r\n                    }}\r\n                >\r\n                    DFS\r\n                </a></li>\r\n                <li><a\r\n                    onClick={() => {\r\n                        this.props.performAlgorithm(new BFS());\r\n                    }}\r\n                >\r\n                    BFS\r\n                </a></li>\r\n                <li><a\r\n                    onClick={() => {\r\n                        this.props.clearPath();\r\n                    }}\r\n                >\r\n                    Clear\r\n                </a></li> \r\n            </ul>\r\n        );\r\n    }\r\n}\r\n","// Credit to https://github.com/Bartvds/lorez/blob/master/src/extra/PerlinNoise.ts\r\n\r\nexport default class PerlinNoise {\r\n\r\n\tprivate p: number[];\r\n\tprivate permutation: number[];\r\n\r\n\tconstructor() {\r\n\t\t// To remove the need for index wrapping, double the permutation table length\r\n\t\tthis.permutation = [ 151, 160, 137, 91, 90, 15,\r\n\t\t\t131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\r\n\t\t\t190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\r\n\t\t\t88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\r\n\t\t\t77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\r\n\t\t\t102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\r\n\t\t\t135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\r\n\t\t\t5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\r\n\t\t\t223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\r\n\t\t\t129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\r\n\t\t\t251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\r\n\t\t\t49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\r\n\t\t\t138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\r\n\t\t];\r\n\t\tthis.p = new Array(512);\r\n\r\n\t\tfor (var i = 0; i < 256; i++) {\r\n\t\t\tthis.p[256 + i] = this.p[i] = this.permutation[i];\r\n\t\t}\r\n\t}\r\n\r\n\tnoise(x: number, y: number, z: number): number {\r\n\t\tvar X = Math.floor(x) & 255;     // FIND UNIT CUBE THAT\r\n\t\tvar Y = Math.floor(y) & 255;     // CONTAINS POINT.\r\n\t\tvar Z = Math.floor(z) & 255;\r\n\r\n\t\tx -= Math.floor(x);              // FIND RELATIVE X,Y,Z\r\n\t\ty -= Math.floor(y);              // OF POINT IN CUBE.\r\n\t\tz -= Math.floor(z);\r\n\r\n\t\tvar u = this.fade(x);            // COMPUTE FADE CURVES\r\n\t\tvar v = this.fade(y);            // FOR EACH OF X,Y,Z.\r\n\t\tvar w = this.fade(z);\r\n\r\n\t\tvar A = this.p[X] + Y;\r\n\t\tvar AA = this.p[A] + Z;\r\n\t\tvar AB = this.p[A + 1] + Z;      // HASH COORDINATES OF\r\n\r\n\t\tvar B = this.p[X + 1] + Y;\r\n\t\tvar BA = this.p[B] + Z;\r\n\t\tvar BB = this.p[B + 1] + Z;      // THE 8 CUBE CORNERS,\r\n\r\n\t\treturn this.scale(this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA  ], x, y, z),  // AND ADD\r\n\t\t\t\t\tthis.grad(this.p[BA], x - 1, y, z)), // BLENDED\r\n\t\t\t\tthis.lerp(u, this.grad(this.p[AB], x, y - 1, z),  // RESULTS\r\n\t\t\t\t\tthis.grad(this.p[BB], x - 1, y - 1, z))),// FROM  8\r\n\t\t\tthis.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),  // CORNERS\r\n\t\t\t\t\tthis.grad(this.p[BA + 1], x - 1, y, z - 1)), // OF CUBE\r\n\t\t\t\tthis.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),\r\n\t\t\t\t\tthis.grad(this.p[BB + 1], x - 1, y - 1, z - 1)))));\r\n\t}\r\n\r\n\tfade(t: number): number {\r\n\t\treturn t * t * t * (t * (t * 6 - 15) + 10);\r\n\t}\r\n\r\n\tlerp(t: number, a: number, b: number): number {\r\n\t\treturn a + t * (b - a);\r\n\t}\r\n\r\n\tgrad(hash: number, x: number, y: number, z: number): number {\r\n\t\tvar h = hash & 15;      // CONVERT LO 4 BITS OF HASH CODE\r\n\t\tvar u = h < 8 ? x : y;  // INTO 12 GRADIENT DIRECTIONS.\r\n\t\tvar v = h < 4 ? y : h === 12 || h === 14 ? x : z;\r\n\t\treturn ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);\r\n\t}\r\n\r\n\tscale(n: number): number {\r\n\t\treturn (1 + n) / 2;\r\n\t}\r\n}","import * as React from 'react';\r\nimport {\r\n    Node,\r\n    NodeType,\r\n    Position,\r\n    MouseState,\r\n    GRID_W,\r\n    GRID_H,\r\n    DEFAULT_START_POS,\r\n    DEFAULT_FINISH_POS,\r\n    UPDATE_RATE,\r\n} from './IPathfinder';\r\nimport { Component, createRef, RefObject } from 'react';\r\nimport Cell from './Cell';\r\nimport Navbar from './Navbar';\r\nimport PathfindingAlgorithm from './Algorithms/PathfindingAlgorithm';\r\nimport PerlinNoise from './Algorithms/Perlin/PerlinNoise';\r\nimport MazeGenerator from './mazes/MazeGenerator';\r\n\r\ninterface State {\r\n    grid: Node[][];\r\n    startPos: Position;\r\n    finishPos: Position;\r\n    midpointPos: Position;\r\n    mouseState: MouseState;\r\n    isMouseDown: boolean;\r\n    updateLock: boolean;\r\n    perlinToggle: boolean;\r\n    prevAlgorithm: PathfindingAlgorithm;\r\n}\r\n\r\nexport default class Pathfinder extends Component<{}, State> {\r\n    references: Array<Array<RefObject<HTMLDivElement> | any>> = Array(GRID_H)\r\n        .fill([])\r\n        .map(() =>\r\n            Array(GRID_W)\r\n                .fill(0)\r\n                .map(() => createRef()),\r\n        );\r\n    constructor(props: any) {\r\n        super(props);\r\n        let grid: Node[][] = [];\r\n        for (let row = 0; row < GRID_H; row++) {\r\n            let curRow: Array<Node> = [];\r\n            for (let col = 0; col < GRID_W; col++) {\r\n                let newNode: Node = { position: { x: col, y: row }, nodeType: NodeType.Unvisited, weight: 0 };\r\n                curRow.push(newNode);\r\n            }\r\n            grid.push(curRow);\r\n        }\r\n        this.state = {\r\n            grid: grid,\r\n            startPos: DEFAULT_START_POS,\r\n            finishPos: DEFAULT_FINISH_POS,\r\n            midpointPos: null,\r\n            mouseState: MouseState.PlacingWall,\r\n            isMouseDown: false,\r\n            updateLock: false,\r\n            perlinToggle: false,\r\n            prevAlgorithm: null,\r\n        };\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps: Readonly<{}>, nextState: Readonly<State>): boolean {\r\n        return !nextState.updateLock;\r\n    }\r\n\r\n    clearPath(): Node[][] {\r\n        let grid: Node[][] = this.state.grid;\r\n        grid = grid.map((row) => {\r\n            return row.map((node) => {\r\n                return {\r\n                    ...node,\r\n                    nodeType: node.nodeType === NodeType.Wall ? NodeType.Wall : NodeType.Unvisited,\r\n                };\r\n            });\r\n        });\r\n        return grid;\r\n    }\r\n\r\n    updateMouseState(position: Position, eventType: string): void {\r\n        if (this.state.mouseState === MouseState.Disabled) return;\r\n        switch (eventType) {\r\n            case 'mousedown': {\r\n                this.onMouseDown(position);\r\n                break;\r\n            }\r\n            case 'mouseup': {\r\n                this.onMouseUp();\r\n                break;\r\n            }\r\n            case 'mouseenter': {\r\n                this.onMouseEnter(position);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private onMouseDown(position: Position) {\r\n        let { grid, mouseState, isMouseDown, prevAlgorithm } = this.state;\r\n        let nodeType: NodeType = grid[position.y][position.x].nodeType;\r\n        if (\r\n            (mouseState === MouseState.MovingStart ||\r\n                mouseState === MouseState.MovingFinish ||\r\n                mouseState === MouseState.MovingMidpoint) &&\r\n            !this.isEmpty(position)\r\n        )\r\n            return;\r\n\r\n        if (this.isStart(position)) {\r\n            mouseState = MouseState.MovingStart;\r\n        } else if (this.isFinish(position)) {\r\n            mouseState = MouseState.MovingFinish;\r\n        } else if (this.isMidpoint(position)) {\r\n            mouseState = MouseState.MovingMidpoint;\r\n        } else if (nodeType === NodeType.Unvisited) {\r\n            mouseState = MouseState.PlacingWall;\r\n        } else {\r\n            mouseState = MouseState.RemovingWall;\r\n        }\r\n\r\n        if (this.isEmpty(position)) {\r\n            if (prevAlgorithm !== null) {\r\n                grid = this.clearPath();\r\n                prevAlgorithm = null;\r\n            }\r\n            if (nodeType === NodeType.Wall) {\r\n                grid[position.y][position.x].nodeType = NodeType.Unvisited;\r\n            } else {\r\n                grid[position.y][position.x].nodeType = NodeType.Wall;\r\n            }\r\n        }\r\n        isMouseDown = true;\r\n        this.setState({ grid: grid, mouseState: mouseState, isMouseDown: isMouseDown, prevAlgorithm: prevAlgorithm });\r\n    }\r\n\r\n    private onMouseUp() {\r\n        let mouseState = MouseState.PlacingWall;\r\n        let isMouseDown = false;\r\n        this.setState({ mouseState: mouseState, isMouseDown: isMouseDown });\r\n    }\r\n\r\n    private onMouseEnter(position: Position) {\r\n        let { grid, startPos, finishPos, midpointPos, mouseState, isMouseDown, prevAlgorithm } = this.state;\r\n        if (!isMouseDown || this.isStart(position) || this.isFinish(position) || this.isMidpoint(position)) return;\r\n\r\n        switch (mouseState) {\r\n            case MouseState.MovingStart:\r\n                startPos = position;\r\n                if (prevAlgorithm !== null) {\r\n                    this.recalculatePath(startPos, finishPos, midpointPos, prevAlgorithm);\r\n                } else {\r\n                    this.setState({ startPos: startPos });\r\n                }\r\n                break;\r\n            case MouseState.MovingFinish:\r\n                finishPos = position;\r\n                if (prevAlgorithm !== null) {\r\n                    this.recalculatePath(startPos, finishPos, midpointPos, prevAlgorithm);\r\n                } else {\r\n                    this.setState({ finishPos: finishPos });\r\n                }\r\n                break;\r\n            case MouseState.MovingMidpoint:\r\n                midpointPos = position;\r\n                if (prevAlgorithm !== null) {\r\n                    this.recalculatePath(startPos, finishPos, midpointPos, prevAlgorithm);\r\n                } else {\r\n                    this.setState({ midpointPos: midpointPos });\r\n                }\r\n                break;\r\n            case MouseState.PlacingWall:\r\n                grid[position.y][position.x].nodeType = NodeType.Wall;\r\n                this.setState({ grid: grid });\r\n                break;\r\n            case MouseState.RemovingWall:\r\n                grid[position.y][position.x].nodeType = NodeType.Unvisited;\r\n                this.setState({ grid: grid });\r\n                break;\r\n        }\r\n    }\r\n\r\n    private recalculatePath(\r\n        startPos: Position,\r\n        finishPos: Position,\r\n        midpointPos: Position,\r\n        prevAlgorithm: PathfindingAlgorithm,\r\n    ) {\r\n        let grid: Node[][] = this.clearPath();\r\n        let visitedPaths: Position[][] = [];\r\n        let finalPaths: Position[][] = [];\r\n        if (midpointPos === null) {\r\n            prevAlgorithm.calculatePath(grid, startPos, finishPos);\r\n            visitedPaths.push(prevAlgorithm.produceVisitedInOrder());\r\n            finalPaths.push(prevAlgorithm.produceFinalPath());\r\n        } else {\r\n            prevAlgorithm.calculatePath(grid, startPos, midpointPos);\r\n            visitedPaths.push(prevAlgorithm.produceVisitedInOrder());\r\n            finalPaths.push(prevAlgorithm.produceFinalPath());\r\n\r\n            prevAlgorithm.calculatePath(grid, midpointPos, finishPos);\r\n            visitedPaths.push(prevAlgorithm.produceVisitedInOrder());\r\n            finalPaths.push(prevAlgorithm.produceFinalPath());\r\n        }\r\n\r\n        for (let idx = 0; idx < visitedPaths.length; idx++) {\r\n            let visited: Position[] = visitedPaths[idx];\r\n            for (let pos of visited) {\r\n                if (idx === 0) {\r\n                    grid[pos.y][pos.x].nodeType = NodeType.VisitedOne;\r\n                } else if (grid[pos.y][pos.x].nodeType === NodeType.VisitedOne) {\r\n                    grid[pos.y][pos.x].nodeType = NodeType.VisitedOverlap;\r\n                } else {\r\n                    grid[pos.y][pos.x].nodeType = NodeType.VisitedTwo;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let path of finalPaths) {\r\n            for (let pos of path) {\r\n                grid[pos.y][pos.x].nodeType = NodeType.ShortestPath;\r\n            }\r\n        }\r\n\r\n        this.setState({ grid: grid, startPos: startPos, finishPos: finishPos, midpointPos: midpointPos });\r\n    }\r\n\r\n    private isEmpty(position: Position) {\r\n        return !this.isStart(position) && !this.isFinish(position) && !this.isMidpoint(position);\r\n    }\r\n\r\n    private isStart(position: Position) {\r\n        return position.x === this.state.startPos.x && position.y === this.state.startPos.y;\r\n    }\r\n\r\n    private isFinish(position: Position) {\r\n        return position.x === this.state.finishPos.x && position.y === this.state.finishPos.y;\r\n    }\r\n\r\n    private isMidpoint(position: Position) {\r\n        return (\r\n            this.state.midpointPos !== null &&\r\n            position.x === this.state.midpointPos.x &&\r\n            position.y === this.state.midpointPos.y\r\n        );\r\n    }\r\n\r\n    private performAlgorithm(algorithm: PathfindingAlgorithm): void {\r\n        let midpointPos = this.state.midpointPos;\r\n        this.setState({ prevAlgorithm: algorithm, mouseState: MouseState.Disabled });\r\n        let visitedPaths: Position[][] = [];\r\n        let finalPaths: Position[][] = [];\r\n        if (midpointPos === null) {\r\n            algorithm.calculatePath(this.state.grid, this.state.startPos, this.state.finishPos);\r\n            visitedPaths.push(algorithm.produceVisitedInOrder());\r\n            finalPaths.push(algorithm.produceFinalPath());\r\n        } else {\r\n            algorithm.calculatePath(this.state.grid, this.state.startPos, this.state.midpointPos);\r\n            visitedPaths.push(algorithm.produceVisitedInOrder());\r\n            finalPaths.push(algorithm.produceFinalPath());\r\n\r\n            algorithm.calculatePath(this.state.grid, this.state.midpointPos, this.state.finishPos);\r\n            visitedPaths.push(algorithm.produceVisitedInOrder());\r\n            finalPaths.push(algorithm.produceFinalPath());\r\n        }\r\n\r\n        this.visualiseAlgorithm(visitedPaths, finalPaths);\r\n        this.setState({ mouseState: MouseState.PlacingWall });\r\n    }\r\n\r\n    private visualiseAlgorithm(visitedInOrder: Position[][], shortestPath: Position[][]): void {\r\n        (async () => {\r\n            this.lockRender();\r\n            for (let idx = 0; idx < visitedInOrder.length; idx++) {\r\n                let visited: Position[] = visitedInOrder[idx];\r\n                await this.visualiseVisited(visited, idx);\r\n            }\r\n\r\n            await this.visualisePath([].concat(...shortestPath));\r\n            this.unlockRender();\r\n        })();\r\n    }\r\n\r\n    private visualiseVisited(visitedInOrder: Array<Position>, count: number): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            for (let i = 0; i <= visitedInOrder.length; i++) {\r\n                setTimeout(() => {\r\n                    if (i === visitedInOrder.length) {\r\n                        setTimeout(() => {\r\n                            resolve();\r\n                        }, UPDATE_RATE);\r\n                    } else {\r\n                        let position: Position = visitedInOrder[i];\r\n                        let ref: RefObject<HTMLDivElement> = this.references[position.y][position.x];\r\n                        let className: string = ref.current.className;\r\n                        if (\r\n                            !className.includes('cell-start') &&\r\n                            !className.includes('cell-finish') &&\r\n                            !className.includes('cell-midpoint')\r\n                        ) {\r\n                            if (className.includes('cell-visited-0')) {\r\n                                ref.current.className = `cell cell-visited-overlap`;\r\n                            } else {\r\n                                ref.current.className = `cell cell-visited-${count}`;\r\n                            }\r\n                            let grid: Node[][] = this.state.grid;\r\n                            if (count === 0) {\r\n                                grid[position.y][position.x].nodeType = NodeType.VisitedOne;\r\n                            } else if (grid[position.y][position.x].nodeType === NodeType.VisitedOne) {\r\n                                grid[position.y][position.x].nodeType = NodeType.VisitedOverlap;\r\n                            } else {\r\n                                grid[position.y][position.x].nodeType = NodeType.VisitedTwo;\r\n                            }\r\n                            this.setState({ grid: grid });\r\n                        }\r\n                    }\r\n                }, UPDATE_RATE * i);\r\n            }\r\n        });\r\n    }\r\n\r\n    private visualisePath(shortestPath: Position[]): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            for (let i = 0; i <= shortestPath.length; i++) {\r\n                setTimeout(() => {\r\n                    if (i === shortestPath.length) {\r\n                        setTimeout(() => {\r\n                            resolve();\r\n                        }, UPDATE_RATE);\r\n                    } else {\r\n                        let position: Position = shortestPath[i];\r\n                        let ref: RefObject<HTMLDivElement> = this.references[position.y][position.x];\r\n                        let className: string = ref.current.className;\r\n                        if (\r\n                            !className.includes('cell-start') &&\r\n                            !className.includes('cell-finish') &&\r\n                            !className.includes('cell-midpoint')\r\n                        ) {\r\n                            ref.current.className = 'cell cell-shortestPath';\r\n                            let grid: Node[][] = this.state.grid;\r\n                            grid[position.y][position.x].nodeType = NodeType.ShortestPath;\r\n                            this.setState({ grid: grid });\r\n                        }\r\n                    }\r\n                }, UPDATE_RATE * i);\r\n            }\r\n        });\r\n    }\r\n\r\n    private lockRender() {\r\n        this.setState({ updateLock: true });\r\n    }\r\n\r\n    private unlockRender() {\r\n        this.setState({ updateLock: false });\r\n    }\r\n\r\n    private generateLandscape() {\r\n        const STEEPNESS: number = 0.2;\r\n        const perlin: PerlinNoise = new PerlinNoise();\r\n        const seed: number = Math.floor(Math.random() * 10000);\r\n\r\n        let grid: Node[][] = this.state.grid;\r\n        for (let y: number = 0; y < GRID_H; y++) {\r\n            for (let x: number = 0; x < GRID_W; x++) {\r\n                let newWeight = perlin.noise(x * STEEPNESS + seed, y * STEEPNESS + seed, 0);\r\n                grid[y][x].weight = newWeight;\r\n            }\r\n        }\r\n        this.setState({ grid: grid });\r\n    }\r\n\r\n    private generateMaze(mazeGenerator: MazeGenerator): void {\r\n        (async () => {\r\n            this.lockRender();\r\n            let setupWalls: Position[] = mazeGenerator.getSetup();\r\n            let walls: Position[] = mazeGenerator.generateWalls();\r\n            await this.setupStartingWalls(setupWalls);\r\n            await this.visualizeMaze(walls);\r\n            this.unlockRender();\r\n            this.setState({ mouseState: MouseState.PlacingWall });\r\n        })();\r\n    }\r\n\r\n    private setupStartingWalls(walls: Position[]): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            for (let i = 0; i <= walls.length; i++) {\r\n                if (i === walls.length) {\r\n                    setTimeout(() => {\r\n                        resolve();\r\n                    }, 1000);\r\n                } else {\r\n                    let grid: Node[][] = this.state.grid;\r\n                    let position = walls[i];\r\n                    let ref: RefObject<HTMLDivElement> = this.references[position.y][position.x];\r\n                    let className = ref.current.className;\r\n                    grid[position.y][position.x].nodeType = NodeType.Wall;\r\n                    if (\r\n                        !className.includes('cell-start') &&\r\n                        !className.includes('cell-finish') &&\r\n                        !className.includes('cell-midpoint')\r\n                    ) {\r\n                        ref.current.className = 'cell cell-wall';\r\n                    }\r\n                    this.setState({ grid: grid });\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private visualizeMaze(walls: Position[]): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            for (let i = 0; i <= walls.length; i++) {\r\n                setTimeout(() => {\r\n                    if (i === walls.length) {\r\n                        setTimeout(() => {\r\n                            resolve();\r\n                        }, UPDATE_RATE);\r\n                    } else {\r\n                        let grid: Node[][] = this.state.grid;\r\n                        let position: Position = walls[i];\r\n                        let ref: RefObject<HTMLDivElement> = this.references[position.y][position.x];\r\n                        let className: string = ref.current.className;\r\n                        if (this.wallAlreadyPlaced(position)) {\r\n                            if (!className.includes('cell-start') && !className.includes('cell-finish')) {\r\n                                ref.current.className = 'cell cell-unvisited';\r\n                            }\r\n                            grid[position.y][position.x].nodeType = NodeType.Unvisited;\r\n                        } else {\r\n                            if (\r\n                                !className.includes('cell-start') &&\r\n                                !className.includes('cell-finish') &&\r\n                                !className.includes('cell-midpoint')\r\n                            ) {\r\n                                ref.current.className = 'cell cell-wall';\r\n                            }\r\n                            grid[position.y][position.x].nodeType = NodeType.Wall;\r\n                        }\r\n\r\n                        this.setState({ grid: grid });\r\n                    }\r\n                }, UPDATE_RATE * i);\r\n            }\r\n        });\r\n    }\r\n\r\n    private wallAlreadyPlaced(wall: Position): boolean {\r\n        const grid = this.state.grid;\r\n        return grid[wall.y][wall.x].nodeType === NodeType.Wall;\r\n    }\r\n\r\n    setMidpoint(position: Position): void {\r\n        let prevAlgorithm = this.state.prevAlgorithm;\r\n        let grid = this.state.grid;\r\n        if (!this.isStart(position) && !this.isFinish(position)) {\r\n            let nextMidPoint: Position;\r\n            if (this.isMidpoint(position)) {\r\n                nextMidPoint = null;\r\n            } else {\r\n                nextMidPoint = position;\r\n            }\r\n            //\r\n            if (prevAlgorithm !== null) {\r\n                prevAlgorithm = null;\r\n                grid = this.clearPath();\r\n            }\r\n            //\r\n            this.setState({ grid: grid, prevAlgorithm: prevAlgorithm, midpointPos: nextMidPoint });\r\n        }\r\n    }\r\n\r\n    public render(): any {\r\n        const grid = this.state.grid;\r\n        return (\r\n            <div>\r\n                <Navbar\r\n                    performAlgorithm={(algorithm: PathfindingAlgorithm) => this.performAlgorithm(algorithm)}\r\n                    clearPath={() => this.setState({ prevAlgorithm: null, grid: this.clearPath() })}\r\n                    generateLandscape={() => this.generateLandscape()}\r\n                    generateMaze={(mazeGenerator: MazeGenerator) => this.generateMaze(mazeGenerator)}\r\n                />\r\n                <div className=\"grid\">\r\n                    {grid.map((row: Array<Node>, rowIdx) => {\r\n                        return (\r\n                            <div className=\"grid-row\" key={rowIdx}>\r\n                                {row.map((cell: Node, colIdx) => {\r\n                                    let position: Position = { x: colIdx, y: rowIdx };\r\n                                    return (\r\n                                        <Cell\r\n                                            position={{ x: colIdx, y: rowIdx }}\r\n                                            isStart={this.isStart(position)}\r\n                                            isFinish={this.isFinish(position)}\r\n                                            isMidpoint={this.isMidpoint(position)}\r\n                                            nodeType={cell.nodeType}\r\n                                            weight={cell.weight}\r\n                                            updateMouseState={(position: Position, eventType: string) =>\r\n                                                this.updateMouseState(position, eventType)\r\n                                            }\r\n                                            setMidpoint={(position: Position) => this.setMidpoint(position)}\r\n                                            nodeRef={this.references[rowIdx][colIdx]}\r\n                                            key={colIdx}\r\n                                        />\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import * as React from 'react';\r\nimport Pathfinder from './Pathfinder';\r\nimport { Component } from 'react';\r\n\r\nexport default class App extends Component {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render(): any {\r\n        return (\r\n            <div className=\"app\">\r\n                <Pathfinder />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import * as React from 'react';\r\nimport * as ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}