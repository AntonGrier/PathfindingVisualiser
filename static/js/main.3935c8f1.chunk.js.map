{"version":3,"sources":["models/MouseState.ts","models/Node.ts","models/Grid.ts","Cell.tsx","Algorithms/PathfindingAlgorithm.tsx","Algorithms/DataStructures/PriorityQueue.tsx","Algorithms/Dijkstra.tsx","Algorithms/DataStructures/Stack.tsx","Algorithms/DFS.ts","Algorithms/DataStructures/Queue.ts","Algorithms/BFS.tsx","mazes/MazeGenerator.ts","mazes/RecursiveDivision.ts","mazes/WallCarver.ts","mazes/RecursiveBacktracking.ts","mazes/Ellers.ts","Algorithms/AStar.ts","Navbar.tsx","helpers/gridHelpers.ts","helpers/positionHelpers.ts","Pathfinder.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["MouseState","NodeType","screenWidth","Math","floor","window","innerWidth","screenHeight","innerHeight","GRID_W","GRID_H","DEFAULT_START_POS","x","y","DEFAULT_FINISH_POS","Cell","position","isStart","isFinish","isMidpoint","nodeType","setMidpoint","onMouseDown","onMouseUp","onMouseEnter","nodeRef","ref","id","className","Unvisited","VisitedOne","VisitedTwo","VisitedOverlap","Wall","ShortestPath","getClassName","event","isMouseDown","buttons","which","onContextMenu","stopPropagation","preventDefault","PathfindingAlgorithm","pathValues","Map","finalPath","visitedNodesInOrder","this","slice","length","grid","neighbors","push","filter","neighbor","isVisited","cornerCheck","current","sqrt","pow","abs","get","hash","pathData","newPathData","set","finishPos","curPosition","previousNode","unshift","pos1","pos2","toString","PriorityQueue","heap","val","priority","replace","undefined","tmp","found","i","p","n","find","foundNode","tuple","shift","pop","map","values","Dijkstra","minHeap","startPos","reset","setMap","insert","size","closestPosition","markAsVisited","equalPosition","findShortestPath","getNeighbors","closestDistance","shortestPath","newDistance","getDistance","neighborPathData","forEach","row","node","nodePosition","Infinity","clear","Stack","data","top","element","DFS","stack","isEmpty","reverse","Queue","BFS","queue","MazeGenerator","wallsCreatedInOrder","walls","topBorderWall","botBorderWall","leftBorderWall","rightBorderWall","min","max","random","RecursiveDivision","lr","divide","ul","splitIdx","gap","newLr","newUl","width","height","vertical","randomEven","randomOdd","pos","getRandom","ADJUSTED_WIDTH","ADJUSTED_HEIGHT","WallCarver","positionBetween","addWall","middleWall","crossWall","RecursiveBacktracking","visited","randomStartingPos","carveWalls","visit","getUnvisitedNeighbors","isVisisted","placeWallBetweenPositions","positionInBounds","randomisePositions","positions","sort","has","Ellers","generateMaze","currentRow","Uptree","mergeRow","prevRow","extendToNextRow","rowIdx","isRoot","addEntry","addTopWall","randomBool","getEntry","sameClass","mergeSets","addRightWall","Array","fill","set1","set2","getRoot","index1","index2","index","value","AStar","setNeighbors","start","finish","costSoFar","distanceFromStart","distanceFromFinish","totalCost","prevPathData","Navbar","props","state","onClick","performAlgorithm","clearPath","clearWall","Component","cloneGrid","clearWalls","positionsEqual","midpointPos","references","createRef","Pathfinder","useState","curRow","col","newNode","getDefaultGrid","setGrid","setStartPos","setFinishPos","setMidpointPos","PlacingWall","mouseState","setMouseState","prevAlgorithm","setPrevAlgorithm","animating","setAnimating","recalculatePath","newGrid","visitedPaths","finalPaths","calculatePath","produceVisitedInOrder","produceFinalPath","idx","path","MovingStart","MovingFinish","MovingMidpoint","RemovingWall","clearedGrid","clonedGrid","visualiseAlgorithm","visitedInOrder","a","visualiseVisited","visualisePath","flat","count","Promise","resolve","setTimeout","includes","mazeGenerator","refRow","setupWalls","getSetup","generateWalls","setupStartingWalls","visualizeMaze","cells","key","colIdx","algorithm","Disabled","App","Boolean","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.3935c8f1.chunk.js","sourcesContent":["export enum MouseState {\r\n  PlacingWall = 'PLACING_WALL',\r\n  RemovingWall = 'REMOVING_WALL',\r\n  MovingStart = 'MOVING_START',\r\n  MovingFinish = 'MOVING_FINISH',\r\n  MovingMidpoint = 'MOVING_MIDPOINT',\r\n  Disabled = 'DISABLED'\r\n}\r\n","import { Position } from './Position'\r\n\r\nexport enum NodeType {\r\n  Unvisited = 'UNVISITED',\r\n  VisitedOne = 'VISITED_ONE',\r\n  VisitedTwo = 'VISITED_TWO',\r\n  VisitedOverlap = 'VISITED_OVERLAP',\r\n  Wall = 'WALL',\r\n  ShortestPath = 'SHORTEST_PATH'\r\n}\r\n\r\nexport interface Node {\r\n  position: Position\r\n  nodeType: NodeType\r\n}\r\n","import { Position } from './Position'\r\n\r\nconst screenWidth = Math.floor((0.9 * window.innerWidth) / 25)\r\nconst screenHeight = Math.floor((0.8 * window.innerHeight) / 25)\r\nexport const GRID_W = screenWidth % 2 === 0 ? screenWidth - 1 : screenWidth\r\nexport const GRID_H = screenHeight % 2 === 0 ? screenHeight - 1 : screenHeight\r\nexport const DEFAULT_START_POS: Position = { x: Math.floor(GRID_W / 4), y: Math.floor(GRID_H / 2) }\r\nexport const DEFAULT_FINISH_POS: Position = { x: GRID_W - DEFAULT_START_POS.x - 1, y: DEFAULT_START_POS.y }\r\nexport const UPDATE_RATE = 15\r\n","import * as React from 'react'\r\nimport { FunctionComponent, RefObject } from 'react'\r\nimport { NodeType, Position } from './models'\r\n\r\ninterface CellProps {\r\n  position: Position\r\n  isStart: boolean\r\n  isFinish: boolean\r\n  isMidpoint: boolean\r\n  nodeType: NodeType\r\n  setMidpoint: (position: Position) => void\r\n  onMouseDown: (position: Position) => void\r\n  onMouseUp: () => void\r\n  onMouseEnter: (position: Position, isMouseDown: boolean) => void\r\n  nodeRef: (ref: RefObject<HTMLDivElement> | any) => void\r\n}\r\n\r\nexport const Cell: FunctionComponent<CellProps> = ({\r\n  position,\r\n  isStart,\r\n  isFinish,\r\n  isMidpoint,\r\n  nodeType,\r\n  setMidpoint,\r\n  onMouseDown,\r\n  onMouseUp,\r\n  onMouseEnter,\r\n  nodeRef\r\n}) => {\r\n  const getClassName = () => {\r\n    if (isStart || isFinish || isMidpoint) {\r\n      return isStart ? 'cell-start' : isFinish ? 'cell-finish' : isMidpoint ? 'cell-midpoint' : ''\r\n    } else {\r\n      switch (nodeType) {\r\n        case NodeType.Unvisited:\r\n          return 'cell-unvisited'\r\n        case NodeType.VisitedOne:\r\n          return 'cell-visited-0'\r\n        case NodeType.VisitedTwo:\r\n          return 'cell-visited-1'\r\n        case NodeType.VisitedOverlap:\r\n          return 'cell-visited-overlap'\r\n        case NodeType.Wall:\r\n          return 'cell-wall'\r\n        case NodeType.ShortestPath:\r\n          return 'cell-shortestPath'\r\n      }\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div\r\n      ref={nodeRef}\r\n      id={`cell-${position.x}-${position.y}`}\r\n      className={`cell ${getClassName()}`}\r\n      onMouseUp={onMouseUp}\r\n      onMouseDown={() => onMouseDown(position)}\r\n      onMouseEnter={event => {\r\n        const isMouseDown = (event.buttons ?? (event as any).which) === 1\r\n        onMouseEnter(position, isMouseDown)\r\n      }}\r\n      onContextMenu={event => {\r\n        event.stopPropagation()\r\n        event.preventDefault()\r\n        setMidpoint(position)\r\n      }}\r\n    />\r\n  )\r\n}\r\n","import { GRID_H, GRID_W, Node, NodeType, Position } from '../models'\n\nexport interface PathData {\n  isVisited: boolean\n  shortestPath?: number\n  previousNode?: Position\n}\n\nexport default abstract class PathfindingAlgorithm {\n  pathValues: Map<string, PathData> = new Map<string, PathData>()\n  finalPath: Position[] = []\n  visitedNodesInOrder: Position[] = []\n\n  protected abstract setMap(grid: Node[][], startPos?: Position): void\n\n  public abstract calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void\n\n  public produceVisitedInOrder(): Position[] {\n    return this.visitedNodesInOrder.slice(1, this.visitedNodesInOrder.length - 1)\n  }\n\n  public produceFinalPath(): Position[] {\n    return this.finalPath.slice(1, this.visitedNodesInOrder.length - 1)\n  }\n\n  protected getNeighbors(grid: Node[][], position: Position): Position[] {\n    let neighbors: Position[] = []\n    neighbors.push({ x: position.x + 1, y: position.y })\n    neighbors.push({ x: position.x, y: position.y + 1 })\n    neighbors.push({ x: position.x, y: position.y - 1 })\n    neighbors.push({ x: position.x - 1, y: position.y })\n\n    neighbors.push({ x: position.x - 1, y: position.y + 1 })\n    neighbors.push({ x: position.x + 1, y: position.y + 1 })\n    neighbors.push({ x: position.x + 1, y: position.y - 1 })\n    neighbors.push({ x: position.x - 1, y: position.y - 1 })\n\n    return neighbors.filter(neighbor => {\n      return (\n        neighbor.x >= 0 &&\n        neighbor.x < GRID_W &&\n        neighbor.y >= 0 &&\n        neighbor.y < GRID_H &&\n        grid[neighbor.y][neighbor.x].nodeType !== NodeType.Wall &&\n        !this.isVisited(neighbor) &&\n        this.cornerCheck(position, neighbor, grid)\n      )\n    })\n  }\n\n  private cornerCheck(position: Position, neighbor: Position, grid: Node[][]): boolean {\n    return (\n      grid[position.y][neighbor.x].nodeType !== NodeType.Wall || grid[neighbor.y][position.x].nodeType !== NodeType.Wall\n    )\n  }\n\n  protected getDistance(grid: Node[][], current: Position, neighbor: Position): number {\n    return Math.sqrt(Math.pow(Math.abs(current.x - neighbor.x), 2) + Math.pow(Math.abs(current.y - neighbor.y), 2))\n  }\n\n  protected isVisited(position: Position): boolean {\n    return this.pathValues.get(this.hash(position)).isVisited\n  }\n\n  protected markAsVisited(position: Position): void {\n    this.visitedNodesInOrder.push(position)\n    let pathData: PathData = this.pathValues.get(this.hash(position))\n    let newPathData: PathData = {\n      ...pathData,\n      isVisited: true\n    }\n    this.pathValues.set(this.hash(position), newPathData)\n  }\n\n  protected findShortestPath(finishPos: Position): void {\n    for (\n      let curPosition = finishPos;\n      curPosition != null;\n      curPosition = this.pathValues.get(this.hash(curPosition)).previousNode\n    ) {\n      this.finalPath.unshift(curPosition)\n    }\n  }\n\n  protected equalPosition(pos1: Position, pos2: Position) {\n    return pos1.x === pos2.x && pos1.y === pos2.y\n  }\n\n  protected hash(position: Position): string {\n    return position.x.toString() + '-' + position.y.toString()\n  }\n\n  protected clear(): void {\n    this.visitedNodesInOrder = []\n    this.finalPath = []\n    this.pathValues = new Map<string, PathData>()\n  }\n\n  protected abstract reset(): void\n}\n","export interface Node {\n    x: number;\n    y: number;\n}\n\nexport type Tuple<T> = [T, number];\n\nexport class PriorityQueue<T extends Node> {\n    heap: Tuple<T>[] = [];\n\n    insert(val: T, priority: number, replace?: boolean) {\n        replace = replace !== undefined;\n\n        if (!this.heap.length || this.heap[this.heap.length - 1][1] > priority) {\n            this.heap.push([val, priority]);\n            return this.heap;\n        }\n\n        const tmp: Tuple<T>[] = [];\n        let found = false;\n\n        for (let i = 0; i < this.heap.length; i++) {\n            const p = this.heap[i][1];\n            const n = this.heap[i][0];\n\n            if (priority >= p && !found) {\n                tmp.push([val, priority]);\n                found = true;\n            }\n\n            if (!(replace && n.x === val.x && n.y === val.y)) {\n                tmp.push(this.heap[i]);\n            }\n        }\n        return (this.heap = tmp);\n    }\n\n    has({ x, y }: T) {\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\n\n        return !!foundNode;\n    }\n\n    get({ x, y }: T) {\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\n\n        return foundNode && foundNode[1];\n    }\n\n    shift(priority: boolean) {\n        const tuple = this.heap.shift();\n        if (priority) {\n            return tuple;\n        }\n\n        return tuple ? tuple[0] : undefined;\n    }\n\n    pop() {\n        return this.heap.pop()[0];\n    }\n\n    priorities() {\n        return this.heap.map(([_, p]) => p);\n    }\n\n    values() {\n        return this.heap.map(([val]) => val);\n    }\n\n    size() {\n        return this.heap.length;\n    }\n\n    toArray(values: boolean) {\n        if (values) {\n            return this.heap.map(([val]) => val);\n        }\n        return this.heap;\n    }\n}\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm'\nimport { Node, Position } from '../models'\nimport { PriorityQueue } from './DataStructures/PriorityQueue'\n\nexport default class Dijkstra extends PathfindingAlgorithm {\n  minHeap: PriorityQueue<Position> = new PriorityQueue<Position>()\n  calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void {\n    this.reset()\n    this.setMap(grid, startPos)\n    this.minHeap.insert(startPos, 0)\n    while (this.minHeap.size() !== 0) {\n      let closestPosition: Position = this.minHeap.pop()\n      this.markAsVisited(closestPosition)\n      if (this.equalPosition(closestPosition, finishPos)) {\n        this.findShortestPath(finishPos)\n        return\n      }\n      let neighbors: Position[] = this.getNeighbors(grid, closestPosition)\n      let closestDistance: number = this.pathValues.get(this.hash(closestPosition)).shortestPath\n      for (let neighbor of neighbors) {\n        let newDistance: number = closestDistance + this.getDistance(grid, closestPosition, neighbor)\n        let neighborPathData: PathData = this.pathValues.get(this.hash(neighbor))\n        this.minHeap.insert(neighbor, newDistance)\n        if (newDistance < neighborPathData.shortestPath) {\n          let pathData: PathData = {\n            shortestPath: newDistance,\n            isVisited: true,\n            previousNode: closestPosition\n          }\n          this.pathValues.set(this.hash(neighbor), pathData)\n        }\n      }\n    }\n  }\n\n  protected setMap(grid: Node[][], startPos: Position): void {\n    grid.forEach(row => {\n      return row.forEach(node => {\n        let nodePosition: Position = node.position\n        let shortestPath: number\n        if (this.equalPosition(startPos, nodePosition)) {\n          shortestPath = 0\n        } else {\n          shortestPath = Infinity\n        }\n        let pathData: PathData = { shortestPath: shortestPath, isVisited: false, previousNode: null }\n        this.pathValues.set(this.hash(nodePosition), pathData)\n      })\n    })\n  }\n\n  protected reset(): void {\n    this.clear()\n    this.minHeap = new PriorityQueue<Position>()\n  }\n}\n","export default class Stack<T> {\n  data: T[]\n  top: number\n  constructor() {\n    this.data = []\n    this.top = 0\n  }\n  public push(element: T): void {\n    this.data[this.top] = element\n    this.top++\n  }\n  public pop(): T {\n    this.top--\n    return this.data[this.top]\n  }\n  public isEmpty(): boolean {\n    return this.top === 0\n  }\n}\n","import PathfindingAlgorithm from './PathfindingAlgorithm'\nimport Stack from './DataStructures/Stack'\nimport { Position, Node } from '../models'\n\nexport default class DFS extends PathfindingAlgorithm {\n  stack: Stack<Position> = new Stack<Position>()\n  calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void {\n    this.reset()\n    this.setMap(grid)\n    this.stack.push(startPos)\n    while (!this.stack.isEmpty()) {\n      let curPosition: Position = this.stack.pop()\n      this.markAsVisited(curPosition)\n      if (this.equalPosition(curPosition, finishPos)) {\n        this.finalPath = this.visitedNodesInOrder\n        return\n      }\n      let neighbors: Position[] = this.getNeighbors(grid, curPosition).reverse()\n      for (let neighbor of neighbors) {\n        this.stack.push(neighbor)\n      }\n    }\n  }\n\n  protected setMap(grid: Node[][]): void {\n    grid.forEach(row => {\n      row.forEach(node => {\n        let nodePosition: Position = node.position\n        this.pathValues.set(this.hash(nodePosition), { isVisited: false })\n      })\n    })\n  }\n\n  protected reset(): void {\n    this.clear()\n    this.stack = new Stack<Position>()\n  }\n}\n","export default class Queue<T> {\n  data: T[] = []\n  push(element: T) {\n    this.data.push(element)\n  }\n  pop(): T {\n    return this.data.shift()\n  }\n  isEmpty(): boolean {\n    return this.data.length === 0\n  }\n}\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm'\nimport Queue from './DataStructures/Queue'\nimport { Node, Position } from '../models'\n\nexport default class BFS extends PathfindingAlgorithm {\n  queue: Queue<Position> = new Queue<Position>()\n\n  calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void {\n    this.reset()\n    this.setMap(grid)\n    this.queue.push(startPos)\n    while (!this.queue.isEmpty()) {\n      let curPosition: Position = this.queue.pop()\n      this.markAsVisited(curPosition)\n      if (this.equalPosition(curPosition, finishPos)) {\n        this.findShortestPath(finishPos)\n        return\n      }\n      let neighbors: Position[] = this.getNeighbors(grid, curPosition)\n      for (let neighbor of neighbors) {\n        this.queue.push(neighbor)\n        this.pathValues.set(this.hash(neighbor), { isVisited: true, previousNode: curPosition })\n      }\n    }\n  }\n\n  protected setMap(grid: Node[][]): void {\n    grid.forEach(row => {\n      row.forEach(node => {\n        let nodePosition: Position = node.position\n        let pathData: PathData = {\n          isVisited: false,\n          previousNode: null\n        }\n        this.pathValues.set(this.hash(nodePosition), pathData)\n      })\n    })\n  }\n\n  protected reset(): void {\n    this.clear()\n    this.queue = new Queue<Position>()\n  }\n}\n","import { Position, GRID_H, GRID_W } from './../models'\nexport default abstract class MazeGenerator {\n  wallsCreatedInOrder: Position[]\n  public abstract generateWalls(): Position[]\n  public getSetup(): Position[] {\n    let walls: Position[] = []\n    for (let i = 0; i < GRID_W; i++) {\n      let topBorderWall: Position = { x: i, y: 0 }\n      let botBorderWall: Position = { x: i, y: GRID_H - 1 }\n      walls.push(topBorderWall)\n      walls.push(botBorderWall)\n    }\n    for (let i = 1; i < GRID_H - 1; i++) {\n      let leftBorderWall: Position = { x: 0, y: i }\n      let rightBorderWall: Position = { x: GRID_W - 1, y: i }\n      walls.push(leftBorderWall)\n      walls.push(rightBorderWall)\n    }\n    return walls\n  }\n  protected getRandom(min: number, max: number): number {\n    return min + Math.floor((max - min + 1) * Math.random())\n  }\n  protected addWall(position: Position) {\n    this.wallsCreatedInOrder.push(position)\n  }\n}\n","import MazeGenerator from './MazeGenerator'\nimport { Position, GRID_W, GRID_H } from '../models'\n\nexport default class RecursiveDivision extends MazeGenerator {\n  public generateWalls(): Position[] {\n    this.wallsCreatedInOrder = []\n    const ul: Position = { x: 0, y: 0 }\n    const lr: Position = { x: GRID_W - 1, y: GRID_H - 1 }\n    this.divide(ul, lr)\n    return this.wallsCreatedInOrder\n  }\n\n  private divide(ul: Position, lr: Position) {\n    let width: number = lr.x - ul.x + 1\n    let height: number = lr.y - ul.y + 1\n    let vertical: boolean = width > height\n    let splitIdx: number\n    let gap: Position\n    if (vertical) {\n      if (width < 4) return\n      splitIdx = this.randomEven(ul.x, lr.x)\n      gap = { x: splitIdx, y: this.randomOdd(ul.y, lr.y) }\n    } else {\n      if (height < 4) return\n      splitIdx = this.randomEven(ul.y, lr.y)\n      gap = { x: this.randomOdd(ul.x, lr.x), y: splitIdx }\n    }\n\n    for (let i = vertical ? ul.y + 1 : ul.x + 1; i <= (vertical ? lr.y - 1 : lr.x - 1); i++) {\n      if (i === (vertical ? gap.y : gap.x)) continue\n      let pos: Position\n      if (vertical) {\n        pos = { x: splitIdx, y: i }\n      } else {\n        pos = { x: i, y: splitIdx }\n      }\n      this.wallsCreatedInOrder.push(pos)\n    }\n\n    let newLr: Position\n    let newUl: Position\n    if (vertical) {\n      newLr = { x: splitIdx, y: lr.y }\n      newUl = { x: splitIdx, y: ul.y }\n    } else {\n      newLr = { x: lr.x, y: splitIdx }\n      newUl = { x: ul.x, y: splitIdx }\n    }\n\n    this.divide(ul, newLr)\n    this.divide(newUl, lr)\n  }\n\n  /**\n   *\n   * @param min\n   * @param max\n   *\n   * produce a random even number in a range to match a valid wall coordinate that is not next to a current wall\n   */\n  private randomEven(min: number, max: number): number {\n    min += 2\n    max -= 2\n    if (min % 2 === 1) {\n      min++\n    }\n    if (max % 2 === 1) {\n      max--\n    }\n    let wall = min + 2 * this.getRandom(0, (max - min) / 2)\n    return wall\n  }\n\n  /**\n   *\n   * @param min\n   * @param max\n   *\n   * produce a random odd number in a range to match a valid gap coordinate\n   */\n  private randomOdd(min: number, max: number): number {\n    min += 2\n    max -= 2\n    if (min % 2 === 0) {\n      min++\n    }\n    if (max % 2 === 0) {\n      max--\n    }\n    let gap = min + 2 * this.getRandom(0, (max - min) / 2)\n    return gap\n  }\n\n  private hash(position: Position): string {\n    return position.x.toString() + '-' + position.y.toString()\n  }\n}\n","import MazeGenerator from './MazeGenerator'\nimport { Position, GRID_W, GRID_H } from '../models'\n\nexport const ADJUSTED_WIDTH = (GRID_W - 1) / 2\nexport const ADJUSTED_HEIGHT = (GRID_H - 1) / 2\n\nexport default abstract class WallCarver extends MazeGenerator {\n  protected placeWallBetweenPositions(current: Position, neighbor: Position): void {\n    let positionBetween: Position = {\n      x: Math.floor((current.x + neighbor.x) / 2),\n      y: Math.floor((current.y + neighbor.y) / 2)\n    }\n    this.addWall(positionBetween)\n  }\n\n  protected positionInBounds(position: Position): boolean {\n    return position.x > 0 && position.x < GRID_W - 1 && position.y > 0 && position.y < GRID_H - 1\n  }\n\n  public getSetup(): Position[] {\n    let walls: Position[] = []\n    for (let i = 0; i < GRID_W; i++) {\n      let topBorderWall: Position = { x: i, y: 0 }\n      let botBorderWall: Position = { x: i, y: GRID_H - 1 }\n      walls.push(topBorderWall)\n      walls.push(botBorderWall)\n    }\n    for (let x = 0; x < GRID_W; x += 2) {\n      for (let y = 1; y < GRID_H - 1; y++) {\n        let middleWall: Position = { x: x, y: y }\n        walls.push(middleWall)\n      }\n    }\n    for (let x = 1; x < GRID_W - 1; x += 2) {\n      for (let y = 2; y < GRID_H - 2; y += 2) {\n        let crossWall: Position = { x: x, y: y }\n        walls.push(crossWall)\n      }\n    }\n    return walls\n  }\n}\n","import { Position, GRID_W, GRID_H } from '../models'\nimport WallCarver from './WallCarver'\n\nexport default class RecursiveBacktracking extends WallCarver {\n  visited: Map<String, boolean>\n  public generateWalls(): Position[] {\n    this.wallsCreatedInOrder = []\n    this.visited = new Map<string, boolean>()\n    let randomStartingPos: Position = {\n      x: 2 * this.getRandom(1, (GRID_W - 1) / 2) - 1,\n      y: 2 * this.getRandom(1, (GRID_H - 1) / 2) - 1\n    }\n    this.carveWalls(randomStartingPos)\n    return this.wallsCreatedInOrder\n  }\n\n  carveWalls(current: Position): void {\n    this.visit(current)\n    let neighbors: Position[] = this.getUnvisitedNeighbors(current)\n    for (let neighbor of neighbors) {\n      if (!this.isVisisted(neighbor)) {\n        this.placeWallBetweenPositions(current, neighbor)\n        this.carveWalls(neighbor)\n      }\n    }\n  }\n\n  private getUnvisitedNeighbors(current: Position): Position[] {\n    let right: Position = { x: current.x + 2, y: current.y }\n    let up: Position = { x: current.x, y: current.y - 2 }\n    let left: Position = { x: current.x - 2, y: current.y }\n    let bot: Position = { x: current.x, y: current.y + 2 }\n    let neighbors: Position[] = [right, up, left, bot]\n    neighbors = neighbors.filter((pos: Position) => {\n      return this.positionInBounds(pos)\n    })\n    return this.randomisePositions(neighbors)\n  }\n\n  private randomisePositions(positions: Position[]): Position[] {\n    return positions.sort(() => Math.random() - 0.5)\n  }\n\n  private visit(position: Position): void {\n    this.visited.set(this.hash(position), true)\n  }\n\n  private isVisisted(position: Position): boolean {\n    return this.visited.has(this.hash(position))\n  }\n\n  private hash(position: Position): string {\n    return position.x.toString() + '-' + position.y.toString()\n  }\n}\n","import { Position } from '../models'\nimport WallCarver, { ADJUSTED_WIDTH, ADJUSTED_HEIGHT } from './WallCarver'\n\nexport default class Ellers extends WallCarver {\n  public generateWalls(): Position[] {\n    this.wallsCreatedInOrder = []\n    this.generateMaze()\n    return this.wallsCreatedInOrder\n  }\n\n  private generateMaze(): void {\n    let currentRow: Uptree = new Uptree()\n    currentRow = this.mergeRow(currentRow, 0, true)\n    for (let y = 1; y < ADJUSTED_HEIGHT; y++) {\n      let prevRow = currentRow\n      currentRow = this.extendToNextRow(currentRow, prevRow, y)\n      currentRow = this.mergeRow(currentRow, y, y !== ADJUSTED_HEIGHT - 1)\n    }\n  }\n  extendToNextRow(currentRow: Uptree, prevRow: Uptree, rowIdx: number) {\n    currentRow = new Uptree()\n    for (let x = 0; x < ADJUSTED_WIDTH; x++) {\n      if (prevRow.isRoot(x)) {\n        currentRow.addEntry(x, -1)\n        this.addTopWall({ x: x, y: rowIdx })\n      } else if (this.randomBool()) {\n        currentRow.addEntry(x, prevRow.getEntry(x))\n        this.addTopWall({ x: x, y: rowIdx })\n      }\n    }\n    return currentRow\n  }\n\n  private mergeRow(row: Uptree, rowIdx: number, random: boolean) {\n    for (let i = 0; i < ADJUSTED_WIDTH - 1; i++) {\n      if ((this.randomBool() || !random) && !row.sameClass(i, i + 1)) {\n        row.mergeSets(i, i + 1)\n        this.addRightWall({ x: i, y: rowIdx })\n      }\n    }\n    return row\n  }\n  addRightWall(pos: Position): void {\n    this.addWall({ x: 2 * pos.x + 2, y: 2 * pos.y + 1 })\n  }\n\n  addTopWall(pos: Position): void {\n    this.addWall({ x: 2 * pos.x + 1, y: 2 * pos.y })\n  }\n\n  private randomBool(): boolean {\n    return Math.random() >= 0.5\n  }\n}\n\nclass Uptree {\n  data: number[]\n  constructor() {\n    this.data = Array(ADJUSTED_WIDTH).fill(-1)\n  }\n\n  public mergeSets(set1: number, set2: number): void {\n    if (this.data[set1] === -1) {\n      this.data[set1] = this.getRoot(set2)\n    } else {\n      this.data[set2] = this.getRoot(set1)\n    }\n  }\n\n  public sameClass(index1: number, index2: number) {\n    return this.getRoot(index1) === this.getRoot(index2)\n  }\n\n  public getRoot(index: number): number {\n    while (this.data[index] !== -1) {\n      index = this.data[index]\n    }\n    return index\n  }\n\n  public isRoot(index: number): boolean {\n    return this.data[index] === -1\n  }\n\n  public addEntry(index: number, value: number) {\n    this.data[index] = value\n  }\n\n  public getEntry(index: number): number {\n    return this.getRoot(index)\n  }\n}\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm'\nimport { Node, Position } from '../models'\nimport { PriorityQueue } from './DataStructures/PriorityQueue'\n\nexport default class AStar extends PathfindingAlgorithm {\n  minHeap: PriorityQueue<Position> = new PriorityQueue<Position>()\n\n  public calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void {\n    this.reset()\n    this.setMap(grid, startPos)\n    this.minHeap.insert(startPos, 0)\n    while (this.minHeap.size() > 0) {\n      let closestPosition: Position = this.minHeap.pop()\n      if (this.pathValues.get(this.hash(closestPosition)).isVisited) {\n        continue\n      }\n      this.markAsVisited(closestPosition)\n      if (this.equalPosition(closestPosition, finishPos)) {\n        this.findShortestPath(finishPos)\n        return\n      }\n      this.setNeighbors(grid, closestPosition, startPos, finishPos)\n    }\n  }\n\n  private setNeighbors(grid: Node[][], current: Position, start: Position, finish: Position): void {\n    let neighbors = this.getNeighbors(grid, current)\n    let costSoFar: number = this.pathValues.get(this.hash(current)).shortestPath\n    for (let neighbor of neighbors) {\n      // let pathData: PathData = this.pathValues.get(this.hash(neighbor));\n      let distanceFromStart: number = costSoFar + this.getDistance(grid, neighbor, current)\n      let distanceFromFinish: number = this.getDistance(grid, neighbor, finish)\n      let totalCost: number = distanceFromStart + distanceFromFinish\n      let prevPathData: PathData = this.pathValues.get(this.hash(neighbor))\n      if (prevPathData.previousNode !== null) {\n        let prevCost: number = prevPathData.shortestPath + distanceFromFinish\n        if (totalCost < prevCost) {\n          this.minHeap.insert(neighbor, totalCost, true)\n          this.pathValues.set(this.hash(neighbor), {\n            isVisited: false,\n            previousNode: current,\n            shortestPath: distanceFromStart\n          })\n        }\n      } else {\n        this.minHeap.insert(neighbor, totalCost, false)\n        this.pathValues.set(this.hash(neighbor), {\n          isVisited: false,\n          previousNode: current,\n          shortestPath: distanceFromStart\n        })\n      }\n    }\n  }\n\n  protected setMap(grid: Node[][], startPos: Position): void {\n    grid.forEach((row: Node[]) => {\n      return row.forEach((node: Node) => {\n        let nodePosition: Position = node.position\n        let shortestPath: number\n        if (this.equalPosition(startPos, nodePosition)) {\n          shortestPath = 0\n        } else {\n          shortestPath = Infinity\n        }\n        let pathData: PathData = { isVisited: false, shortestPath: shortestPath, previousNode: null }\n        this.pathValues.set(this.hash(nodePosition), pathData)\n      })\n    })\n  }\n  protected reset(): void {\n    this.clear()\n    this.minHeap = new PriorityQueue<Position>()\n  }\n}\n","import { Component } from 'react'\nimport * as React from 'react'\nimport PathfindingAlgorithm from './Algorithms/PathfindingAlgorithm'\nimport Dijkstra from './Algorithms/Dijkstra'\nimport DFS from './Algorithms/DFS'\nimport BFS from './Algorithms/BFS'\nimport MazeGenerator from './mazes/MazeGenerator'\nimport RecursiveDivision from './mazes/RecursiveDivision'\nimport RecursiveBacktracking from './mazes/RecursiveBacktracking'\nimport Ellers from './mazes/Ellers'\nimport AStar from './Algorithms/AStar'\n\ninterface Props {\n  performAlgorithm: (algorithm: PathfindingAlgorithm) => void\n  clearPath: () => void\n  clearWall: () => void\n  generateMaze: (mazeGenerator: MazeGenerator) => void\n}\n\nexport default class Navbar extends Component<Props> {\n  constructor(props: any) {\n    super(props)\n    this.state = {}\n  }\n\n  render(): any {\n    return (\n      <ul>\n        <li>\n          <a\n            onClick={() => {\n              this.props.generateMaze(new Ellers())\n            }}\n          >\n            Ellers\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.generateMaze(new RecursiveBacktracking())\n            }}\n          >\n            Recursive BackTrack\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.generateMaze(new RecursiveDivision())\n            }}\n          >\n            Recursive Division\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.performAlgorithm(new AStar())\n            }}\n          >\n            AStar\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.performAlgorithm(new Dijkstra())\n            }}\n          >\n            Dijkstra\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.performAlgorithm(new DFS())\n            }}\n          >\n            DFS\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.performAlgorithm(new BFS())\n            }}\n          >\n            BFS\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.clearPath()\n            }}\n          >\n            Clear Path\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.clearWall()\n            }}\n          >\n            Clear Walls\n          </a>\n        </li>\n      </ul>\n    )\n  }\n}\n","import { GRID_H, GRID_W, Node, NodeType } from '../models'\r\n\r\nexport const getDefaultGrid = () => {\r\n  const grid: Node[][] = []\r\n  for (let row = 0; row < GRID_H; row++) {\r\n    let curRow: Node[] = []\r\n    for (let col = 0; col < GRID_W; col++) {\r\n      let newNode: Node = { position: { x: col, y: row }, nodeType: NodeType.Unvisited }\r\n      curRow.push(newNode)\r\n    }\r\n    grid.push(curRow)\r\n  }\r\n  return grid\r\n}\r\n\r\nexport const cloneGrid = (grid: Node[][]) => grid.map(row => row.slice())\r\n\r\nexport const clearPath = (grid: Node[][]): Node[][] =>\r\n  grid.map(row =>\r\n    row.map(node => ({\r\n      ...node,\r\n      nodeType: node.nodeType === NodeType.Wall ? NodeType.Wall : NodeType.Unvisited\r\n    }))\r\n  )\r\n\r\nexport const clearWalls = (grid: Node[][]): Node[][] =>\r\n  grid.map(row =>\r\n    row.map(node => ({\r\n      ...node,\r\n      nodeType: NodeType.Unvisited\r\n    }))\r\n  )\r\n","import { Position } from '../models'\r\n\r\nexport const positionsEqual = (pos1: Position, pos2: Position) => pos1.x === pos2.x && pos1.y === pos2.y\r\n\r\nexport const isStart = (position: Position, startPos: Position) => positionsEqual(position, startPos)\r\n\r\nexport const isFinish = (position: Position, finishPos: Position) => positionsEqual(position, finishPos)\r\n\r\nexport const isMidpoint = (position: Position, midpointPos: Position) =>\r\n  midpointPos && positionsEqual(position, midpointPos)\r\n\r\nexport const isEmpty = (position: Position, startPos: Position, finishPos: Position, midpointPos: Position) =>\r\n  !isStart(position, startPos) && !isFinish(position, finishPos) && !isMidpoint(position, midpointPos)\r\n","import * as React from 'react'\r\nimport {\r\n  Node,\r\n  NodeType,\r\n  Position,\r\n  MouseState,\r\n  GRID_W,\r\n  GRID_H,\r\n  DEFAULT_START_POS,\r\n  DEFAULT_FINISH_POS,\r\n  UPDATE_RATE\r\n} from './models'\r\nimport { createRef, FunctionComponent, RefObject, useState } from 'react'\r\nimport { Cell } from './Cell'\r\nimport Navbar from './Navbar'\r\nimport PathfindingAlgorithm from './Algorithms/PathfindingAlgorithm'\r\nimport MazeGenerator from './mazes/MazeGenerator'\r\nimport { clearPath, clearWalls, cloneGrid, getDefaultGrid, isEmpty, isFinish, isMidpoint, isStart } from './helpers'\r\n\r\nconst references: any[][] = Array(GRID_H)\r\n  .fill([])\r\n  .map(() =>\r\n    Array(GRID_W)\r\n      .fill(0)\r\n      .map(() => createRef())\r\n  )\r\n\r\nexport const Pathfinder: FunctionComponent = () => {\r\n  const [grid, setGrid] = useState<Node[][]>(getDefaultGrid())\r\n  const [startPos, setStartPos] = useState<Position>(DEFAULT_START_POS)\r\n  const [finishPos, setFinishPos] = useState<Position>(DEFAULT_FINISH_POS)\r\n  const [midpointPos, setMidpointPos] = useState<Position | undefined>()\r\n  const [mouseState, setMouseState] = useState<MouseState>(MouseState.PlacingWall)\r\n  const [prevAlgorithm, setPrevAlgorithm] = useState<PathfindingAlgorithm | undefined>()\r\n  const [animating, setAnimating] = useState(false)\r\n\r\n  const recalculatePath = (\r\n    prevAlgorithm: PathfindingAlgorithm,\r\n    startPos: Position,\r\n    finishPos: Position,\r\n    midpointPos?: Position\r\n  ) => {\r\n    let newGrid: Node[][] = clearPath(cloneGrid(grid))\r\n    let visitedPaths: Position[][] = []\r\n    let finalPaths: Position[][] = []\r\n    if (!midpointPos) {\r\n      prevAlgorithm.calculatePath(newGrid, startPos, finishPos)\r\n      visitedPaths.push(prevAlgorithm.produceVisitedInOrder())\r\n      finalPaths.push(prevAlgorithm.produceFinalPath())\r\n    } else {\r\n      prevAlgorithm.calculatePath(newGrid, startPos, midpointPos)\r\n      visitedPaths.push(prevAlgorithm.produceVisitedInOrder())\r\n      finalPaths.push(prevAlgorithm.produceFinalPath())\r\n\r\n      prevAlgorithm.calculatePath(newGrid, midpointPos, finishPos)\r\n      visitedPaths.push(prevAlgorithm.produceVisitedInOrder())\r\n      finalPaths.push(prevAlgorithm.produceFinalPath())\r\n    }\r\n\r\n    for (let idx = 0; idx < visitedPaths.length; idx++) {\r\n      let visited: Position[] = visitedPaths[idx]\r\n      for (let pos of visited) {\r\n        if (idx === 0) {\r\n          newGrid[pos.y][pos.x].nodeType = NodeType.VisitedOne\r\n        } else if (newGrid[pos.y][pos.x].nodeType === NodeType.VisitedOne) {\r\n          newGrid[pos.y][pos.x].nodeType = NodeType.VisitedOverlap\r\n        } else {\r\n          newGrid[pos.y][pos.x].nodeType = NodeType.VisitedTwo\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let path of finalPaths) {\r\n      for (let pos of path) {\r\n        newGrid[pos.y][pos.x].nodeType = NodeType.ShortestPath\r\n      }\r\n    }\r\n\r\n    setStartPos(startPos)\r\n    setFinishPos(finishPos)\r\n    setMidpointPos(midpointPos)\r\n    setPrevAlgorithm(prevAlgorithm)\r\n    setGrid(newGrid)\r\n  }\r\n\r\n  const onMouseUp = () => {\r\n    setMouseState(MouseState.PlacingWall)\r\n  }\r\n\r\n  const onMouseDown = (position: Position) => {\r\n    if (animating) return\r\n    const { nodeType } = grid[position.y][position.x]\r\n    if (\r\n      (mouseState === MouseState.MovingStart ||\r\n        mouseState === MouseState.MovingFinish ||\r\n        mouseState === MouseState.MovingMidpoint) &&\r\n      !isEmpty(position, startPos, finishPos, midpointPos)\r\n    )\r\n      return\r\n\r\n    if (isStart(position, startPos)) {\r\n      setMouseState(MouseState.MovingStart)\r\n    } else if (isFinish(position, finishPos)) {\r\n      setMouseState(MouseState.MovingFinish)\r\n    } else if (isMidpoint(position, midpointPos)) {\r\n      setMouseState(MouseState.MovingMidpoint)\r\n    } else if (nodeType === NodeType.Unvisited) {\r\n      setMouseState(MouseState.PlacingWall)\r\n    } else {\r\n      setMouseState(MouseState.RemovingWall)\r\n    }\r\n\r\n    if (isEmpty(position, startPos, finishPos, midpointPos)) {\r\n      let clearedGrid = cloneGrid(grid)\r\n      if (prevAlgorithm) {\r\n        clearedGrid = clearPath(clearedGrid)\r\n        setPrevAlgorithm(undefined)\r\n      }\r\n      if (nodeType === NodeType.Wall) {\r\n        clearedGrid[position.y][position.x].nodeType = NodeType.Unvisited\r\n      } else {\r\n        clearedGrid[position.y][position.x].nodeType = NodeType.Wall\r\n      }\r\n      setGrid(clearedGrid)\r\n    }\r\n  }\r\n\r\n  const onMouseEnter = (position: Position, isMouseDown: boolean) => {\r\n    if (animating) return\r\n    const clonedGrid = cloneGrid(grid)\r\n    if (\r\n      !isMouseDown ||\r\n      isStart(position, startPos) ||\r\n      isFinish(position, finishPos) ||\r\n      isMidpoint(position, midpointPos)\r\n    )\r\n      return\r\n\r\n    switch (mouseState) {\r\n      case MouseState.MovingStart:\r\n        if (prevAlgorithm) {\r\n          recalculatePath(prevAlgorithm, position, finishPos, midpointPos)\r\n        } else {\r\n          setStartPos(position)\r\n        }\r\n        break\r\n      case MouseState.MovingFinish:\r\n        if (prevAlgorithm) {\r\n          recalculatePath(prevAlgorithm, startPos, position, midpointPos)\r\n        } else {\r\n          setFinishPos(position)\r\n        }\r\n        break\r\n      case MouseState.MovingMidpoint:\r\n        if (prevAlgorithm) {\r\n          recalculatePath(prevAlgorithm, startPos, finishPos, position)\r\n        } else {\r\n          setMidpointPos(position)\r\n        }\r\n        break\r\n      case MouseState.PlacingWall:\r\n        clonedGrid[position.y][position.x].nodeType = NodeType.Wall\r\n        setGrid(clonedGrid)\r\n        break\r\n      case MouseState.RemovingWall:\r\n        clonedGrid[position.y][position.x].nodeType = NodeType.Unvisited\r\n        setGrid(clonedGrid)\r\n        break\r\n    }\r\n  }\r\n\r\n  const performAlgorithm = (algorithm: PathfindingAlgorithm): void => {\r\n    setPrevAlgorithm(algorithm)\r\n    setMouseState(MouseState.Disabled)\r\n    const clonedGrid = clearPath(cloneGrid(grid))\r\n    const visitedPaths: Position[][] = []\r\n    const finalPaths: Position[][] = []\r\n    if (!midpointPos) {\r\n      algorithm.calculatePath(grid, startPos, finishPos)\r\n      visitedPaths.push(algorithm.produceVisitedInOrder())\r\n      finalPaths.push(algorithm.produceFinalPath())\r\n    } else {\r\n      algorithm.calculatePath(grid, startPos, midpointPos)\r\n      visitedPaths.push(algorithm.produceVisitedInOrder())\r\n      finalPaths.push(algorithm.produceFinalPath())\r\n\r\n      algorithm.calculatePath(grid, midpointPos, finishPos)\r\n      visitedPaths.push(algorithm.produceVisitedInOrder())\r\n      finalPaths.push(algorithm.produceFinalPath())\r\n    }\r\n    visualiseAlgorithm(visitedPaths, finalPaths, clonedGrid)\r\n\r\n    setGrid(clonedGrid)\r\n    setMouseState(MouseState.PlacingWall)\r\n  }\r\n\r\n  const visualiseAlgorithm = async (\r\n    visitedInOrder: Position[][],\r\n    shortestPath: Position[][],\r\n    clonedGrid: Node[][]\r\n  ): Promise<void> => {\r\n    setAnimating(true)\r\n\r\n    for (let idx = 0; idx < visitedInOrder.length; idx++) {\r\n      let visited: Position[] = visitedInOrder[idx]\r\n      await visualiseVisited(visited, idx, clonedGrid)\r\n    }\r\n    await visualisePath(shortestPath.flat(), clonedGrid)\r\n    setAnimating(false)\r\n  }\r\n\r\n  const visualiseVisited = (visitedInOrder: Position[], count: number, clonedGrid: Node[][]): Promise<void> => {\r\n    return new Promise<void>(resolve => {\r\n      for (let i = 0; i <= visitedInOrder.length; i++) {\r\n        setTimeout(() => {\r\n          if (i === visitedInOrder.length) {\r\n            setTimeout(() => {\r\n              resolve()\r\n            }, UPDATE_RATE)\r\n          } else {\r\n            let position: Position = visitedInOrder[i]\r\n            let ref: RefObject<HTMLDivElement> = references[position.y][position.x]\r\n            let className: string = ref.current.className\r\n            if (\r\n              !className.includes('cell-start') &&\r\n              !className.includes('cell-finish') &&\r\n              !className.includes('cell-midpoint')\r\n            ) {\r\n              if (className.includes('cell-visited-0')) {\r\n                ref.current.className = `cell cell-visited-overlap`\r\n              } else {\r\n                ref.current.className = `cell cell-visited-${count}`\r\n              }\r\n              if (count === 0) {\r\n                clonedGrid[position.y][position.x].nodeType = NodeType.VisitedOne\r\n              } else if (clonedGrid[position.y][position.x].nodeType === NodeType.VisitedOne) {\r\n                clonedGrid[position.y][position.x].nodeType = NodeType.VisitedOverlap\r\n              } else {\r\n                clonedGrid[position.y][position.x].nodeType = NodeType.VisitedTwo\r\n              }\r\n            }\r\n          }\r\n        }, UPDATE_RATE * i)\r\n      }\r\n    })\r\n  }\r\n\r\n  const visualisePath = (shortestPath: Position[], clonedGrid: Node[][]): Promise<void> => {\r\n    return new Promise<void>(resolve => {\r\n      for (let i = 0; i <= shortestPath.length; i++) {\r\n        setTimeout(() => {\r\n          if (i === shortestPath.length) {\r\n            setTimeout(() => {\r\n              resolve()\r\n            }, UPDATE_RATE)\r\n          } else {\r\n            let position: Position = shortestPath[i]\r\n            let ref: RefObject<HTMLDivElement> = references[position.y][position.x]\r\n            let className: string = ref.current.className\r\n            if (\r\n              !className.includes('cell-start') &&\r\n              !className.includes('cell-finish') &&\r\n              !className.includes('cell-midpoint')\r\n            ) {\r\n              ref.current.className = 'cell cell-shortestPath'\r\n              clonedGrid[position.y][position.x].nodeType = NodeType.ShortestPath\r\n            }\r\n          }\r\n        }, UPDATE_RATE * i)\r\n      }\r\n    })\r\n  }\r\n\r\n  const clearGridWalls = () => {\r\n    references.forEach(refRow =>\r\n      refRow.forEach(ref => {\r\n        const className = ref.current.className\r\n        if (\r\n          !className.includes('cell-start') &&\r\n          !className.includes('cell-finish') &&\r\n          !className.includes('cell-midpoint')\r\n        ) {\r\n          ref.current.className = 'cell cell-unvisited'\r\n        }\r\n      })\r\n    )\r\n  }\r\n\r\n  const generateMaze = async (mazeGenerator: MazeGenerator): Promise<void> => {\r\n    setAnimating(true)\r\n    setPrevAlgorithm(undefined)\r\n    clearGridWalls()\r\n    const clonedGrid = clearWalls(cloneGrid(grid))\r\n    const setupWalls: Position[] = mazeGenerator.getSetup()\r\n    const walls: Position[] = mazeGenerator.generateWalls()\r\n    await setupStartingWalls(setupWalls, clonedGrid)\r\n    await visualizeMaze(walls, clonedGrid)\r\n    setGrid(clonedGrid)\r\n    setMouseState(MouseState.PlacingWall)\r\n    setAnimating(false)\r\n  }\r\n\r\n  const setupStartingWalls = (walls: Position[], clonedGrid: Node[][]): Promise<void> => {\r\n    return new Promise<void>(resolve => {\r\n      for (let i = 0; i <= walls.length; i++) {\r\n        if (i === walls.length) {\r\n          setTimeout(() => {\r\n            resolve()\r\n          }, 1000)\r\n        } else {\r\n          let position = walls[i]\r\n          let ref: RefObject<HTMLDivElement> = references[position.y][position.x]\r\n          let className = ref.current.className\r\n          clonedGrid[position.y][position.x].nodeType = NodeType.Wall\r\n          if (\r\n            !className.includes('cell-start') &&\r\n            !className.includes('cell-finish') &&\r\n            !className.includes('cell-midpoint')\r\n          ) {\r\n            ref.current.className = 'cell cell-wall'\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  const visualizeMaze = (walls: Position[], clonedGrid: Node[][]): Promise<void> => {\r\n    return new Promise<void>(resolve => {\r\n      for (let i = 0; i <= walls.length; i++) {\r\n        setTimeout(() => {\r\n          if (i === walls.length) {\r\n            setTimeout(() => {\r\n              resolve()\r\n            }, UPDATE_RATE)\r\n          } else {\r\n            let position: Position = walls[i]\r\n            let ref: RefObject<HTMLDivElement> = references[position.y][position.x]\r\n            let className: string = ref.current.className\r\n            if (className.includes('cell-wall')) {\r\n              if (!className.includes('cell-start') && !className.includes('cell-finish')) {\r\n                ref.current.className = 'cell cell-unvisited'\r\n              }\r\n              clonedGrid[position.y][position.x].nodeType = NodeType.Unvisited\r\n            } else {\r\n              if (\r\n                !className.includes('cell-start') &&\r\n                !className.includes('cell-finish') &&\r\n                !className.includes('cell-midpoint')\r\n              ) {\r\n                ref.current.className = 'cell cell-wall'\r\n              }\r\n              clonedGrid[position.y][position.x].nodeType = NodeType.Wall\r\n            }\r\n          }\r\n        }, UPDATE_RATE * i)\r\n      }\r\n    })\r\n  }\r\n\r\n  const setMidpoint = (position: Position): void => {\r\n    if (animating) return\r\n    if (!isStart(position, startPos) && !isFinish(position, finishPos)) {\r\n      setMidpointPos(isMidpoint(position, midpointPos) ? undefined : position)\r\n      if (prevAlgorithm) {\r\n        setPrevAlgorithm(undefined)\r\n      }\r\n    }\r\n  }\r\n\r\n  const cells = grid.map((row, rowIdx) => (\r\n    <div className='grid-row' key={rowIdx}>\r\n      {row.map((node, colIdx) => {\r\n        const position: Position = { x: colIdx, y: rowIdx }\r\n        return (\r\n          <Cell\r\n            key={`${colIdx}-${rowIdx}`}\r\n            position={position}\r\n            onMouseDown={onMouseDown}\r\n            onMouseEnter={onMouseEnter}\r\n            onMouseUp={onMouseUp}\r\n            isStart={isStart(position, startPos)}\r\n            isFinish={isFinish(position, finishPos)}\r\n            isMidpoint={isMidpoint(position, midpointPos)}\r\n            setMidpoint={setMidpoint}\r\n            nodeType={node.nodeType}\r\n            nodeRef={references[rowIdx][colIdx]}\r\n          />\r\n        )\r\n      })}\r\n    </div>\r\n  ))\r\n\r\n  return (\r\n    <div>\r\n      <Navbar\r\n        performAlgorithm={(algorithm: PathfindingAlgorithm) => performAlgorithm(algorithm)}\r\n        clearPath={() => {\r\n          setPrevAlgorithm(undefined)\r\n          setGrid(clearPath(grid))\r\n        }}\r\n        clearWall={() => {\r\n          setPrevAlgorithm(undefined)\r\n          setGrid(clearWalls(grid))\r\n        }}\r\n        generateMaze={(mazeGenerator: MazeGenerator) => {\r\n          generateMaze(mazeGenerator)\r\n        }}\r\n      />\r\n      <div className='grid'>{cells}</div>\r\n    </div>\r\n  )\r\n}\r\n","import { Pathfinder } from './Pathfinder'\nimport { FunctionComponent } from 'react'\nimport React from 'react'\n\nexport const App: FunctionComponent = () => {\n  return (\n    <div className='app'>\n      <Pathfinder />\n    </div>\n  )\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport { App } from './App'\n\nimport './index.css'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}