{"version":3,"sources":["models/MouseState.ts","models/Node.ts","models/Grid.ts","Cell.tsx","Algorithms/PathfindingAlgorithm.tsx","Algorithms/DataStructures/PriorityQueue.tsx","Algorithms/Dijkstra.tsx","Algorithms/DataStructures/Stack.tsx","Algorithms/DFS.ts","Algorithms/DataStructures/Queue.ts","Algorithms/BFS.tsx","mazes/MazeGenerator.ts","mazes/RecursiveDivision.ts","mazes/WallCarver.ts","mazes/RecursiveBacktracking.ts","mazes/Ellers.ts","Algorithms/AStar.ts","Navbar.tsx","helpers/gridHelpers.ts","helpers/positionHelpers.ts","Pathfinder.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["MouseState","NodeType","screenWidth","Math","floor","window","innerWidth","screenHeight","innerHeight","GRID_W","GRID_H","DEFAULT_START_POS","x","y","DEFAULT_FINISH_POS","Cell","position","isStart","isFinish","isMidpoint","nodeType","setMidpoint","onMouseDown","onMouseUp","onMouseEnter","nodeRef","ref","id","className","Unvisited","VisitedOne","VisitedTwo","VisitedOverlap","Wall","ShortestPath","getClassName","event","isMouseDown","buttons","which","onContextMenu","stopPropagation","preventDefault","PathfindingAlgorithm","pathValues","Map","finalPath","visitedNodesInOrder","this","slice","length","grid","neighbors","push","filter","neighbor","isVisited","cornerCheck","current","sqrt","pow","abs","get","hash","pathData","newPathData","set","finishPos","curPosition","previousNode","unshift","pos1","pos2","toString","PriorityQueue","heap","val","priority","replace","undefined","tmp","found","i","p","n","find","foundNode","tuple","shift","pop","map","values","Dijkstra","minHeap","startPos","reset","setMap","insert","size","closestPosition","markAsVisited","equalPosition","findShortestPath","getNeighbors","closestDistance","shortestPath","newDistance","getDistance","neighborPathData","forEach","row","node","nodePosition","Infinity","clear","Stack","data","top","element","DFS","stack","isEmpty","reverse","Queue","BFS","queue","MazeGenerator","wallsCreatedInOrder","walls","topBorderWall","botBorderWall","leftBorderWall","rightBorderWall","min","max","random","RecursiveDivision","lr","divide","ul","splitIdx","gap","newLr","newUl","width","height","vertical","randomEven","console","log","randomOdd","pos","getRandom","ADJUSTED_WIDTH","ADJUSTED_HEIGHT","WallCarver","positionBetween","addWall","middleWall","crossWall","RecursiveBacktracking","visited","randomStartingPos","carveWalls","visit","getUnvisitedNeighbors","isVisisted","placeWallBetweenPositions","positionInBounds","randomisePositions","positions","sort","has","Ellers","generateMaze","currentRow","Uptree","mergeRow","prevRow","extendToNextRow","rowIdx","isRoot","addEntry","addTopWall","randomBool","getEntry","sameClass","mergeSets","addRightWall","Array","fill","set1","set2","getRoot","index1","index2","index","value","AStar","setNeighbors","start","finish","costSoFar","distanceFromStart","distanceFromFinish","totalCost","prevPathData","Navbar","props","state","onClick","performAlgorithm","clearPath","clearWall","Component","cloneGrid","clearWalls","positionsEqual","midpointPos","references","createRef","Pathfinder","useState","curRow","col","newNode","getDefaultGrid","setGrid","setStartPos","setFinishPos","setMidpointPos","PlacingWall","mouseState","setMouseState","prevAlgorithm","setPrevAlgorithm","animating","setAnimating","recalculatePath","newGrid","visitedPaths","finalPaths","calculatePath","produceVisitedInOrder","produceFinalPath","idx","path","MovingStart","MovingFinish","MovingMidpoint","RemovingWall","clearedGrid","clonedGrid","visualiseAlgorithm","visitedInOrder","a","visualiseVisited","visualisePath","flat","count","Promise","resolve","setTimeout","includes","mazeGenerator","refRow","setupWalls","getSetup","generateWalls","setupStartingWalls","visualizeMaze","cells","key","colIdx","algorithm","Disabled","App","Boolean","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.3088d85e.chunk.js","sourcesContent":["export enum MouseState {\r\n  PlacingWall = 'PLACING_WALL',\r\n  RemovingWall = 'REMOVING_WALL',\r\n  MovingStart = 'MOVING_START',\r\n  MovingFinish = 'MOVING_FINISH',\r\n  MovingMidpoint = 'MOVING_MIDPOINT',\r\n  Disabled = 'DISABLED'\r\n}\r\n","import { Position } from './Position'\r\n\r\nexport enum NodeType {\r\n  Unvisited = 'UNVISITED',\r\n  VisitedOne = 'VISITED_ONE',\r\n  VisitedTwo = 'VISITED_TWO',\r\n  VisitedOverlap = 'VISITED_OVERLAP',\r\n  Wall = 'WALL',\r\n  ShortestPath = 'SHORTEST_PATH'\r\n}\r\n\r\nexport interface Node {\r\n  position: Position\r\n  nodeType: NodeType\r\n}\r\n","import { Position } from './Position'\r\n\r\nconst screenWidth = Math.floor((0.9 * window.innerWidth) / 25)\r\nconst screenHeight = Math.floor((0.8 * window.innerHeight) / 25)\r\nexport const GRID_W = screenWidth % 2 === 0 ? screenWidth - 1 : screenWidth\r\nexport const GRID_H = screenHeight % 2 === 0 ? screenHeight - 1 : screenHeight\r\nexport const DEFAULT_START_POS: Position = { x: Math.floor(GRID_W / 4), y: Math.floor(GRID_H / 2) }\r\nexport const DEFAULT_FINISH_POS: Position = { x: GRID_W - DEFAULT_START_POS.x - 1, y: DEFAULT_START_POS.y }\r\nexport const UPDATE_RATE = 15\r\n","import * as React from 'react'\nimport { FunctionComponent, RefObject } from 'react'\nimport { NodeType, Position } from './models'\n\ninterface CellProps {\n  position: Position\n  isStart: boolean\n  isFinish: boolean\n  isMidpoint: boolean\n  nodeType: NodeType\n  setMidpoint: (position: Position) => void\n  onMouseDown: (position: Position) => void\n  onMouseUp: () => void\n  onMouseEnter: (position: Position, isMouseDown: boolean) => void\n  nodeRef: (ref: RefObject<HTMLDivElement> | any) => void\n}\n\nexport const Cell: FunctionComponent<CellProps> = ({\n  position,\n  isStart,\n  isFinish,\n  isMidpoint,\n  nodeType,\n  setMidpoint,\n  onMouseDown,\n  onMouseUp,\n  onMouseEnter,\n  nodeRef\n}) => {\n  const getClassName = () => {\n    if (isStart || isFinish || isMidpoint) {\n      return isStart ? 'cell-start' : isFinish ? 'cell-finish' : isMidpoint ? 'cell-midpoint' : ''\n    } else {\n      switch (nodeType) {\n        case NodeType.Unvisited:\n          return 'cell-unvisited'\n        case NodeType.VisitedOne:\n          return 'cell-visited-0'\n        case NodeType.VisitedTwo:\n          return 'cell-visited-1'\n        case NodeType.VisitedOverlap:\n          return 'cell-visited-overlap'\n        case NodeType.Wall:\n          return 'cell-wall'\n        case NodeType.ShortestPath:\n          return 'cell-shortestPath'\n      }\n    }\n  }\n\n  return (\n    <div\n      ref={nodeRef}\n      id={`cell-${position.x}-${position.y}`}\n      className={`cell ${getClassName()}`}\n      onMouseUp={onMouseUp}\n      onMouseDown={() => onMouseDown(position)}\n      onMouseEnter={event => {\n        const isMouseDown = (event.buttons ?? (event as any).which) === 1\n        onMouseEnter(position, isMouseDown)\n      }}\n      onContextMenu={event => {\n        event.stopPropagation()\n        event.preventDefault()\n        setMidpoint(position)\n      }}\n    />\n  )\n}\n","import { GRID_H, GRID_W, Node, NodeType, Position } from '../models'\n\nexport interface PathData {\n  isVisited: boolean\n  shortestPath?: number\n  previousNode?: Position\n}\n\nexport default abstract class PathfindingAlgorithm {\n  pathValues: Map<string, PathData> = new Map<string, PathData>()\n  finalPath: Position[] = []\n  visitedNodesInOrder: Position[] = []\n\n  protected abstract setMap(grid: Node[][], startPos?: Position): void\n\n  public abstract calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void\n\n  public produceVisitedInOrder(): Position[] {\n    return this.visitedNodesInOrder.slice(1, this.visitedNodesInOrder.length - 1)\n  }\n\n  public produceFinalPath(): Position[] {\n    return this.finalPath.slice(1, this.visitedNodesInOrder.length - 1)\n  }\n\n  protected getNeighbors(grid: Node[][], position: Position): Position[] {\n    let neighbors: Position[] = []\n    neighbors.push({ x: position.x + 1, y: position.y })\n    neighbors.push({ x: position.x, y: position.y + 1 })\n    neighbors.push({ x: position.x, y: position.y - 1 })\n    neighbors.push({ x: position.x - 1, y: position.y })\n\n    neighbors.push({ x: position.x - 1, y: position.y + 1 })\n    neighbors.push({ x: position.x + 1, y: position.y + 1 })\n    neighbors.push({ x: position.x + 1, y: position.y - 1 })\n    neighbors.push({ x: position.x - 1, y: position.y - 1 })\n\n    return neighbors.filter(neighbor => {\n      return (\n        neighbor.x >= 0 &&\n        neighbor.x < GRID_W &&\n        neighbor.y >= 0 &&\n        neighbor.y < GRID_H &&\n        grid[neighbor.y][neighbor.x].nodeType !== NodeType.Wall &&\n        !this.isVisited(neighbor) &&\n        this.cornerCheck(position, neighbor, grid)\n      )\n    })\n  }\n\n  private cornerCheck(position: Position, neighbor: Position, grid: Node[][]): boolean {\n    return (\n      grid[position.y][neighbor.x].nodeType !== NodeType.Wall || grid[neighbor.y][position.x].nodeType !== NodeType.Wall\n    )\n  }\n\n  protected getDistance(grid: Node[][], current: Position, neighbor: Position): number {\n    return Math.sqrt(Math.pow(Math.abs(current.x - neighbor.x), 2) + Math.pow(Math.abs(current.y - neighbor.y), 2))\n  }\n\n  protected isVisited(position: Position): boolean {\n    return this.pathValues.get(this.hash(position)).isVisited\n  }\n\n  protected markAsVisited(position: Position): void {\n    this.visitedNodesInOrder.push(position)\n    let pathData: PathData = this.pathValues.get(this.hash(position))\n    let newPathData: PathData = {\n      ...pathData,\n      isVisited: true\n    }\n    this.pathValues.set(this.hash(position), newPathData)\n  }\n\n  protected findShortestPath(finishPos: Position): void {\n    for (\n      let curPosition = finishPos;\n      curPosition != null;\n      curPosition = this.pathValues.get(this.hash(curPosition)).previousNode\n    ) {\n      this.finalPath.unshift(curPosition)\n    }\n  }\n\n  protected equalPosition(pos1: Position, pos2: Position) {\n    return pos1.x === pos2.x && pos1.y === pos2.y\n  }\n\n  protected hash(position: Position): string {\n    return position.x.toString() + '-' + position.y.toString()\n  }\n\n  protected clear(): void {\n    this.visitedNodesInOrder = []\n    this.finalPath = []\n    this.pathValues = new Map<string, PathData>()\n  }\n\n  protected abstract reset(): void\n}\n","export interface Node {\n    x: number;\n    y: number;\n}\n\nexport type Tuple<T> = [T, number];\n\nexport class PriorityQueue<T extends Node> {\n    heap: Tuple<T>[] = [];\n\n    insert(val: T, priority: number, replace?: boolean) {\n        replace = replace !== undefined;\n\n        if (!this.heap.length || this.heap[this.heap.length - 1][1] > priority) {\n            this.heap.push([val, priority]);\n            return this.heap;\n        }\n\n        const tmp: Tuple<T>[] = [];\n        let found = false;\n\n        for (let i = 0; i < this.heap.length; i++) {\n            const p = this.heap[i][1];\n            const n = this.heap[i][0];\n\n            if (priority >= p && !found) {\n                tmp.push([val, priority]);\n                found = true;\n            }\n\n            if (!(replace && n.x === val.x && n.y === val.y)) {\n                tmp.push(this.heap[i]);\n            }\n        }\n        return (this.heap = tmp);\n    }\n\n    has({ x, y }: T) {\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\n\n        return !!foundNode;\n    }\n\n    get({ x, y }: T) {\n        const foundNode = this.heap.find(([val]) => val.x === x && val.y === y);\n\n        return foundNode && foundNode[1];\n    }\n\n    shift(priority: boolean) {\n        const tuple = this.heap.shift();\n        if (priority) {\n            return tuple;\n        }\n\n        return tuple ? tuple[0] : undefined;\n    }\n\n    pop() {\n        return this.heap.pop()[0];\n    }\n\n    priorities() {\n        return this.heap.map(([_, p]) => p);\n    }\n\n    values() {\n        return this.heap.map(([val]) => val);\n    }\n\n    size() {\n        return this.heap.length;\n    }\n\n    toArray(values: boolean) {\n        if (values) {\n            return this.heap.map(([val]) => val);\n        }\n        return this.heap;\n    }\n}\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm'\nimport { Node, Position } from '../models'\nimport { PriorityQueue } from './DataStructures/PriorityQueue'\n\nexport default class Dijkstra extends PathfindingAlgorithm {\n  minHeap: PriorityQueue<Position> = new PriorityQueue<Position>()\n  calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void {\n    this.reset()\n    this.setMap(grid, startPos)\n    this.minHeap.insert(startPos, 0)\n    while (this.minHeap.size() !== 0) {\n      let closestPosition: Position = this.minHeap.pop()\n      this.markAsVisited(closestPosition)\n      if (this.equalPosition(closestPosition, finishPos)) {\n        this.findShortestPath(finishPos)\n        return\n      }\n      let neighbors: Position[] = this.getNeighbors(grid, closestPosition)\n      let closestDistance: number = this.pathValues.get(this.hash(closestPosition)).shortestPath\n      for (let neighbor of neighbors) {\n        let newDistance: number = closestDistance + this.getDistance(grid, closestPosition, neighbor)\n        let neighborPathData: PathData = this.pathValues.get(this.hash(neighbor))\n        this.minHeap.insert(neighbor, newDistance)\n        if (newDistance < neighborPathData.shortestPath) {\n          let pathData: PathData = {\n            shortestPath: newDistance,\n            isVisited: true,\n            previousNode: closestPosition\n          }\n          this.pathValues.set(this.hash(neighbor), pathData)\n        }\n      }\n    }\n  }\n\n  protected setMap(grid: Node[][], startPos: Position): void {\n    grid.forEach(row => {\n      return row.forEach(node => {\n        let nodePosition: Position = node.position\n        let shortestPath: number\n        if (this.equalPosition(startPos, nodePosition)) {\n          shortestPath = 0\n        } else {\n          shortestPath = Infinity\n        }\n        let pathData: PathData = { shortestPath: shortestPath, isVisited: false, previousNode: null }\n        this.pathValues.set(this.hash(nodePosition), pathData)\n      })\n    })\n  }\n\n  protected reset(): void {\n    this.clear()\n    this.minHeap = new PriorityQueue<Position>()\n  }\n}\n","export default class Stack<T> {\n  data: T[]\n  top: number\n  constructor() {\n    this.data = []\n    this.top = 0\n  }\n  public push(element: T): void {\n    this.data[this.top] = element\n    this.top++\n  }\n  public pop(): T {\n    this.top--\n    return this.data[this.top]\n  }\n  public isEmpty(): boolean {\n    return this.top === 0\n  }\n}\n","import PathfindingAlgorithm from './PathfindingAlgorithm'\nimport Stack from './DataStructures/Stack'\nimport { Position, Node } from '../models'\n\nexport default class DFS extends PathfindingAlgorithm {\n  stack: Stack<Position> = new Stack<Position>()\n  calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void {\n    this.reset()\n    this.setMap(grid)\n    this.stack.push(startPos)\n    while (!this.stack.isEmpty()) {\n      let curPosition: Position = this.stack.pop()\n      this.markAsVisited(curPosition)\n      if (this.equalPosition(curPosition, finishPos)) {\n        this.finalPath = this.visitedNodesInOrder\n        return\n      }\n      let neighbors: Position[] = this.getNeighbors(grid, curPosition).reverse()\n      for (let neighbor of neighbors) {\n        this.stack.push(neighbor)\n      }\n    }\n  }\n\n  protected setMap(grid: Node[][]): void {\n    grid.forEach(row => {\n      row.forEach(node => {\n        let nodePosition: Position = node.position\n        this.pathValues.set(this.hash(nodePosition), { isVisited: false })\n      })\n    })\n  }\n\n  protected reset(): void {\n    this.clear()\n    this.stack = new Stack<Position>()\n  }\n}\n","export default class Queue<T> {\n  data: T[] = []\n  push(element: T) {\n    this.data.push(element)\n  }\n  pop(): T {\n    return this.data.shift()\n  }\n  isEmpty(): boolean {\n    return this.data.length === 0\n  }\n}\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm'\nimport Queue from './DataStructures/Queue'\nimport { Node, Position } from '../models'\n\nexport default class BFS extends PathfindingAlgorithm {\n  queue: Queue<Position> = new Queue<Position>()\n\n  calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void {\n    this.reset()\n    this.setMap(grid)\n    this.queue.push(startPos)\n    while (!this.queue.isEmpty()) {\n      let curPosition: Position = this.queue.pop()\n      this.markAsVisited(curPosition)\n      if (this.equalPosition(curPosition, finishPos)) {\n        this.findShortestPath(finishPos)\n        return\n      }\n      let neighbors: Position[] = this.getNeighbors(grid, curPosition)\n      for (let neighbor of neighbors) {\n        this.queue.push(neighbor)\n        this.pathValues.set(this.hash(neighbor), { isVisited: true, previousNode: curPosition })\n      }\n    }\n  }\n\n  protected setMap(grid: Node[][]): void {\n    grid.forEach(row => {\n      row.forEach(node => {\n        let nodePosition: Position = node.position\n        let pathData: PathData = {\n          isVisited: false,\n          previousNode: null\n        }\n        this.pathValues.set(this.hash(nodePosition), pathData)\n      })\n    })\n  }\n\n  protected reset(): void {\n    this.clear()\n    this.queue = new Queue<Position>()\n  }\n}\n","import { Position, GRID_H, GRID_W } from './../models'\nexport default abstract class MazeGenerator {\n  wallsCreatedInOrder: Position[]\n  public abstract generateWalls(): Position[]\n  public getSetup(): Position[] {\n    let walls: Position[] = []\n    for (let i = 0; i < GRID_W; i++) {\n      let topBorderWall: Position = { x: i, y: 0 }\n      let botBorderWall: Position = { x: i, y: GRID_H - 1 }\n      walls.push(topBorderWall)\n      walls.push(botBorderWall)\n    }\n    for (let i = 1; i < GRID_H - 1; i++) {\n      let leftBorderWall: Position = { x: 0, y: i }\n      let rightBorderWall: Position = { x: GRID_W - 1, y: i }\n      walls.push(leftBorderWall)\n      walls.push(rightBorderWall)\n    }\n    return walls\n  }\n  protected getRandom(min: number, max: number): number {\n    return min + Math.floor((max - min + 1) * Math.random())\n  }\n  protected addWall(position: Position) {\n    this.wallsCreatedInOrder.push(position)\n  }\n}\n","import MazeGenerator from './MazeGenerator'\nimport { Position, GRID_W, GRID_H } from '../models'\n\nexport default class RecursiveDivision extends MazeGenerator {\n  public generateWalls(): Position[] {\n    this.wallsCreatedInOrder = []\n    const ul: Position = { x: 0, y: 0 }\n    const lr: Position = { x: GRID_W - 1, y: GRID_H - 1 }\n    this.divide(ul, lr)\n    return this.wallsCreatedInOrder\n  }\n\n  private divide(ul: Position, lr: Position) {\n    let width: number = lr.x - ul.x + 1\n    let height: number = lr.y - ul.y + 1\n    let vertical: boolean = width > height\n    let splitIdx: number\n    let gap: Position\n    if (vertical) {\n      if (width < 4) return\n      splitIdx = this.randomEven(ul.x, lr.x)\n      console.log(splitIdx)\n      gap = { x: splitIdx, y: this.randomOdd(ul.y, lr.y) }\n      console.log(`Trying ${splitIdx}, gap (${gap.x},${gap.y}) width: ${width} height: ${height}`)\n    } else {\n      if (height < 4) return\n      splitIdx = this.randomEven(ul.y, lr.y)\n      console.log(splitIdx)\n      gap = { x: this.randomOdd(ul.x, lr.x), y: splitIdx }\n      console.log(`Trying ${splitIdx}, gap (${gap.x},${gap.y}) width: ${width} height: ${height}`)\n    }\n\n    for (let i = vertical ? ul.y + 1 : ul.x + 1; i <= (vertical ? lr.y - 1 : lr.x - 1); i++) {\n      if (i === (vertical ? gap.y : gap.x)) continue\n      let pos: Position\n      if (vertical) {\n        pos = { x: splitIdx, y: i }\n      } else {\n        pos = { x: i, y: splitIdx }\n      }\n      this.wallsCreatedInOrder.push(pos)\n    }\n\n    let newLr: Position\n    let newUl: Position\n    if (vertical) {\n      newLr = { x: splitIdx, y: lr.y }\n      newUl = { x: splitIdx, y: ul.y }\n    } else {\n      newLr = { x: lr.x, y: splitIdx }\n      newUl = { x: ul.x, y: splitIdx }\n    }\n\n    this.divide(ul, newLr)\n    this.divide(newUl, lr)\n  }\n\n  /**\n   *\n   * @param min\n   * @param max\n   *\n   * produce a random even number in a range to match a valid wall coordinate that is not next to a current wall\n   */\n  private randomEven(min: number, max: number): number {\n    min += 2\n    max -= 2\n    if (min % 2 === 1) {\n      min++\n    }\n    if (max % 2 === 1) {\n      max--\n    }\n    let wall = min + 2 * this.getRandom(0, (max - min) / 2)\n    return wall\n  }\n\n  /**\n   *\n   * @param min\n   * @param max\n   *\n   * produce a random odd number in a range to match a valid gap coordinate\n   */\n  private randomOdd(min: number, max: number): number {\n    min += 2\n    max -= 2\n    if (min % 2 === 0) {\n      min++\n    }\n    if (max % 2 === 0) {\n      max--\n    }\n    let gap = min + 2 * this.getRandom(0, (max - min) / 2)\n    return gap\n  }\n\n  private hash(position: Position): string {\n    return position.x.toString() + '-' + position.y.toString()\n  }\n}\n","import MazeGenerator from './MazeGenerator'\nimport { Position, GRID_W, GRID_H } from '../models'\n\nexport const ADJUSTED_WIDTH = (GRID_W - 1) / 2\nexport const ADJUSTED_HEIGHT = (GRID_H - 1) / 2\n\nexport default abstract class WallCarver extends MazeGenerator {\n  protected placeWallBetweenPositions(current: Position, neighbor: Position): void {\n    let positionBetween: Position = {\n      x: Math.floor((current.x + neighbor.x) / 2),\n      y: Math.floor((current.y + neighbor.y) / 2)\n    }\n    this.addWall(positionBetween)\n  }\n\n  protected positionInBounds(position: Position): boolean {\n    return position.x > 0 && position.x < GRID_W - 1 && position.y > 0 && position.y < GRID_H - 1\n  }\n\n  public getSetup(): Position[] {\n    let walls: Position[] = []\n    for (let i = 0; i < GRID_W; i++) {\n      let topBorderWall: Position = { x: i, y: 0 }\n      let botBorderWall: Position = { x: i, y: GRID_H - 1 }\n      walls.push(topBorderWall)\n      walls.push(botBorderWall)\n    }\n    for (let x = 0; x < GRID_W; x += 2) {\n      for (let y = 1; y < GRID_H - 1; y++) {\n        let middleWall: Position = { x: x, y: y }\n        walls.push(middleWall)\n      }\n    }\n    for (let x = 1; x < GRID_W - 1; x += 2) {\n      for (let y = 2; y < GRID_H - 2; y += 2) {\n        let crossWall: Position = { x: x, y: y }\n        walls.push(crossWall)\n      }\n    }\n    return walls\n  }\n}\n","import { Position, GRID_W, GRID_H } from '../models'\nimport WallCarver from './WallCarver'\n\nexport default class RecursiveBacktracking extends WallCarver {\n  visited: Map<String, boolean>\n  public generateWalls(): Position[] {\n    this.wallsCreatedInOrder = []\n    this.visited = new Map<string, boolean>()\n    let randomStartingPos: Position = {\n      x: 2 * this.getRandom(1, (GRID_W - 1) / 2) - 1,\n      y: 2 * this.getRandom(1, (GRID_H - 1) / 2) - 1\n    }\n    this.carveWalls(randomStartingPos)\n    return this.wallsCreatedInOrder\n  }\n\n  carveWalls(current: Position): void {\n    this.visit(current)\n    let neighbors: Position[] = this.getUnvisitedNeighbors(current)\n    for (let neighbor of neighbors) {\n      console.log(neighbor)\n      if (!this.isVisisted(neighbor)) {\n        this.placeWallBetweenPositions(current, neighbor)\n        this.carveWalls(neighbor)\n      }\n    }\n  }\n\n  private getUnvisitedNeighbors(current: Position): Position[] {\n    let right: Position = { x: current.x + 2, y: current.y }\n    let up: Position = { x: current.x, y: current.y - 2 }\n    let left: Position = { x: current.x - 2, y: current.y }\n    let bot: Position = { x: current.x, y: current.y + 2 }\n    let neighbors: Position[] = [right, up, left, bot]\n    neighbors = neighbors.filter((pos: Position) => {\n      return this.positionInBounds(pos)\n    })\n    return this.randomisePositions(neighbors)\n  }\n\n  private randomisePositions(positions: Position[]): Position[] {\n    return positions.sort(() => Math.random() - 0.5)\n  }\n\n  private visit(position: Position): void {\n    this.visited.set(this.hash(position), true)\n  }\n\n  private isVisisted(position: Position): boolean {\n    return this.visited.has(this.hash(position))\n  }\n\n  private hash(position: Position): string {\n    return position.x.toString() + '-' + position.y.toString()\n  }\n}\n","import { Position } from '../models'\nimport WallCarver, { ADJUSTED_WIDTH, ADJUSTED_HEIGHT } from './WallCarver'\n\nexport default class Ellers extends WallCarver {\n  public generateWalls(): Position[] {\n    this.wallsCreatedInOrder = []\n    this.generateMaze()\n    return this.wallsCreatedInOrder\n  }\n\n  private generateMaze(): void {\n    let currentRow: Uptree = new Uptree()\n    currentRow = this.mergeRow(currentRow, 0, true)\n    for (let y = 1; y < ADJUSTED_HEIGHT; y++) {\n      let prevRow = currentRow\n      currentRow = this.extendToNextRow(currentRow, prevRow, y)\n      currentRow = this.mergeRow(currentRow, y, y !== ADJUSTED_HEIGHT - 1)\n    }\n  }\n  extendToNextRow(currentRow: Uptree, prevRow: Uptree, rowIdx: number) {\n    currentRow = new Uptree()\n    for (let x = 0; x < ADJUSTED_WIDTH; x++) {\n      if (prevRow.isRoot(x)) {\n        currentRow.addEntry(x, -1)\n        this.addTopWall({ x: x, y: rowIdx })\n      } else if (this.randomBool()) {\n        currentRow.addEntry(x, prevRow.getEntry(x))\n        this.addTopWall({ x: x, y: rowIdx })\n      }\n    }\n    return currentRow\n  }\n\n  private mergeRow(row: Uptree, rowIdx: number, random: boolean) {\n    for (let i = 0; i < ADJUSTED_WIDTH - 1; i++) {\n      if ((this.randomBool() || !random) && !row.sameClass(i, i + 1)) {\n        row.mergeSets(i, i + 1)\n        this.addRightWall({ x: i, y: rowIdx })\n      }\n    }\n    return row\n  }\n  addRightWall(pos: Position): void {\n    this.addWall({ x: 2 * pos.x + 2, y: 2 * pos.y + 1 })\n  }\n\n  addTopWall(pos: Position): void {\n    this.addWall({ x: 2 * pos.x + 1, y: 2 * pos.y })\n  }\n\n  private randomBool(): boolean {\n    return Math.random() >= 0.5\n  }\n}\n\nclass Uptree {\n  data: number[]\n  constructor() {\n    this.data = Array(ADJUSTED_WIDTH).fill(-1)\n  }\n\n  public mergeSets(set1: number, set2: number): void {\n    if (this.data[set1] === -1) {\n      this.data[set1] = this.getRoot(set2)\n    } else {\n      this.data[set2] = this.getRoot(set1)\n    }\n  }\n\n  public sameClass(index1: number, index2: number) {\n    return this.getRoot(index1) === this.getRoot(index2)\n  }\n\n  public getRoot(index: number): number {\n    while (this.data[index] !== -1) {\n      index = this.data[index]\n    }\n    return index\n  }\n\n  public isRoot(index: number): boolean {\n    return this.data[index] === -1\n  }\n\n  public addEntry(index: number, value: number) {\n    this.data[index] = value\n  }\n\n  public getEntry(index: number): number {\n    return this.getRoot(index)\n  }\n}\n","import PathfindingAlgorithm, { PathData } from './PathfindingAlgorithm'\nimport { Node, Position } from '../models'\nimport { PriorityQueue } from './DataStructures/PriorityQueue'\n\nexport default class AStar extends PathfindingAlgorithm {\n  minHeap: PriorityQueue<Position> = new PriorityQueue<Position>()\n\n  public calculatePath(grid: Node[][], startPos: Position, finishPos: Position): void {\n    this.reset()\n    this.setMap(grid, startPos)\n    this.minHeap.insert(startPos, 0)\n    while (this.minHeap.size() > 0) {\n      let closestPosition: Position = this.minHeap.pop()\n      if (this.pathValues.get(this.hash(closestPosition)).isVisited) {\n        continue\n      }\n      this.markAsVisited(closestPosition)\n      if (this.equalPosition(closestPosition, finishPos)) {\n        this.findShortestPath(finishPos)\n        return\n      }\n      this.setNeighbors(grid, closestPosition, startPos, finishPos)\n    }\n  }\n\n  private setNeighbors(grid: Node[][], current: Position, start: Position, finish: Position): void {\n    let neighbors = this.getNeighbors(grid, current)\n    let costSoFar: number = this.pathValues.get(this.hash(current)).shortestPath\n    for (let neighbor of neighbors) {\n      // let pathData: PathData = this.pathValues.get(this.hash(neighbor));\n      let distanceFromStart: number = costSoFar + this.getDistance(grid, neighbor, current)\n      let distanceFromFinish: number = this.getDistance(grid, neighbor, finish)\n      let totalCost: number = distanceFromStart + distanceFromFinish\n      let prevPathData: PathData = this.pathValues.get(this.hash(neighbor))\n      if (prevPathData.previousNode !== null) {\n        let prevCost: number = prevPathData.shortestPath + distanceFromFinish\n        if (totalCost < prevCost) {\n          this.minHeap.insert(neighbor, totalCost, true)\n          this.pathValues.set(this.hash(neighbor), {\n            isVisited: false,\n            previousNode: current,\n            shortestPath: distanceFromStart\n          })\n        }\n      } else {\n        this.minHeap.insert(neighbor, totalCost, false)\n        this.pathValues.set(this.hash(neighbor), {\n          isVisited: false,\n          previousNode: current,\n          shortestPath: distanceFromStart\n        })\n      }\n    }\n  }\n\n  protected setMap(grid: Node[][], startPos: Position): void {\n    grid.forEach((row: Node[]) => {\n      return row.forEach((node: Node) => {\n        let nodePosition: Position = node.position\n        let shortestPath: number\n        if (this.equalPosition(startPos, nodePosition)) {\n          shortestPath = 0\n        } else {\n          shortestPath = Infinity\n        }\n        let pathData: PathData = { isVisited: false, shortestPath: shortestPath, previousNode: null }\n        this.pathValues.set(this.hash(nodePosition), pathData)\n      })\n    })\n  }\n  protected reset(): void {\n    this.clear()\n    this.minHeap = new PriorityQueue<Position>()\n  }\n}\n","import { Component } from 'react'\nimport * as React from 'react'\nimport PathfindingAlgorithm from './Algorithms/PathfindingAlgorithm'\nimport Dijkstra from './Algorithms/Dijkstra'\nimport DFS from './Algorithms/DFS'\nimport BFS from './Algorithms/BFS'\nimport MazeGenerator from './mazes/MazeGenerator'\nimport RecursiveDivision from './mazes/RecursiveDivision'\nimport RecursiveBacktracking from './mazes/RecursiveBacktracking'\nimport Ellers from './mazes/Ellers'\nimport AStar from './Algorithms/AStar'\n\ninterface Props {\n  performAlgorithm: (algorithm: PathfindingAlgorithm) => void\n  clearPath: () => void\n  clearWall: () => void\n  generateMaze: (mazeGenerator: MazeGenerator) => void\n}\n\nexport default class Navbar extends Component<Props> {\n  constructor(props: any) {\n    super(props)\n    this.state = {}\n  }\n\n  render(): any {\n    return (\n      <ul>\n        <li>\n          <a\n            onClick={() => {\n              this.props.generateMaze(new Ellers())\n            }}\n          >\n            Ellers\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.generateMaze(new RecursiveBacktracking())\n            }}\n          >\n            Recursive BackTrack\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.generateMaze(new RecursiveDivision())\n            }}\n          >\n            Recursive Division\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.performAlgorithm(new AStar())\n            }}\n          >\n            AStar\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.performAlgorithm(new Dijkstra())\n            }}\n          >\n            Dijkstra\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.performAlgorithm(new DFS())\n            }}\n          >\n            DFS\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.performAlgorithm(new BFS())\n            }}\n          >\n            BFS\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.clearPath()\n            }}\n          >\n            Clear Path\n          </a>\n        </li>\n        <li>\n          <a\n            onClick={() => {\n              this.props.clearWall()\n            }}\n          >\n            Clear Walls\n          </a>\n        </li>\n      </ul>\n    )\n  }\n}\n","import { GRID_H, GRID_W, Node, NodeType } from '../models'\r\n\r\nexport const getDefaultGrid = () => {\r\n  const grid: Node[][] = []\r\n  for (let row = 0; row < GRID_H; row++) {\r\n    let curRow: Node[] = []\r\n    for (let col = 0; col < GRID_W; col++) {\r\n      let newNode: Node = { position: { x: col, y: row }, nodeType: NodeType.Unvisited }\r\n      curRow.push(newNode)\r\n    }\r\n    grid.push(curRow)\r\n  }\r\n  return grid\r\n}\r\n\r\nexport const cloneGrid = (grid: Node[][]) => grid.map(row => row.slice())\r\n\r\nexport const clearPath = (grid: Node[][]): Node[][] =>\r\n  grid.map(row =>\r\n    row.map(node => ({\r\n      ...node,\r\n      nodeType: node.nodeType === NodeType.Wall ? NodeType.Wall : NodeType.Unvisited\r\n    }))\r\n  )\r\n\r\nexport const clearWalls = (grid: Node[][]): Node[][] =>\r\n  grid.map(row =>\r\n    row.map(node => ({\r\n      ...node,\r\n      nodeType: NodeType.Unvisited\r\n    }))\r\n  )\r\n","import { Position } from '../models'\r\n\r\nexport const positionsEqual = (pos1: Position, pos2: Position) => pos1.x === pos2.x && pos1.y === pos2.y\r\n\r\nexport const isStart = (position: Position, startPos: Position) => positionsEqual(position, startPos)\r\n\r\nexport const isFinish = (position: Position, finishPos: Position) => positionsEqual(position, finishPos)\r\n\r\nexport const isMidpoint = (position: Position, midpointPos: Position) =>\r\n  midpointPos && positionsEqual(position, midpointPos)\r\n\r\nexport const isEmpty = (position: Position, startPos: Position, finishPos: Position, midpointPos: Position) =>\r\n  !isStart(position, startPos) && !isFinish(position, finishPos) && !isMidpoint(position, midpointPos)\r\n","import * as React from 'react'\nimport {\n  Node,\n  NodeType,\n  Position,\n  MouseState,\n  GRID_W,\n  GRID_H,\n  DEFAULT_START_POS,\n  DEFAULT_FINISH_POS,\n  UPDATE_RATE\n} from './models'\nimport { createRef, FunctionComponent, RefObject, useState } from 'react'\nimport { Cell } from './Cell'\nimport Navbar from './Navbar'\nimport PathfindingAlgorithm from './Algorithms/PathfindingAlgorithm'\nimport MazeGenerator from './mazes/MazeGenerator'\nimport { clearPath, clearWalls, cloneGrid, getDefaultGrid, isEmpty, isFinish, isMidpoint, isStart } from './helpers'\n\nconst references: any[][] = Array(GRID_H)\n  .fill([])\n  .map(() =>\n    Array(GRID_W)\n      .fill(0)\n      .map(() => createRef())\n  )\n\nexport const Pathfinder: FunctionComponent = () => {\n  const [grid, setGrid] = useState<Node[][]>(getDefaultGrid())\n  const [startPos, setStartPos] = useState<Position>(DEFAULT_START_POS)\n  const [finishPos, setFinishPos] = useState<Position>(DEFAULT_FINISH_POS)\n  const [midpointPos, setMidpointPos] = useState<Position | undefined>()\n  const [mouseState, setMouseState] = useState<MouseState>(MouseState.PlacingWall)\n  const [prevAlgorithm, setPrevAlgorithm] = useState<PathfindingAlgorithm | undefined>()\n  const [animating, setAnimating] = useState(false)\n\n  const recalculatePath = (\n    prevAlgorithm: PathfindingAlgorithm,\n    startPos: Position,\n    finishPos: Position,\n    midpointPos?: Position\n  ) => {\n    let newGrid: Node[][] = clearPath(cloneGrid(grid))\n    let visitedPaths: Position[][] = []\n    let finalPaths: Position[][] = []\n    if (!midpointPos) {\n      prevAlgorithm.calculatePath(newGrid, startPos, finishPos)\n      visitedPaths.push(prevAlgorithm.produceVisitedInOrder())\n      finalPaths.push(prevAlgorithm.produceFinalPath())\n    } else {\n      prevAlgorithm.calculatePath(newGrid, startPos, midpointPos)\n      visitedPaths.push(prevAlgorithm.produceVisitedInOrder())\n      finalPaths.push(prevAlgorithm.produceFinalPath())\n\n      prevAlgorithm.calculatePath(newGrid, midpointPos, finishPos)\n      visitedPaths.push(prevAlgorithm.produceVisitedInOrder())\n      finalPaths.push(prevAlgorithm.produceFinalPath())\n    }\n\n    for (let idx = 0; idx < visitedPaths.length; idx++) {\n      let visited: Position[] = visitedPaths[idx]\n      for (let pos of visited) {\n        if (idx === 0) {\n          newGrid[pos.y][pos.x].nodeType = NodeType.VisitedOne\n        } else if (newGrid[pos.y][pos.x].nodeType === NodeType.VisitedOne) {\n          newGrid[pos.y][pos.x].nodeType = NodeType.VisitedOverlap\n        } else {\n          newGrid[pos.y][pos.x].nodeType = NodeType.VisitedTwo\n        }\n      }\n    }\n\n    for (let path of finalPaths) {\n      for (let pos of path) {\n        newGrid[pos.y][pos.x].nodeType = NodeType.ShortestPath\n      }\n    }\n\n    setStartPos(startPos)\n    setFinishPos(finishPos)\n    setMidpointPos(midpointPos)\n    setPrevAlgorithm(prevAlgorithm)\n    setGrid(newGrid)\n  }\n\n  const onMouseUp = () => {\n    setMouseState(MouseState.PlacingWall)\n  }\n\n  const onMouseDown = (position: Position) => {\n    if (animating) return\n    const { nodeType } = grid[position.y][position.x]\n    if (\n      (mouseState === MouseState.MovingStart ||\n        mouseState === MouseState.MovingFinish ||\n        mouseState === MouseState.MovingMidpoint) &&\n      !isEmpty(position, startPos, finishPos, midpointPos)\n    )\n      return\n\n    if (isStart(position, startPos)) {\n      setMouseState(MouseState.MovingStart)\n    } else if (isFinish(position, finishPos)) {\n      setMouseState(MouseState.MovingFinish)\n    } else if (isMidpoint(position, midpointPos)) {\n      setMouseState(MouseState.MovingMidpoint)\n    } else if (nodeType === NodeType.Unvisited) {\n      setMouseState(MouseState.PlacingWall)\n    } else {\n      setMouseState(MouseState.RemovingWall)\n    }\n\n    if (isEmpty(position, startPos, finishPos, midpointPos)) {\n      let clearedGrid = cloneGrid(grid)\n      if (prevAlgorithm) {\n        clearedGrid = clearPath(clearedGrid)\n        setPrevAlgorithm(undefined)\n      }\n      if (nodeType === NodeType.Wall) {\n        clearedGrid[position.y][position.x].nodeType = NodeType.Unvisited\n      } else {\n        clearedGrid[position.y][position.x].nodeType = NodeType.Wall\n      }\n      setGrid(clearedGrid)\n    }\n  }\n\n  const onMouseEnter = (position: Position, isMouseDown: boolean) => {\n    if (animating) return\n    const clonedGrid = cloneGrid(grid)\n    if (\n      !isMouseDown ||\n      isStart(position, startPos) ||\n      isFinish(position, finishPos) ||\n      isMidpoint(position, midpointPos)\n    )\n      return\n\n    switch (mouseState) {\n      case MouseState.MovingStart:\n        if (prevAlgorithm) {\n          recalculatePath(prevAlgorithm, position, finishPos, midpointPos)\n        } else {\n          setStartPos(position)\n        }\n        break\n      case MouseState.MovingFinish:\n        if (prevAlgorithm) {\n          recalculatePath(prevAlgorithm, startPos, position, midpointPos)\n        } else {\n          setFinishPos(position)\n        }\n        break\n      case MouseState.MovingMidpoint:\n        if (prevAlgorithm) {\n          recalculatePath(prevAlgorithm, startPos, finishPos, position)\n        } else {\n          setMidpointPos(position)\n        }\n        break\n      case MouseState.PlacingWall:\n        clonedGrid[position.y][position.x].nodeType = NodeType.Wall\n        setGrid(clonedGrid)\n        break\n      case MouseState.RemovingWall:\n        clonedGrid[position.y][position.x].nodeType = NodeType.Unvisited\n        setGrid(clonedGrid)\n        break\n    }\n  }\n\n  const performAlgorithm = (algorithm: PathfindingAlgorithm): void => {\n    setPrevAlgorithm(algorithm)\n    setMouseState(MouseState.Disabled)\n    const clonedGrid = clearPath(cloneGrid(grid))\n    const visitedPaths: Position[][] = []\n    const finalPaths: Position[][] = []\n    if (!midpointPos) {\n      algorithm.calculatePath(grid, startPos, finishPos)\n      visitedPaths.push(algorithm.produceVisitedInOrder())\n      finalPaths.push(algorithm.produceFinalPath())\n    } else {\n      algorithm.calculatePath(grid, startPos, midpointPos)\n      visitedPaths.push(algorithm.produceVisitedInOrder())\n      finalPaths.push(algorithm.produceFinalPath())\n\n      algorithm.calculatePath(grid, midpointPos, finishPos)\n      visitedPaths.push(algorithm.produceVisitedInOrder())\n      finalPaths.push(algorithm.produceFinalPath())\n    }\n    visualiseAlgorithm(visitedPaths, finalPaths, clonedGrid)\n\n    setGrid(clonedGrid)\n    setMouseState(MouseState.PlacingWall)\n  }\n\n  const visualiseAlgorithm = async (\n    visitedInOrder: Position[][],\n    shortestPath: Position[][],\n    clonedGrid: Node[][]\n  ): Promise<void> => {\n    setAnimating(true)\n\n    for (let idx = 0; idx < visitedInOrder.length; idx++) {\n      let visited: Position[] = visitedInOrder[idx]\n      await visualiseVisited(visited, idx, clonedGrid)\n    }\n    await visualisePath(shortestPath.flat(), clonedGrid)\n    setAnimating(false)\n  }\n\n  const visualiseVisited = (visitedInOrder: Position[], count: number, clonedGrid: Node[][]): Promise<void> => {\n    return new Promise<void>(resolve => {\n      for (let i = 0; i <= visitedInOrder.length; i++) {\n        setTimeout(() => {\n          if (i === visitedInOrder.length) {\n            setTimeout(() => {\n              resolve()\n            }, UPDATE_RATE)\n          } else {\n            let position: Position = visitedInOrder[i]\n            let ref: RefObject<HTMLDivElement> = references[position.y][position.x]\n            let className: string = ref.current.className\n            if (\n              !className.includes('cell-start') &&\n              !className.includes('cell-finish') &&\n              !className.includes('cell-midpoint')\n            ) {\n              if (className.includes('cell-visited-0')) {\n                ref.current.className = `cell cell-visited-overlap`\n              } else {\n                ref.current.className = `cell cell-visited-${count}`\n              }\n              if (count === 0) {\n                clonedGrid[position.y][position.x].nodeType = NodeType.VisitedOne\n              } else if (clonedGrid[position.y][position.x].nodeType === NodeType.VisitedOne) {\n                clonedGrid[position.y][position.x].nodeType = NodeType.VisitedOverlap\n              } else {\n                clonedGrid[position.y][position.x].nodeType = NodeType.VisitedTwo\n              }\n            }\n          }\n        }, UPDATE_RATE * i)\n      }\n    })\n  }\n\n  const visualisePath = (shortestPath: Position[], clonedGrid: Node[][]): Promise<void> => {\n    return new Promise<void>(resolve => {\n      for (let i = 0; i <= shortestPath.length; i++) {\n        setTimeout(() => {\n          if (i === shortestPath.length) {\n            setTimeout(() => {\n              resolve()\n            }, UPDATE_RATE)\n          } else {\n            let position: Position = shortestPath[i]\n            let ref: RefObject<HTMLDivElement> = references[position.y][position.x]\n            let className: string = ref.current.className\n            if (\n              !className.includes('cell-start') &&\n              !className.includes('cell-finish') &&\n              !className.includes('cell-midpoint')\n            ) {\n              ref.current.className = 'cell cell-shortestPath'\n              clonedGrid[position.y][position.x].nodeType = NodeType.ShortestPath\n            }\n          }\n        }, UPDATE_RATE * i)\n      }\n    })\n  }\n\n  const clearGridWalls = () => {\n    references.forEach(refRow =>\n      refRow.forEach(ref => {\n        const className = ref.current.className\n        if (\n          !className.includes('cell-start') &&\n          !className.includes('cell-finish') &&\n          !className.includes('cell-midpoint')\n        ) {\n          ref.current.className = 'cell cell-unvisited'\n        }\n      })\n    )\n  }\n\n  const generateMaze = async (mazeGenerator: MazeGenerator): Promise<void> => {\n    setAnimating(true)\n    setPrevAlgorithm(undefined)\n    clearGridWalls()\n    const clonedGrid = clearWalls(cloneGrid(grid))\n    const setupWalls: Position[] = mazeGenerator.getSetup()\n    const walls: Position[] = mazeGenerator.generateWalls()\n    await setupStartingWalls(setupWalls, clonedGrid)\n    await visualizeMaze(walls, clonedGrid)\n    setGrid(clonedGrid)\n    setMouseState(MouseState.PlacingWall)\n    setAnimating(false)\n  }\n\n  const setupStartingWalls = (walls: Position[], clonedGrid: Node[][]): Promise<void> => {\n    return new Promise<void>(resolve => {\n      for (let i = 0; i <= walls.length; i++) {\n        if (i === walls.length) {\n          setTimeout(() => {\n            resolve()\n          }, 1000)\n        } else {\n          let position = walls[i]\n          let ref: RefObject<HTMLDivElement> = references[position.y][position.x]\n          let className = ref.current.className\n          clonedGrid[position.y][position.x].nodeType = NodeType.Wall\n          if (\n            !className.includes('cell-start') &&\n            !className.includes('cell-finish') &&\n            !className.includes('cell-midpoint')\n          ) {\n            ref.current.className = 'cell cell-wall'\n          }\n        }\n      }\n    })\n  }\n\n  const visualizeMaze = (walls: Position[], clonedGrid: Node[][]): Promise<void> => {\n    return new Promise<void>(resolve => {\n      for (let i = 0; i <= walls.length; i++) {\n        setTimeout(() => {\n          if (i === walls.length) {\n            setTimeout(() => {\n              resolve()\n            }, UPDATE_RATE)\n          } else {\n            let position: Position = walls[i]\n            let ref: RefObject<HTMLDivElement> = references[position.y][position.x]\n            let className: string = ref.current.className\n            if (className.includes('cell-wall')) {\n              if (!className.includes('cell-start') && !className.includes('cell-finish')) {\n                ref.current.className = 'cell cell-unvisited'\n              }\n              clonedGrid[position.y][position.x].nodeType = NodeType.Unvisited\n            } else {\n              if (\n                !className.includes('cell-start') &&\n                !className.includes('cell-finish') &&\n                !className.includes('cell-midpoint')\n              ) {\n                ref.current.className = 'cell cell-wall'\n              }\n              clonedGrid[position.y][position.x].nodeType = NodeType.Wall\n            }\n          }\n        }, UPDATE_RATE * i)\n      }\n    })\n  }\n\n  const setMidpoint = (position: Position): void => {\n    if (animating) return\n    if (!isStart(position, startPos) && !isFinish(position, finishPos)) {\n      setMidpointPos(isMidpoint(position, midpointPos) ? undefined : position)\n      if (prevAlgorithm) {\n        setPrevAlgorithm(undefined)\n      }\n    }\n  }\n\n  const cells = grid.map((row, rowIdx) => (\n    <div className='grid-row' key={rowIdx}>\n      {row.map((node, colIdx) => {\n        const position: Position = { x: colIdx, y: rowIdx }\n        return (\n          <Cell\n            key={`${colIdx}-${rowIdx}`}\n            position={position}\n            onMouseDown={onMouseDown}\n            onMouseEnter={onMouseEnter}\n            onMouseUp={onMouseUp}\n            isStart={isStart(position, startPos)}\n            isFinish={isFinish(position, finishPos)}\n            isMidpoint={isMidpoint(position, midpointPos)}\n            setMidpoint={setMidpoint}\n            nodeType={node.nodeType}\n            nodeRef={references[rowIdx][colIdx]}\n          />\n        )\n      })}\n    </div>\n  ))\n\n  return (\n    <div>\n      <Navbar\n        performAlgorithm={(algorithm: PathfindingAlgorithm) => performAlgorithm(algorithm)}\n        clearPath={() => {\n          setPrevAlgorithm(undefined)\n          setGrid(clearPath(grid))\n        }}\n        clearWall={() => {\n          setPrevAlgorithm(undefined)\n          setGrid(clearWalls(grid))\n        }}\n        generateMaze={(mazeGenerator: MazeGenerator) => {\n          generateMaze(mazeGenerator)\n        }}\n      />\n      <div className='grid'>{cells}</div>\n    </div>\n  )\n}\n","import { Pathfinder } from './Pathfinder'\nimport { FunctionComponent } from 'react'\nimport React from 'react'\n\nexport const App: FunctionComponent = () => {\n  return (\n    <div className='app'>\n      <Pathfinder />\n    </div>\n  )\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport { App } from './App'\n\nimport './index.css'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}